diff --git a/lib/main.dart b/lib/main.dart
index a3b4746..a4d14fb 100644
--- a/lib/main.dart
+++ b/lib/main.dart
@@ -1,19 +1,15 @@
 // lib/main.dart
 import 'dart:io';
 
-import 'package:context_collector/src/features/editor/assets_manager/notifier.dart';
-import 'package:context_collector/src/features/editor/presentation/ui/global_monaco_container.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_providers.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_state.dart';
-import 'package:context_collector/src/features/editor/utils/webview_platform_utils.dart';
-import 'package:context_collector/src/features/scan/presentation/ui/home_screen.dart';
-import 'package:context_collector/src/features/settings/presentation/state/theme_notifier.dart';
-import 'package:context_collector/src/features/settings/services/auto_updater_service.dart';
-import 'package:context_collector/src/shared/theme/app_theme.dart';
+import 'package:context_collector/context_collector.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:window_manager/window_manager.dart';
 
+// Global RouteObserver for tracking navigation events
+final RouteObserver<ModalRoute<void>> routeObserver =
+    RouteObserver<ModalRoute<void>>();
+
 void main() async {
   WidgetsFlutterBinding.ensureInitialized();
 
@@ -35,20 +31,6 @@ void main() async {
     await windowManager.focus();
   });
 
-  // Check platform compatibility first
-  final platformInfo = await WebViewPlatformUtils.getPlatformInfo();
-  debugPrint('WebView Platform Info: $platformInfo');
-
-  // For Windows, check WebView2 availability
-  if (Platform.isWindows && !platformInfo.isSupported) {
-    runApp(
-      const ProviderScope(
-        child: WebView2MissingApp(),
-      ),
-    );
-    return;
-  }
-
   // Create ProviderScope container for early access
   final container = ProviderContainer();
 
@@ -73,20 +55,22 @@ void main() async {
 /// Start Monaco asset copying silently in background - no UI indication
 void _startMonacoAssetsSilently(ProviderContainer container) {
   debugPrint(
-      '[ContextCollector] ü§´ Starting Monaco assets SILENTLY in background...');
+    '[ContextCollector] ü§´ Starting Monaco assets SILENTLY in background...',
+  );
 
   // Fire and forget - completely silent, no UI changes
   container
-      .read(monacoAssetManagerProvider)
-      .initializeAssets()
-      .then((assetPath) {
-    debugPrint(
-        '[ContextCollector] ‚úÖ Monaco assets ready silently at: $assetPath');
-  }).catchError((dynamic error) {
-    // Silent failure - will be retried when user actually needs the editor
-    debugPrint(
-        '[ContextCollector] ‚ö†Ô∏è Silent Monaco asset initialization failed: $error');
-  });
+      .read(monacoProvider.notifier)
+      .initialize()
+      .then((_) {
+        debugPrint('[ContextCollector] ‚úÖ Monaco assets ready silently');
+      })
+      .catchError((dynamic error) {
+        // Silent failure - will be retried when user actually needs the editor
+        debugPrint(
+          '[ContextCollector] ‚ö†Ô∏è Silent Monaco asset initialization failed: $error',
+        );
+      });
 }
 
 /// Start editor preloading - will automatically wait for assets
@@ -97,15 +81,13 @@ void _startEditorPreloading(ProviderContainer container) {
   // and initialize the editor when assets are ready
   container
     ..read(monacoEditorServiceProvider)
-
     // Also listen to status for debugging
-    ..listen<MonacoEditorStatus>(
+    ..listen<EditorStatus>(
       monacoEditorStatusProvider,
       (previous, next) {
         debugPrint(
-            '[ContextCollector] Editor status changed: ${previous?.state} ‚Üí ${next.state}');
-        debugPrint('  Progress: ${(next.progress * 100).toInt()}%');
-        debugPrint('  Is Visible: ${next.isVisible}');
+          '[ContextCollector] Editor status changed: ${previous?.lifecycle} ‚Üí ${next.lifecycle}',
+        );
         debugPrint('  Has Content: ${next.hasContent}');
         if (next.error != null) {
           debugPrint('  Error: ${next.error}');
@@ -116,7 +98,8 @@ void _startEditorPreloading(ProviderContainer container) {
   // Check initial state
   final initialStatus = container.read(monacoEditorStatusProvider);
   debugPrint(
-      '[ContextCollector] Initial editor status: ${initialStatus.state}');
+    '[ContextCollector] Initial editor status: ${initialStatus.lifecycle}',
+  );
 }
 
 /// Initialize auto updater for automatic updates
@@ -124,75 +107,27 @@ void _initializeAutoUpdater(ProviderContainer container) {
   // Only initialize on supported platforms
   if (!Platform.isMacOS && !Platform.isWindows) {
     debugPrint(
-        '[ContextCollector] Auto updater not supported on this platform');
+      '[ContextCollector] Auto updater not supported on this platform',
+    );
     return;
   }
 
   debugPrint('[ContextCollector] üîÑ Initializing auto updater...');
 
   // Initialize auto updater service
-  container.read(autoUpdaterServiceProvider).initialize().then((_) {
-    debugPrint('[ContextCollector] ‚úÖ Auto updater initialized successfully');
-  }).catchError((dynamic error) {
-    debugPrint(
-        '[ContextCollector] ‚ö†Ô∏è Auto updater initialization failed: $error');
-  });
-}
-
-class WebView2MissingApp extends StatelessWidget {
-  const WebView2MissingApp({super.key});
-
-  @override
-  Widget build(BuildContext context) {
-    return MaterialApp(
-      title: 'Context Collector',
-      theme: AppTheme.lightTheme,
-      home: Scaffold(
-        body: Center(
-          child: Padding(
-            padding: const EdgeInsets.all(32),
-            child: Column(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                const Icon(
-                  Icons.warning_amber_rounded,
-                  size: 64,
-                  color: Colors.orange,
-                ),
-                const SizedBox(height: 16),
-                const Text(
-                  'WebView2 Runtime Required',
-                  style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
-                ),
-                const SizedBox(height: 8),
-                const Text(
-                  'Context Collector requires Microsoft Edge WebView2 Runtime to function on Windows.',
-                  textAlign: TextAlign.center,
-                ),
-                const SizedBox(height: 16),
-                Consumer(
-                  builder: (context, ref, child) {
-                    return ElevatedButton.icon(
-                      onPressed: () =>
-                          WebViewPlatformUtils.showWebView2InstallDialog(
-                              context),
-                      icon: const Icon(Icons.download),
-                      label: const Text('Install WebView2 Runtime'),
-                    );
-                  },
-                ),
-                const SizedBox(height: 8),
-                const TextButton(
-                  onPressed: main,
-                  child: Text('Recheck After Installation'),
-                ),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
+  container
+      .read(autoUpdaterServiceProvider)
+      .initialize()
+      .then((_) {
+        debugPrint(
+          '[ContextCollector] ‚úÖ Auto updater initialized successfully',
+        );
+      })
+      .catchError((dynamic error) {
+        debugPrint(
+          '[ContextCollector] ‚ö†Ô∏è Auto updater initialization failed: $error',
+        );
+      });
 }
 
 class ContextCollectorApp extends ConsumerWidget {
@@ -207,134 +142,17 @@ class ContextCollectorApp extends ConsumerWidget {
       theme: AppTheme.lightTheme,
       darkTheme: AppTheme.darkTheme,
       themeMode: themeMode,
+      // Register the route observer for navigation tracking
+      navigatorObservers: [routeObserver],
       home: WebViewPlatformUtils.buildCompatibilityChecker(
         // Wrap with GlobalMonacoContainer to ensure editor is always present
         child: const GlobalMonacoContainer(
-          child: HomeScreen(),
+          child: HomeScreenWithDrop(),
         ),
-        fallback: const UnsupportedPlatformScreen(),
+        // The fallback is handled by buildCompatibilityChecker itself
+        fallback: const SizedBox.shrink(),
       ),
       debugShowCheckedModeBanner: false,
     );
   }
 }
-
-class UnsupportedPlatformScreen extends ConsumerWidget {
-  const UnsupportedPlatformScreen({super.key});
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final theme = Theme.of(context);
-
-    return Scaffold(
-      appBar: AppBar(
-        title: const Text('Context Collector'),
-      ),
-      body: Center(
-        child: Padding(
-          padding: const EdgeInsets.all(32),
-          child: Column(
-            mainAxisAlignment: MainAxisAlignment.center,
-            children: [
-              Icon(
-                Platform.isWindows
-                    ? Icons.warning_amber_rounded
-                    : Icons.devices_other,
-                size: 64,
-                color: theme.colorScheme.error,
-              ),
-              const SizedBox(height: 16),
-              Text(
-                Platform.isWindows
-                    ? 'WebView2 Runtime Missing'
-                    : 'Platform Not Supported',
-                style: theme.textTheme.headlineSmall?.copyWith(
-                  color: theme.colorScheme.error,
-                  fontWeight: FontWeight.bold,
-                ),
-              ),
-              const SizedBox(height: 8),
-              Text(
-                'Context Collector requires a supported WebView implementation.',
-                textAlign: TextAlign.center,
-                style: theme.textTheme.bodyLarge,
-              ),
-              const SizedBox(height: 24),
-              Container(
-                padding: const EdgeInsets.all(16),
-                decoration: BoxDecoration(
-                  color: theme.colorScheme.surfaceContainer,
-                  borderRadius: BorderRadius.circular(12),
-                ),
-                child: Column(
-                  crossAxisAlignment: CrossAxisAlignment.start,
-                  children: [
-                    Text(
-                      'Supported Platforms:',
-                      style: theme.textTheme.titleSmall?.copyWith(
-                        fontWeight: FontWeight.bold,
-                      ),
-                    ),
-                    const SizedBox(height: 8),
-                    ...[
-                      'Windows 10/11 with WebView2 Runtime',
-                      'macOS 10.13 or later',
-                    ].map(
-                      (platform) => Padding(
-                        padding: const EdgeInsets.only(bottom: 4),
-                        child: Row(
-                          children: [
-                            Icon(
-                              Icons.check_circle_outline,
-                              size: 16,
-                              color: theme.colorScheme.primary,
-                            ),
-                            const SizedBox(width: 8),
-                            Expanded(
-                              child: Text(
-                                platform,
-                                style: theme.textTheme.bodySmall,
-                              ),
-                            ),
-                          ],
-                        ),
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-              const SizedBox(height: 24),
-              if (Platform.isWindows) ...[
-                FilledButton.icon(
-                  onPressed: () =>
-                      WebViewPlatformUtils.showWebView2InstallDialog(context),
-                  icon: const Icon(Icons.download),
-                  label: const Text('Install WebView2 Runtime'),
-                ),
-                const SizedBox(height: 8),
-                TextButton.icon(
-                  onPressed: () async {
-                    final newInfo =
-                        await WebViewPlatformUtils.getPlatformInfo();
-                    if (newInfo.isSupported && context.mounted) {
-                      main();
-                    }
-                  },
-                  icon: const Icon(Icons.refresh),
-                  label: const Text('Recheck After Installation'),
-                ),
-              ] else ...[
-                OutlinedButton(
-                  onPressed: () {
-                    // Could show more platform-specific information
-                  },
-                  child: const Text('Learn More'),
-                ),
-              ],
-            ],
-          ),
-        ),
-      ),
-    );
-  }
-}
diff --git a/lib/src/context_collector.dart b/lib/src/context_collector.dart
index e6aee0a..29b119c 100644
--- a/lib/src/context_collector.dart
+++ b/lib/src/context_collector.dart
@@ -2,4 +2,5 @@ export '../main.dart';
 export 'features/editor/editor.dart';
 export 'features/scan/scan.dart';
 export 'features/settings/settings.dart';
+export 'features/virtual_tree/virtual_tree.dart';
 export 'shared/shared.dart';
diff --git a/lib/src/features/editor/assets_manager/notifier.dart b/lib/src/features/editor/assets_manager/notifier.dart
deleted file mode 100644
index 3e5a04e..0000000
--- a/lib/src/features/editor/assets_manager/notifier.dart
+++ /dev/null
@@ -1,536 +0,0 @@
-// lib/src/features/editor/services/monaco_asset_manager.dart
-import 'dart:async';
-import 'dart:io';
-import 'dart:math';
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:path/path.dart' as path;
-import 'package:path_provider/path_provider.dart';
-
-/// States for Monaco asset management
-enum MonacoAssetState {
-  idle,
-  initializing,
-  copying,
-  verifying,
-  ready,
-  error,
-  retrying,
-}
-
-/// Detailed asset preparation status
-class MonacoAssetStatus {
-  const MonacoAssetStatus({
-    required this.state,
-    this.progress = 0.0,
-    this.message,
-    this.error,
-    this.assetPath,
-    this.retryCount = 0,
-    this.lastUpdate,
-  });
-
-  final MonacoAssetState state;
-  final double progress;
-  final String? message;
-  final String? error;
-  final String? assetPath;
-  final int retryCount;
-  final DateTime? lastUpdate;
-
-  MonacoAssetStatus copyWith({
-    MonacoAssetState? state,
-    double? progress,
-    String? message,
-    String? error,
-    String? assetPath,
-    int? retryCount,
-    DateTime? lastUpdate,
-  }) {
-    return MonacoAssetStatus(
-      state: state ?? this.state,
-      progress: progress ?? this.progress,
-      message: message ?? this.message,
-      error: error ?? this.error,
-      assetPath: assetPath ?? this.assetPath,
-      retryCount: retryCount ?? this.retryCount,
-      lastUpdate: lastUpdate ?? this.lastUpdate,
-    );
-  }
-
-  bool get isReady => state == MonacoAssetState.ready;
-
-  bool get isLoading => [
-        MonacoAssetState.initializing,
-        MonacoAssetState.copying,
-        MonacoAssetState.verifying,
-        MonacoAssetState.retrying,
-      ].contains(state);
-
-  bool get hasError => state == MonacoAssetState.error;
-
-  @override
-  String toString() =>
-      'MonacoAssetStatus(state: $state, progress: ${(progress * 100).toInt()}%, message: $message)';
-}
-
-/// Monaco Asset Manager - Core service class
-class MonacoAssetManager {
-  MonacoAssetManager(this._ref);
-
-  static const String _assetBaseDir = 'assets/monaco';
-  static const String _cacheSubDir = 'monaco_editor_cache';
-  static const int _maxRetries = 3;
-  static const Duration _retryDelay = Duration(seconds: 2);
-
-  final Ref _ref;
-  String? _cachedAssetPath;
-  Timer? _retryTimer;
-  Completer<String>? _initCompleter;
-
-  /// Initialize Monaco assets - main entry point
-  Future<String> initializeAssets() async {
-    debugPrint('[MonacoAssetManager] Starting asset initialization');
-
-    // Return cached path if already ready
-    if (_cachedAssetPath != null) {
-      debugPrint(
-          '[MonacoAssetManager] Assets already ready at: $_cachedAssetPath');
-      return _cachedAssetPath!;
-    }
-
-    // If initialization is already in progress, wait for it
-    if (_initCompleter != null) {
-      debugPrint('[MonacoAssetManager] Initialization in progress, waiting...');
-      return _initCompleter!.future;
-    }
-
-    _initCompleter = Completer<String>();
-
-    try {
-      await _performInitialization();
-      final assetPath = _cachedAssetPath!;
-      _initCompleter!.complete(assetPath);
-      return assetPath;
-    } catch (e) {
-      _initCompleter!.completeError(e);
-      rethrow;
-    } finally {
-      _initCompleter = null;
-    }
-  }
-
-  /// Perform the actual initialization process
-  Future<void> _performInitialization() async {
-    _updateStatus(MonacoAssetStatus(
-      state: MonacoAssetState.initializing,
-      message: 'Preparing Monaco Editor assets...',
-      lastUpdate: DateTime.now(),
-    ));
-
-    try {
-      // Step 1: Determine target directory
-      final targetDir = await _getTargetDirectory();
-      debugPrint('[MonacoAssetManager] Target directory: $targetDir');
-
-      // Step 2: Check if assets are already prepared and valid
-      if (await _validateExistingAssets(targetDir)) {
-        debugPrint('[MonacoAssetManager] Valid assets found, skipping copy');
-        _cachedAssetPath = targetDir;
-        _updateStatus(MonacoAssetStatus(
-          state: MonacoAssetState.ready,
-          progress: 1,
-          message: 'Monaco Editor assets ready',
-          assetPath: targetDir,
-          lastUpdate: DateTime.now(),
-        ));
-        return;
-      }
-
-      // Step 3: Copy all Monaco assets
-      await _copyAllAssets(targetDir);
-
-      // Step 4: Verify the copied assets
-      await _verifyAssets(targetDir);
-
-      // Step 5: Cache the path and mark as ready
-      _cachedAssetPath = targetDir;
-      _updateStatus(MonacoAssetStatus(
-        state: MonacoAssetState.ready,
-        progress: 1,
-        message: 'Monaco Editor assets ready',
-        assetPath: targetDir,
-        lastUpdate: DateTime.now(),
-      ));
-
-      debugPrint(
-          '[MonacoAssetManager] Asset initialization completed successfully');
-    } catch (e) {
-      await _handleInitializationError(e);
-    }
-  }
-
-  /// Get the target directory for Monaco assets
-  Future<String> _getTargetDirectory() async {
-    if (Platform.isWindows || Platform.isMacOS) {
-      // Desktop: Use app support directory for persistent caching
-      final appDir = await getApplicationSupportDirectory();
-      return path.join(appDir.path, _cacheSubDir);
-    } else {
-      // Unsupported platform
-      throw UnsupportedError(
-          'Context Collector only supports macOS and Windows');
-    }
-  }
-
-  /// Validate existing assets to avoid unnecessary copying
-  Future<bool> _validateExistingAssets(String targetDir) async {
-    _updateStatus(MonacoAssetStatus(
-      state: MonacoAssetState.verifying,
-      progress: 0.1,
-      message: 'Checking existing assets...',
-      lastUpdate: DateTime.now(),
-    ));
-
-    try {
-      // Check if essential Monaco files exist
-      final vsDir =
-          Directory(path.join(targetDir, 'monaco-editor', 'min', 'vs'));
-      if (!vsDir.existsSync()) return false;
-
-      final essentialFiles = [
-        'loader.js',
-        'editor/editor.main.js',
-        'editor/editor.main.css',
-      ];
-
-      for (final file in essentialFiles) {
-        final filePath = path.join(vsDir.path, file);
-        if (!File(filePath).existsSync()) {
-          debugPrint('[MonacoAssetManager] Missing essential file: $file');
-          return false;
-        }
-      }
-
-      // Check if assets are reasonably recent (less than 30 days old)
-      final loaderFile = File(path.join(vsDir.path, 'loader.js'));
-      final stat = loaderFile.statSync();
-      final age = DateTime.now().difference(stat.modified);
-      if (age.inDays > 30) {
-        debugPrint(
-            '[MonacoAssetManager] Assets are old (${age.inDays} days), refreshing');
-        return false;
-      }
-
-      debugPrint('[MonacoAssetManager] Existing assets are valid');
-      return true;
-    } catch (e) {
-      debugPrint('[MonacoAssetManager] Asset validation error: $e');
-      return false;
-    }
-  }
-
-  /// Copy all Monaco assets with progress tracking
-  Future<void> _copyAllAssets(String targetDir) async {
-    _updateStatus(MonacoAssetStatus(
-      state: MonacoAssetState.copying,
-      progress: 0.2,
-      message: 'Copying Monaco Editor files...',
-      lastUpdate: DateTime.now(),
-    ));
-
-    try {
-      // Clean target directory
-      final targetDirectory = Directory(targetDir);
-      if (targetDirectory.existsSync()) {
-        await targetDirectory.delete(recursive: true);
-      }
-      await targetDirectory.create(recursive: true);
-
-      // Get all Monaco assets
-      final assetManifest = await AssetManifest.loadFromAssetBundle(rootBundle);
-      final monacoAssets = assetManifest
-          .listAssets()
-          .where((key) => key.startsWith(_assetBaseDir))
-          .toList();
-
-      debugPrint(
-          '[MonacoAssetManager] Found ${monacoAssets.length} Monaco assets to copy');
-
-      if (monacoAssets.isEmpty) {
-        throw Exception('No Monaco assets found in bundle');
-      }
-
-      // Copy assets with progress tracking
-      var copiedCount = 0;
-      const batchSize = 10;
-
-      for (var i = 0; i < monacoAssets.length; i += batchSize) {
-        final batch = monacoAssets.skip(i).take(batchSize);
-
-        await Future.wait(
-          batch.map((assetKey) => _copyAssetFile(assetKey, targetDir)),
-        );
-
-        copiedCount += batch.length;
-        final progress =
-            0.2 + (copiedCount / monacoAssets.length) * 0.6; // 20% to 80%
-
-        _updateStatus(MonacoAssetStatus(
-          state: MonacoAssetState.copying,
-          progress: progress,
-          message:
-              'Copying Monaco assets ($copiedCount/${monacoAssets.length})...',
-          lastUpdate: DateTime.now(),
-        ));
-      }
-
-      debugPrint(
-          '[MonacoAssetManager] Successfully copied ${monacoAssets.length} assets');
-    } catch (e) {
-      debugPrint('[MonacoAssetManager] Asset copying failed: $e');
-      rethrow;
-    }
-  }
-
-  /// Copy a single asset file
-  Future<void> _copyAssetFile(String assetKey, String targetDir) async {
-    try {
-      final relativePath = assetKey.substring('$_assetBaseDir/'.length);
-      if (relativePath.isEmpty) return;
-
-      final targetPath = path.join(targetDir, relativePath);
-      final targetFile = File(targetPath);
-
-      // Create parent directories
-      await targetFile.parent.create(recursive: true);
-
-      // Copy the asset
-      final bytes = await rootBundle.load(assetKey);
-      await targetFile.writeAsBytes(bytes.buffer.asUint8List());
-    } catch (e) {
-      debugPrint('[MonacoAssetManager] Failed to copy $assetKey: $e');
-      // Don't rethrow - some assets might be directories or have permission issues
-    }
-  }
-
-  /// Verify that the copied assets are complete
-  Future<void> _verifyAssets(String targetDir) async {
-    _updateStatus(MonacoAssetStatus(
-      state: MonacoAssetState.verifying,
-      progress: 0.9,
-      message: 'Verifying Monaco assets...',
-      lastUpdate: DateTime.now(),
-    ));
-
-    try {
-      // Verify essential Monaco files exist and are non-empty
-      final vsDir =
-          Directory(path.join(targetDir, 'monaco-editor', 'min', 'vs'));
-
-      final essentialFiles = [
-        'loader.js',
-        'editor/editor.main.js',
-        'editor/editor.main.css',
-      ];
-
-      for (final file in essentialFiles) {
-        final filePath = path.join(vsDir.path, file);
-        final fileObj = File(filePath);
-
-        if (!fileObj.existsSync()) {
-          throw Exception('Essential file missing: $file');
-        }
-
-        final size = await fileObj.length();
-        if (size == 0) {
-          throw Exception('Essential file is empty: $file');
-        }
-      }
-
-      debugPrint('[MonacoAssetManager] Asset verification completed');
-    } catch (e) {
-      debugPrint('[MonacoAssetManager] Asset verification failed: $e');
-      rethrow;
-    }
-  }
-
-  /// Handle initialization errors with retry logic
-  Future<void> _handleInitializationError(dynamic error) async {
-    final currentStatus = _ref.read(monacoAssetStatusProvider);
-    final newRetryCount = currentStatus.retryCount + 1;
-
-    debugPrint(
-        '[MonacoAssetManager] Initialization error (attempt $newRetryCount): $error');
-
-    if (newRetryCount >= _maxRetries) {
-      _updateStatus(MonacoAssetStatus(
-        state: MonacoAssetState.error,
-        error:
-            'Failed to initialize Monaco assets after $_maxRetries attempts: $error',
-        retryCount: newRetryCount,
-        lastUpdate: DateTime.now(),
-      ));
-      throw Exception('Monaco asset initialization failed: $error');
-    }
-
-    // Exponential backoff for retries
-    final retryDelay = Duration(
-      milliseconds:
-          _retryDelay.inMilliseconds * pow(2, newRetryCount - 1).toInt(),
-    );
-
-    _updateStatus(MonacoAssetStatus(
-      state: MonacoAssetState.retrying,
-      message:
-          'Retrying in ${retryDelay.inSeconds} seconds (attempt $newRetryCount/$_maxRetries)...',
-      error: error.toString(),
-      retryCount: newRetryCount,
-      lastUpdate: DateTime.now(),
-    ));
-
-    _retryTimer = Timer(retryDelay, () {
-      debugPrint(
-          '[MonacoAssetManager] Retrying initialization (attempt $newRetryCount)');
-      _performInitialization();
-    });
-  }
-
-  /// Manual retry method for external triggers
-  Future<String> retryInitialization() async {
-    debugPrint('[MonacoAssetManager] Manual retry requested');
-    _retryTimer?.cancel();
-    _cachedAssetPath = null;
-    _initCompleter = null;
-    return initializeAssets();
-  }
-
-  /// Clean up cached assets
-  Future<void> clearCache() async {
-    debugPrint('[MonacoAssetManager] Clearing Monaco asset cache');
-
-    try {
-      _retryTimer?.cancel();
-      _cachedAssetPath = null;
-      _initCompleter = null;
-
-      final targetDir = await _getTargetDirectory();
-      final directory = Directory(targetDir);
-
-      if (directory.existsSync()) {
-        await directory.delete(recursive: true);
-        debugPrint('[MonacoAssetManager] Cache cleared successfully');
-      }
-
-      _updateStatus(MonacoAssetStatus(
-        state: MonacoAssetState.idle,
-        message: 'Cache cleared',
-        lastUpdate: DateTime.now(),
-      ));
-    } catch (e) {
-      debugPrint('[MonacoAssetManager] Error clearing cache: $e');
-    }
-  }
-
-  /// Update status through Riverpod
-  void _updateStatus(MonacoAssetStatus status) {
-    _ref.read(monacoAssetStatusProvider.notifier).updateStatus(status);
-  }
-
-  /// Get current asset path (null if not ready)
-  String? get assetPath => _cachedAssetPath;
-
-  /// Dispose resources
-  void dispose() {
-    _retryTimer?.cancel();
-    _initCompleter = null;
-  }
-}
-
-/// Riverpod notifier for Monaco asset status
-class MonacoAssetStatusNotifier extends StateNotifier<MonacoAssetStatus> {
-  MonacoAssetStatusNotifier()
-      : super(const MonacoAssetStatus(state: MonacoAssetState.idle));
-
-  void updateStatus(MonacoAssetStatus status) {
-    state = status;
-    debugPrint('[MonacoAssetStatusNotifier] Status updated: $status');
-  }
-
-  void reset() {
-    state = const MonacoAssetStatus(state: MonacoAssetState.idle);
-  }
-}
-
-/// Riverpod providers for Monaco asset management
-final monacoAssetStatusProvider =
-    StateNotifierProvider<MonacoAssetStatusNotifier, MonacoAssetStatus>((ref) {
-  return MonacoAssetStatusNotifier();
-});
-
-final monacoAssetManagerProvider = Provider<MonacoAssetManager>((ref) {
-  final manager = MonacoAssetManager(ref);
-  ref.onDispose(manager.dispose);
-  return manager;
-});
-
-/// Convenient provider for checking if assets are ready
-final monacoAssetsReadyProvider = Provider<bool>((ref) {
-  final status = ref.watch(monacoAssetStatusProvider);
-  return status.isReady;
-});
-
-/// Provider for getting the asset path when ready
-final monacoAssetPathProvider = Provider<String?>((ref) {
-  final status = ref.watch(monacoAssetStatusProvider);
-  return status.isReady ? status.assetPath : null;
-});
-
-/// Extension methods for easier usage
-extension MonacoAssetManagerX on MonacoAssetManager {
-  /// Wait for assets to be ready with timeout
-  Future<String> waitForAssets({Duration? timeout}) async {
-    final completer = Completer<String>();
-    Timer? timeoutTimer;
-    ProviderSubscription? subscription;
-
-    if (timeout != null) {
-      timeoutTimer = Timer(timeout, () {
-        if (!completer.isCompleted) {
-          completer.completeError(TimeoutException(
-              'Monaco assets not ready within timeout', timeout));
-        }
-      });
-    }
-
-    // Listen for status changes
-    subscription = _ref.listen<MonacoAssetStatus>(
-      monacoAssetStatusProvider,
-      (previous, next) {
-        if (next.isReady && !completer.isCompleted) {
-          completer.complete(next.assetPath!);
-        } else if (next.hasError && !completer.isCompleted) {
-          completer.completeError(Exception(next.error));
-        }
-      },
-    );
-
-    // Check current state
-    final currentStatus = _ref.read(monacoAssetStatusProvider);
-    if (currentStatus.isReady) {
-      completer.complete(currentStatus.assetPath!);
-    } else if (currentStatus.hasError) {
-      completer.completeError(Exception(currentStatus.error));
-    }
-
-    try {
-      final result = await completer.future;
-      return result;
-    } finally {
-      timeoutTimer?.cancel();
-      subscription.close();
-    }
-  }
-}
diff --git a/lib/src/features/editor/assets_manager/widget.dart b/lib/src/features/editor/assets_manager/widget.dart
deleted file mode 100644
index fd83549..0000000
--- a/lib/src/features/editor/assets_manager/widget.dart
+++ /dev/null
@@ -1,520 +0,0 @@
-// lib/src/features/editor/presentation/ui/monaco_asset_loading_widget.dart
-import 'dart:async';
-
-import 'package:context_collector/context_collector.dart';
-import 'package:context_collector/src/features/editor/assets_manager/notifier.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-/// Widget that shows Monaco asset loading progress
-class MonacoAssetLoadingWidget extends ConsumerWidget {
-  const MonacoAssetLoadingWidget({
-    super.key,
-    this.onReady,
-    this.showDetails = true,
-    this.compact = false,
-  });
-
-  final VoidCallback? onReady;
-  final bool showDetails;
-  final bool compact;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final status = ref.watch(monacoAssetStatusProvider);
-
-    // Trigger callback when ready
-    ref.listen<MonacoAssetStatus>(monacoAssetStatusProvider, (previous, next) {
-      if (next.isReady && previous?.state != MonacoAssetState.ready) {
-        onReady?.call();
-      }
-    });
-
-    if (status.isReady) {
-      return _buildReadyState(context);
-    }
-
-    if (compact) {
-      return _buildCompactLoading(context, status);
-    }
-
-    return _buildFullLoading(context, status, ref);
-  }
-
-  Widget _buildReadyState(BuildContext context) {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(16),
-      decoration: BoxDecoration(
-        color: context.primaryContainer,
-        borderRadius: BorderRadius.circular(8),
-      ),
-      child: Row(
-        mainAxisSize: MainAxisSize.min,
-        children: [
-          Icon(
-            Icons.check_circle,
-            color: context.primary,
-            size: 20,
-          ),
-          const SizedBox(width: 8),
-          Text(
-            'Monaco Editor Ready',
-            style: context.bodyMedium?.copyWith(
-              color: context.onPrimaryContainer,
-              fontWeight: FontWeight.w500,
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildCompactLoading(BuildContext context, MonacoAssetStatus status) {
-    return Container(
-      padding:
-          const EdgeInsetsDirectional.symmetric(horizontal: 12, vertical: 8),
-      decoration: BoxDecoration(
-        color: context.surfaceContainerHighest,
-        borderRadius: BorderRadius.circular(6),
-      ),
-      child: Row(
-        mainAxisSize: MainAxisSize.min,
-        children: [
-          SizedBox(
-            width: 16,
-            height: 16,
-            child: CircularProgressIndicator(
-              strokeWidth: 2,
-              value: status.progress > 0 ? status.progress : null,
-            ),
-          ),
-          const SizedBox(width: 8),
-          Text(
-            _getStatusText(status),
-            style: context.bodySmall?.copyWith(
-              color: context.onSurfaceVariant,
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildFullLoading(
-      BuildContext context, MonacoAssetStatus status, WidgetRef ref) {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        mainAxisSize: MainAxisSize.min,
-        children: [
-          // Header
-          Row(
-            children: [
-              Container(
-                padding: const EdgeInsetsDirectional.all(12),
-                decoration: BoxDecoration(
-                  color: context.primaryContainer,
-                  borderRadius: BorderRadius.circular(12),
-                ),
-                child: Icon(
-                  Icons.code,
-                  color: context.primary,
-                  size: 24,
-                ),
-              ),
-              const SizedBox(width: 16),
-              Expanded(
-                child: Column(
-                  crossAxisAlignment: CrossAxisAlignment.start,
-                  children: [
-                    Text(
-                      'Preparing Monaco Editor',
-                      style: context.titleMedium?.copyWith(
-                        fontWeight: FontWeight.w600,
-                      ),
-                    ),
-                    const SizedBox(height: 4),
-                    Text(
-                      'Setting up the code editor for optimal performance',
-                      style: context.bodySmall?.copyWith(
-                        color: context.onSurfaceVariant,
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-            ],
-          ),
-
-          const SizedBox(height: 24),
-
-          // Progress indicator
-          Column(
-            children: [
-              Row(
-                children: [
-                  Expanded(
-                    child: LinearProgressIndicator(
-                      value: status.progress > 0 ? status.progress : null,
-                      backgroundColor: context.surfaceContainerHighest,
-                      borderRadius: BorderRadius.circular(4),
-                    ),
-                  ),
-                  const SizedBox(width: 12),
-                  Text(
-                    '${(status.progress * 100).toInt()}%',
-                    style: context.bodySmall?.copyWith(
-                      color: context.onSurfaceVariant,
-                      fontWeight: FontWeight.w500,
-                    ),
-                  ),
-                ],
-              ),
-              const SizedBox(height: 12),
-              Row(
-                children: [
-                  _buildStatusIcon(context, status),
-                  const SizedBox(width: 8),
-                  Expanded(
-                    child: Text(
-                      status.message ?? _getStatusText(status),
-                      style: context.bodyMedium,
-                    ),
-                  ),
-                ],
-              ),
-            ],
-          ),
-
-          if (showDetails) ...[
-            const SizedBox(height: 16),
-            _buildDetailsSection(context, status, ref),
-          ],
-
-          if (status.hasError) ...[
-            const SizedBox(height: 16),
-            _buildErrorSection(context, status, ref),
-          ],
-        ],
-      ),
-    );
-  }
-
-  Widget _buildStatusIcon(BuildContext context, MonacoAssetStatus status) {
-    switch (status.state) {
-      case MonacoAssetState.idle:
-        return Icon(Icons.hourglass_empty,
-            size: 16, color: context.onSurfaceVariant);
-      case MonacoAssetState.initializing:
-        return SizedBox(
-          width: 16,
-          height: 16,
-          child:
-              CircularProgressIndicator(strokeWidth: 2, color: context.primary),
-        );
-      case MonacoAssetState.copying:
-        return Icon(Icons.download, size: 16, color: context.primary);
-      case MonacoAssetState.verifying:
-        return Icon(Icons.verified, size: 16, color: context.primary);
-      case MonacoAssetState.ready:
-        return Icon(Icons.check_circle, size: 16, color: context.primary);
-      case MonacoAssetState.error:
-        return Icon(Icons.error, size: 16, color: context.error);
-      case MonacoAssetState.retrying:
-        return SizedBox(
-          width: 16,
-          height: 16,
-          child: CircularProgressIndicator(
-              strokeWidth: 2, color: context.secondary),
-        );
-    }
-  }
-
-  Widget _buildDetailsSection(
-      BuildContext context, MonacoAssetStatus status, WidgetRef ref) {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(12),
-      decoration: BoxDecoration(
-        color: context.surfaceContainerHighest,
-        borderRadius: BorderRadius.circular(8),
-      ),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          Row(
-            children: [
-              Icon(
-                Icons.info_outline,
-                size: 16,
-                color: context.onSurfaceVariant,
-              ),
-              const SizedBox(width: 8),
-              Text(
-                'Details',
-                style: context.bodySmall?.copyWith(
-                  color: context.onSurfaceVariant,
-                  fontWeight: FontWeight.w500,
-                ),
-              ),
-            ],
-          ),
-          const SizedBox(height: 8),
-          _buildDetailRow(context, 'Status', _getStatusText(status)),
-          if (status.progress > 0)
-            _buildDetailRow(
-                context, 'Progress', '${(status.progress * 100).toInt()}%'),
-          if (status.retryCount > 0)
-            _buildDetailRow(
-                context, 'Retry Count', status.retryCount.toString()),
-          if (status.lastUpdate != null)
-            _buildDetailRow(
-                context, 'Last Update', _formatTime(status.lastUpdate!)),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildDetailRow(BuildContext context, String label, String value) {
-    return Padding(
-      padding: const EdgeInsetsDirectional.only(bottom: 4),
-      child: Row(
-        children: [
-          SizedBox(
-            width: 80,
-            child: Text(
-              label,
-              style: context.bodySmall?.copyWith(
-                color: context.onSurfaceVariant,
-              ),
-            ),
-          ),
-          const SizedBox(width: 8),
-          Expanded(
-            child: Text(
-              value,
-              style: context.bodySmall?.copyWith(
-                fontWeight: FontWeight.w500,
-              ),
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildErrorSection(
-      BuildContext context, MonacoAssetStatus status, WidgetRef ref) {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(16),
-      decoration: BoxDecoration(
-        color: context.errorContainer,
-        borderRadius: BorderRadius.circular(8),
-      ),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          Row(
-            children: [
-              Icon(
-                Icons.error_outline,
-                color: context.onErrorContainer,
-                size: 20,
-              ),
-              const SizedBox(width: 8),
-              Text(
-                'Initialization Failed',
-                style: context.titleSmall?.copyWith(
-                  color: context.onErrorContainer,
-                  fontWeight: FontWeight.w600,
-                ),
-              ),
-            ],
-          ),
-          const SizedBox(height: 8),
-          Text(
-            status.error ?? 'Unknown error occurred',
-            style: context.bodySmall?.copyWith(
-              color: context.onErrorContainer,
-            ),
-          ),
-          const SizedBox(height: 12),
-          Row(
-            children: [
-              OutlinedButton.icon(
-                onPressed: () =>
-                    ref.read(monacoAssetManagerProvider).retryInitialization(),
-                icon: const Icon(Icons.refresh),
-                label: const Text('Retry'),
-                style: OutlinedButton.styleFrom(
-                  foregroundColor: context.onErrorContainer,
-                  side: BorderSide(color: context.onErrorContainer),
-                ),
-              ),
-              const SizedBox(width: 8),
-              TextButton.icon(
-                onPressed: () =>
-                    ref.read(monacoAssetManagerProvider).clearCache(),
-                icon: const Icon(Icons.clear_all),
-                label: const Text('Clear Cache'),
-                style: TextButton.styleFrom(
-                  foregroundColor: context.onErrorContainer,
-                ),
-              ),
-            ],
-          ),
-        ],
-      ),
-    );
-  }
-
-  String _getStatusText(MonacoAssetStatus status) {
-    switch (status.state) {
-      case MonacoAssetState.idle:
-        return 'Ready to initialize';
-      case MonacoAssetState.initializing:
-        return 'Initializing...';
-      case MonacoAssetState.copying:
-        return 'Copying assets...';
-      case MonacoAssetState.verifying:
-        return 'Verifying assets...';
-      case MonacoAssetState.ready:
-        return 'Ready';
-      case MonacoAssetState.error:
-        return 'Error occurred';
-      case MonacoAssetState.retrying:
-        return 'Retrying...';
-    }
-  }
-
-  String _formatTime(DateTime dateTime) {
-    final now = DateTime.now();
-    final difference = now.difference(dateTime);
-
-    if (difference.inMinutes < 1) {
-      return 'Just now';
-    } else if (difference.inHours < 1) {
-      return '${difference.inMinutes}m ago';
-    } else {
-      return '${difference.inHours}h ago';
-    }
-  }
-}
-
-/// Simple loading indicator for Monaco assets
-class MonacoAssetLoadingIndicator extends ConsumerWidget {
-  const MonacoAssetLoadingIndicator({
-    super.key,
-    this.size = 24,
-  });
-
-  final double size;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final status = ref.watch(monacoAssetStatusProvider);
-
-    if (status.isReady) {
-      return Icon(
-        Icons.check_circle,
-        size: size,
-        color: context.primary,
-      );
-    }
-
-    if (status.hasError) {
-      return Icon(
-        Icons.error,
-        size: size,
-        color: context.error,
-      );
-    }
-
-    return SizedBox(
-      width: size,
-      height: size,
-      child: CircularProgressIndicator(
-        strokeWidth: 2,
-        value: status.progress > 0 ? status.progress : null,
-      ),
-    );
-  }
-}
-
-/// Consumer wrapper that automatically initializes Monaco assets
-class MonacoAssetInitializer extends ConsumerStatefulWidget {
-  const MonacoAssetInitializer({
-    required this.child,
-    super.key,
-    this.loadingWidget,
-    this.autoInitialize = true,
-  });
-
-  final Widget child;
-  final Widget? loadingWidget;
-  final bool autoInitialize;
-
-  @override
-  ConsumerState<MonacoAssetInitializer> createState() =>
-      _MonacoAssetInitializerState();
-}
-
-class _MonacoAssetInitializerState
-    extends ConsumerState<MonacoAssetInitializer> {
-  bool _hasInitialized = false;
-
-  @override
-  void initState() {
-    super.initState();
-    if (widget.autoInitialize) {
-      WidgetsBinding.instance.addPostFrameCallback((_) {
-        _initializeAssets();
-      });
-    }
-  }
-
-  Future<void> _initializeAssets() async {
-    if (_hasInitialized) return;
-    _hasInitialized = true;
-
-    try {
-      await ref.read(monacoAssetManagerProvider).initializeAssets();
-    } catch (e) {
-      debugPrint('[MonacoAssetInitializer] Initialization error: $e');
-    }
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final status = ref.watch(monacoAssetStatusProvider);
-
-    if (status.isReady) {
-      return widget.child;
-    }
-
-    return widget.loadingWidget ??
-        MonacoAssetLoadingWidget(
-          onReady: () {
-            // Child will be rebuilt automatically due to Riverpod state change
-          },
-        );
-  }
-}
-
-/// Hook for using Monaco asset status in functional widgets
-extension MonacoAssetHooks on WidgetRef {
-  /// Wait for Monaco assets to be ready
-  Future<String> waitForMonacoAssets({Duration? timeout}) async {
-    return read(monacoAssetManagerProvider).waitForAssets(timeout: timeout);
-  }
-
-  /// Initialize Monaco assets if not already done
-  Future<String> initializeMonacoAssets() async {
-    return read(monacoAssetManagerProvider).initializeAssets();
-  }
-
-  /// Check if Monaco assets are ready
-  bool get areMonacoAssetsReady => read(monacoAssetsReadyProvider);
-
-  /// Get Monaco asset path if ready
-  String? get monacoAssetPath => read(monacoAssetPathProvider);
-}
diff --git a/lib/src/features/editor/bridge/bridge.dart b/lib/src/features/editor/bridge/bridge.dart
new file mode 100644
index 0000000..e5448a2
--- /dev/null
+++ b/lib/src/features/editor/bridge/bridge.dart
@@ -0,0 +1,276 @@
+import 'dart:async';
+import 'dart:convert';
+
+import 'package:context_collector/context_collector.dart';
+import 'package:equatable/equatable.dart';
+import 'package:flutter/foundation.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// A communication bridge between the Flutter application and the Monaco Editor
+/// instance running in a WebView.
+///
+/// the editor (like readiness and stats updates) and sending commands to it (like
+/// setting content, changing language, or executing actions). It uses the
+/// [MonacoEditorActions] mixin to provide a clean API for common editor operations.
+class MonacoBridgePlatform extends ChangeNotifier with MonacoEditorActions {
+  PlatformWebViewController? _webViewController;
+
+  // --- State Management ---
+  /// A completer that signals when the Monaco Editor's JavaScript `onEditorReady`
+  /// event has been received, indicating that the editor is fully initialized.
+  final Completer<void> onReady = Completer<void>();
+
+  /// A [ValueNotifier] that provides real-time statistics from the editor,
+  /// such as line count, character count, and selection details.
+  final ValueNotifier<LiveStats> liveStats =
+      const LiveStats.defaults().notifier;
+
+  String _content = '';
+  String _language = 'markdown';
+
+  /// Gets the current content of the editor.
+  String get content => _content;
+
+  /// Gets the current language syntax of the editor.
+  String get language => _language;
+
+  // --- Lifecycle and WebView Integration ---
+
+  /// Attaches the platform-specific [PlatformWebViewController] to the bridge.
+  ///
+  /// This method is called by the managing service once the WebView is created,
+  /// establishing the connection needed to execute JavaScript.
+  void attachWebView(PlatformWebViewController controller) {
+    _webViewController = controller;
+    debugPrint('[MonacoBridgePlatform] WebView controller attached.');
+  }
+
+  /// The primary entry point for all messages sent from the WebView's JavaScript.
+  ///
+  /// This method normalizes the incoming message and passes it to the internal
+  /// [_handleJavaScriptMessage] for parsing and dispatching.
+  void handleJavaScriptMessage(dynamic message) {
+    // Normalize message content, as platform implementations can vary.
+    final String messageContent = message is String
+        ? message
+        : (message.runtimeType.toString() == 'JavaScriptMessage'
+              // ignore: avoid_dynamic_calls
+              ? message.message as String
+              : message.toString());
+
+    _handleJavaScriptMessage(messageContent);
+  }
+
+  // --- Public API for Editor Operations ---
+
+  /// Updates the editor's entire content.
+  ///
+  /// The new content is JSON-encoded to ensure safe transmission to JavaScript.
+  Future<void> setContent(String newContent) async {
+    if (_webViewController == null) return;
+    _content = newContent;
+    final escapedContent = json.encode(newContent);
+    await _webViewController!.runJavaScript(
+      'window.setEditorContent($escapedContent)',
+    );
+    notifyListeners();
+  }
+
+  /// Updates the editor's language for syntax highlighting and other features.
+  Future<void> setLanguage(String newLanguage) async {
+    if (_webViewController == null) return;
+    _language = newLanguage;
+    await _webViewController!.runJavaScript(
+      'window.setEditorLanguage && window.setEditorLanguage("$newLanguage")',
+    );
+    notifyListeners();
+  }
+
+  /// Pushes a new set of editor options to Monaco.
+  ///
+  /// This updates the editor's appearance and behavior based on an [EditorSettings]
+  /// object, including theme and other Monaco-specific options.
+  Future<void> updateSettings(EditorSettings settings) async {
+    if (_webViewController == null) return;
+    debugPrint('[MonacoBridgePlatform] Pushing settings to editor...');
+    final optionsJson = json.encode(settings.toMonacoOptions());
+    await _webViewController!.runJavaScript(
+      'window.setEditorOptions($optionsJson)',
+    );
+    await _webViewController!.runJavaScript(
+      'window.setEditorTheme("${settings.theme}")',
+    );
+    notifyListeners();
+  }
+
+  /// Scrolls the editor to the first line.
+  Future<void> scrollToTop() async {
+    if (_webViewController == null) return;
+    await _webViewController!.runJavaScript(MonacoScripts.scrollToTopScript);
+  }
+
+  /// Scrolls the editor to the last line.
+  Future<void> scrollToBottom() async {
+    if (_webViewController == null) return;
+    await _webViewController!.runJavaScript(MonacoScripts.scrollToBottomScript);
+  }
+
+  // --- Overridden Methods ---
+
+  @override
+  Future<void> executeEditorAction(String actionId, [dynamic args]) async {
+    if (_webViewController == null) return;
+
+    // json.encode will correctly handle null `args` by converting it to the string 'null'.
+    final argsJson = json.encode(args);
+
+    // This is the safer script.
+    // 1. It uses `window.editor`, which is the specific instance of the editor we are controlling.
+    // 2. It uses the optional chaining operator `?.` which prevents an error if `window.editor` hasn't been initialized yet.
+    // 3. It uses `trigger()`, which is the high-level API for running commands. It fails gracefully if the actionId doesn't exist.
+    final script =
+        'window.editor?.trigger("flutter-bridge", "$actionId", $argsJson)';
+
+    await _webViewController!.runJavaScript(script);
+  }
+
+  @override
+  void dispose() {
+    debugPrint('[MonacoBridgePlatform] Disposing bridge.');
+    if (!onReady.isCompleted) {
+      onReady.completeError(
+        Exception('Bridge disposed before the editor became ready.'),
+      );
+    }
+    liveStats.dispose();
+    _webViewController?.dispose(); // Ensure the controller is also disposed.
+    super.dispose();
+  }
+
+  // --- Private Helpers ---
+
+  /// Injects the JavaScript responsible for monitoring and reporting editor stats.
+  Future<void> _injectLiveStatsJavaScript() async {
+    if (_webViewController == null) return;
+    await _webViewController!.runJavaScript(MonacoScripts.liveStatsMonitoring);
+  }
+
+  /// Parses and dispatches all incoming messages from the editor's JavaScript.
+  void _handleJavaScriptMessage(String message) {
+    // Handle simple log messages from JS without JSON parsing. This is efficient.
+    if (message.startsWith('log:')) {
+      debugPrint('[Monaco JS] ${message.substring(4)}');
+      return;
+    }
+
+    // The try-catch block MUST wrap the JSON conversion to handle parsing errors.
+    try {
+      // The conversion is now safely inside the try block.
+      final Map<String, dynamic> json = ConvertObject.toMap<String, dynamic>(
+        message,
+      );
+
+      switch (json) {
+        case {'event': 'onEditorReady'} when !onReady.isCompleted:
+          debugPrint('[MonacoBridge] ‚úÖ "onEditorReady" event received.');
+          onReady.complete();
+          _injectLiveStatsJavaScript();
+        // It's good practice to add breaks in switch statements.
+
+        case {'event': 'onEditorReady'}:
+          debugPrint(
+            '[MonacoBridge] "onEditorReady" already completed, ignoring.',
+          );
+
+        // --- OPTION 1: For Dart 3.4+ (Recommended if available) ---
+        case final Map<String, dynamic> data when data['event'] == 'stats':
+          liveStats.value = LiveStats.fromJson(data);
+
+        case {'event': 'error', 'message': final String message}:
+          debugPrint('‚ùå [Monaco JS Error] $message');
+
+        case {'event': final String event}:
+          debugPrint('[MonacoBridge] Unhandled JS event type: "$event"');
+
+        default:
+          debugPrint('[MonacoBridge] Unhandled or malformed JS message.');
+      }
+    } catch (e) {
+      // This will now correctly catch errors from both parsing and switching logic.
+      debugPrint(
+        '[MonacoBridge] Could not process JS message. Raw: "$message". Error: $e',
+      );
+    }
+  }
+}
+
+@immutable
+class LiveStats extends Equatable {
+  // --- CONSTRUCTORS ---
+  const LiveStats({
+    required this.lineCount,
+    required this.charCount,
+    required this.selectedLines,
+    required this.selectedCharacters,
+    required this.caretCount,
+  });
+
+  /// A factory for creating an initial/empty state with default labels.
+  const LiveStats.defaults({
+    this.lineCount = (value: 0, label: 'Ln'),
+    this.charCount = (value: 0, label: 'Ch'),
+    this.selectedLines = (value: 0, label: 'Sel Ln'),
+    this.selectedCharacters = (value: 0, label: 'Sel Ch'),
+    this.caretCount = (value: 0, label: 'Cursors'),
+  });
+
+  /// The fromJson factory now constructs the records, pairing the
+  /// integer from the JSON with its corresponding hardcoded label.
+  /// JSON: {event: stats, lineCount: 2, charCount: 75, selLines: 0, selChars: 0, caretCount: 1}
+  factory LiveStats.fromJson(Map<String, dynamic> json) {
+    return LiveStats(
+      lineCount: (
+        value: json.getInt('lineCount', defaultValue: 0),
+        label: 'Ln',
+      ),
+      charCount: (
+        value: json.getInt('charCount', defaultValue: 0),
+        label: 'Ch',
+      ),
+      selectedLines: (
+        value: json.getInt('selLines', defaultValue: 0),
+        label: 'Sel Ln',
+      ),
+      selectedCharacters: (
+        value: json.getInt('selChars', defaultValue: 0),
+        label: 'Sel Ch',
+      ),
+      caretCount: (
+        value: json.getInt('caretCount', defaultValue: 0),
+        label: 'Cursors',
+      ),
+    );
+  }
+
+  // --- PROPERTIES ---
+  // The properties are now records containing both the value and its label.
+  final ({int value, String label}) lineCount;
+  final ({int value, String label}) charCount;
+  final ({int value, String label}) selectedLines;
+  final ({int value, String label}) selectedCharacters;
+  final ({int value, String label}) caretCount;
+
+  // --- GETTERS & PROPS ---
+
+  /// The getter now accesses the `.value` of the record.
+  bool get hasSelection => selectedCharacters.value > 0;
+
+  @override
+  List<Object?> get props => [
+    lineCount,
+    charCount,
+    selectedLines,
+    selectedCharacters,
+    caretCount,
+  ];
+}
diff --git a/lib/src/features/editor/bridge/monaco_bridge_platform.dart b/lib/src/features/editor/bridge/monaco_bridge_platform.dart
deleted file mode 100644
index b8beef3..0000000
--- a/lib/src/features/editor/bridge/monaco_bridge_platform.dart
+++ /dev/null
@@ -1,781 +0,0 @@
-// ignore_for_file: use_setters_to_change_properties
-
-import 'dart:async';
-import 'dart:convert';
-import 'dart:io';
-
-import 'package:context_collector/src/features/editor/bridge/platform_webview_controller.dart';
-import 'package:context_collector/src/features/editor/domain/editor_settings.dart';
-import 'package:dart_helper_utils/dart_helper_utils.dart';
-import 'package:flutter/foundation.dart';
-
-/// Enhanced Cross-Platform Monaco Bridge
-/// Works seamlessly with both webview_flutter and webview_windows
-class MonacoBridgePlatform extends ChangeNotifier {
-  PlatformWebViewController? _webViewController;
-
-  String _content = '';
-  String _language = 'markdown';
-  EditorSettings _settings = const EditorSettings();
-  bool _isReady = false;
-  bool _forceSetLanguageNext = false;
-
-  // ValueNotifier for live editor stats
-  final ValueNotifier<Map<String, int>> liveStats =
-      ValueNotifier(<String, int>{});
-
-  // State tracking
-  Map<String, dynamic>? _lastState;
-  String? _lastTheme;
-
-  static const String _statsChannelName = 'flutterChannel';
-
-  // Getters
-  String get content => _content;
-
-  String get language => _language;
-
-  EditorSettings get settings => _settings;
-
-  bool get isReady => _isReady;
-
-  String get theme => _settings.theme;
-
-  double get fontSize => _settings.fontSize;
-
-  bool get wordWrap => _settings.wordWrap != WordWrap.off;
-
-  bool get showLineNumbers => _settings.showLineNumbers;
-
-  bool get readOnly => _settings.readOnly;
-
-  /// Handle JavaScript messages from the WebView
-  /// Handle JavaScript messages from the WebView
-  void _handleJavaScriptMessage(String message) {
-    debugPrint(
-        '[MonacoBridgePlatform._handleJavaScriptMessage] Received: $message');
-
-    // Handle log messages
-    if (message.startsWith('log:')) {
-      debugPrint('[Monaco JS] ${message.substring(4)}');
-      return;
-    }
-
-    try {
-      final data = ConvertObject.tryToMap(message) ?? {};
-
-      if (data['event'] == 'stats') {
-        liveStats.value = {
-          'lines': ConvertObject.toInt(data['lineCount'], defaultValue: 0),
-          'chars': ConvertObject.toInt(data['charCount'], defaultValue: 0),
-          'selLn': ConvertObject.toInt(data['selLines'], defaultValue: 0),
-          'selCh': ConvertObject.toInt(data['selChars'], defaultValue: 0),
-          'carets': ConvertObject.toInt(data['caretCount'], defaultValue: 1),
-        };
-      } else if (data['event'] == 'onEditorReady') {
-        debugPrint('[MonacoBridgePlatform] Editor ready event received');
-      } else if (data['event'] == 'error') {
-        debugPrint('[MonacoBridgePlatform] Editor error: ${data['message']}');
-      } else {
-        debugPrint('[MonacoBridgePlatform] Unhandled message: $message');
-      }
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Error parsing message: $e');
-      // For Windows, sometimes messages come as raw strings
-      if (Platform.isWindows && message.isNotEmpty) {
-        _handleWindowsMessage(message);
-      }
-    }
-  }
-
-  /// Handle Windows-specific message formats (ADD THIS NEW METHOD)
-  void _handleWindowsMessage(String message) {
-    try {
-      // Windows WebView might send messages in different formats
-      if (message.contains('stats') || message.contains('lineCount')) {
-        // Try to extract stats from the message
-        final regex = RegExp(r'"event"\s*:\s*"stats"');
-        if (regex.hasMatch(message)) {
-          final data = ConvertObject.tryToMap(message) ?? {};
-          if (data['event'] == 'stats') {
-            liveStats.value = {
-              'lines': ConvertObject.toInt(data['lineCount'], defaultValue: 0),
-              'chars': ConvertObject.toInt(data['charCount'], defaultValue: 0),
-              'selLn': ConvertObject.toInt(data['selLines'], defaultValue: 0),
-              'selCh': ConvertObject.toInt(data['selChars'], defaultValue: 0),
-              'carets':
-                  ConvertObject.toInt(data['caretCount'], defaultValue: 1),
-            };
-          }
-        }
-      }
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Windows message handling error: $e');
-    }
-  }
-
-  /// Public method for external components to forward JavaScript messages
-  /// Supports both JavaScriptMessage objects (from webview_flutter) and Strings
-  void handleJavaScriptMessage(dynamic message) {
-    String messageContent;
-
-    // Handle both JavaScriptMessage objects and Strings for compatibility
-    if (message is String) {
-      messageContent = message;
-    } else if (message.runtimeType.toString().contains('JavaScriptMessage')) {
-      // ignore: avoid_dynamic_calls
-      messageContent = message.message as String;
-    } else {
-      messageContent = message.toString();
-    }
-
-    _handleJavaScriptMessage(messageContent);
-  }
-
-  /// Attach the platform-specific WebView controller
-  void attachWebView(PlatformWebViewController controller) {
-    _webViewController = controller;
-    debugPrint('[MonacoBridgePlatform] WebView controller attached');
-  }
-
-  /// Detach the WebView controller
-  void detachWebView() {
-    _webViewController
-        ?.removeJavaScriptChannel(_statsChannelName)
-        .catchError((dynamic e) {
-      debugPrint('[MonacoBridgePlatform] Error removing JS channel: $e');
-      return null;
-    });
-    _webViewController = null;
-    _isReady = false;
-    debugPrint('[MonacoBridgePlatform] WebView controller detached');
-  }
-
-  /// Mark the editor as ready and initialize
-  void markReady() {
-    debugPrint('[MonacoBridgePlatform] markReady called. Language: $_language');
-    _isReady = true;
-
-    if (_webViewController != null) {
-      // Add debugging to check Monaco initialization
-      _webViewController!.runJavaScript('''
-        console.log('[MonacoBridge] Editor ready check:');
-        console.log('  - window.editor exists:', !!window.editor);
-        console.log('  - setEditorContent exists:', !!window.setEditorContent);
-        console.log('  - setEditorLanguage exists:', !!window.setEditorLanguage);
-        console.log('  - setEditorOptions exists:', !!window.setEditorOptions);
-        if (window.editor) {
-          console.log('  - editor model exists:', !!window.editor.getModel());
-        }
-      ''').catchError(
-        (dynamic e) {
-          debugPrint(
-              '[MonacoBridgePlatform] Error checking Monaco readiness: $e');
-          return null;
-        },
-      );
-
-      _pushContentToEditor();
-      _pushSettingsToEditor();
-      _forceSetLanguageNext = true;
-      setLanguage(_language);
-      _injectLiveStatsJavaScript();
-    }
-
-    notifyListeners();
-    debugPrint('[MonacoBridgePlatform] Editor marked as ready');
-  }
-
-  /// Inject JavaScript for live statistics monitoring
-  Future<void> _injectLiveStatsJavaScript() async {
-    if (_webViewController == null || !_isReady) {
-      debugPrint('[MonacoBridgePlatform] Skipping stats injection: not ready');
-      return;
-    }
-
-    const script = '''
-      console.log('[Stats Script] Injecting live stats monitoring');
-      if (window.__liveStatsHooked) {
-        console.log('[Stats Script] Already hooked');
-      } else {
-        window.__liveStatsHooked = true;
-        if (window.editor) {
-          const sendStats = () => {
-            const model = window.editor.getModel();
-            const selection = window.editor.getSelection();
-            const selections = window.editor.getSelections() || [];
-            
-            if (!model || !selection) return;
-            
-            const stats = {
-              event: 'stats',
-              lineCount: model.getLineCount(),
-              charCount: model.getValueLength(),
-              selLines: selection.isEmpty() ? 0 : selection.endLineNumber - selection.startLineNumber + 1,
-              selChars: selection.isEmpty() ? 0 : model.getValueInRange(selection).length,
-              caretCount: selections.length
-            };
-            
-            if (window.flutterChannel && window.flutterChannel.postMessage) {
-              window.flutterChannel.postMessage(JSON.stringify(stats));
-            }
-          };
-          
-          window.editor.onDidChangeModelContent(sendStats);
-          window.editor.onDidChangeCursorSelection(sendStats);
-          sendStats(); // Initial call
-        }
-      }
-    ''';
-
-    try {
-      await _webViewController!.runJavaScript(script);
-      debugPrint('[MonacoBridgePlatform] Live stats JavaScript injected');
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Error injecting stats JS: $e');
-    }
-  }
-
-  /// Updates the editor content
-  Future<void> setContent(String content, {bool preserveState = false}) async {
-    if (_content == content) return;
-
-    if (preserveState && _webViewController != null && _isReady) {
-      await _saveEditorState();
-    }
-
-    _content = content;
-
-    if (_webViewController != null && _isReady) {
-      await _pushContentToEditor();
-
-      if (preserveState && _lastState != null) {
-        await _restoreEditorState();
-      }
-    }
-
-    notifyListeners();
-  }
-
-  /// Gets the current editor content
-  Future<String> getContent() async {
-    if (_webViewController != null && _isReady) {
-      try {
-        final result = await _webViewController!.runJavaScriptReturningResult(
-          'window.getEditorContent() || ""',
-        );
-        final content = result is String ? result : result.toString();
-        _content = content.replaceAll(RegExp(r'^"|"$'), '');
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error getting content: $e');
-      }
-    }
-    return _content;
-  }
-
-  /// Sets the editor language
-  Future<void> setLanguage(String language) async {
-    debugPrint(
-        '[MonacoBridgePlatform] setLanguage: $language (ready: $_isReady)');
-
-    if (!_isReady) {
-      _language = language;
-      notifyListeners();
-      return;
-    }
-
-    if (_language == language && !_forceSetLanguageNext) {
-      debugPrint('[MonacoBridgePlatform] Language already set to: $language');
-      return;
-    }
-
-    _language = language;
-    _forceSetLanguageNext = false;
-
-    if (_webViewController != null) {
-      try {
-        // First, check if Monaco is properly initialized
-        await _webViewController!.runJavaScript('''
-          if (!window.editor) {
-            console.error('[MonacoBridge] Editor not found when setting language');
-          } else if (!window.setEditorLanguage) {
-            console.error('[MonacoBridge] setEditorLanguage function not found');
-          } else {
-            console.log('[MonacoBridge] Setting language to: $language');
-          }
-        ''');
-
-        await _webViewController!.runJavaScript(
-          'window.setEditorLanguage && window.setEditorLanguage("$language")',
-        );
-        debugPrint('[MonacoBridgePlatform] Language set to: $language');
-
-        // Verify the language was set
-        await _webViewController!.runJavaScript('''
-          if (window.editor && window.editor.getModel()) {
-            const currentLang = window.editor.getModel().getLanguageId();
-            console.log('[MonacoBridge] Current language after setting: ' + currentLang);
-          }
-        ''');
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error setting language: $e');
-      }
-    }
-    notifyListeners();
-  }
-
-  /// Updates editor settings - the main method for configuration
-  Future<void> updateSettings(EditorSettings newSettings) async {
-    debugPrint('[MonacoBridgePlatform] updateSettings called');
-    final oldSettings = _settings;
-    _settings = newSettings;
-
-    if (_webViewController != null && _isReady) {
-      await _pushSettingsToEditor();
-
-      if (oldSettings.theme != newSettings.theme) {
-        await _setTheme(newSettings.theme);
-      }
-    }
-
-    notifyListeners();
-  }
-
-  /// Apply keybinding preset
-  Future<void> applyKeybindingPreset(KeybindingPresetEnum preset) async {
-    debugPrint('[MonacoBridgePlatform] applyKeybindingPreset: $preset');
-
-    if (_webViewController != null && _isReady) {
-      try {
-        // Use the enum name directly like the old version
-        await _webViewController!.runJavaScript(
-          'window.applyKeybindingPreset && window.applyKeybindingPreset("${preset.monacoPreset}")',
-        );
-        debugPrint(
-            '[MonacoBridgePlatform] Applied keybinding preset: ${preset.monacoPreset}');
-      } catch (e) {
-        debugPrint(
-            '[MonacoBridgePlatform] Error applying keybinding preset: $e');
-      }
-    }
-  }
-
-  /// Set up custom keybindings
-  Future<void> setupKeybindings(Map<String, String> keybindings) async {
-    debugPrint(
-        '[MonacoBridgePlatform] setupKeybindings: ${keybindings.length} bindings');
-
-    if (_webViewController != null && _isReady && keybindings.isNotEmpty) {
-      try {
-        final keybindingsJson = json.encode(keybindings);
-        await _webViewController!.runJavaScript(
-          'window.setupCustomKeybindings && window.setupCustomKeybindings($keybindingsJson)',
-        );
-        debugPrint('[MonacoBridgePlatform] Custom keybindings applied');
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error setting up keybindings: $e');
-      }
-    }
-  }
-
-  /// Apply language-specific settings
-  Future<void> applyLanguageSettings(String language) async {
-    final languageSettings = _settings.getLanguageSettings(language);
-    if (languageSettings != _settings) {
-      await _pushLanguageSpecificSettings(languageSettings, language);
-    }
-  }
-
-  /// Set markers for error highlighting, etc.
-  Future<void> setMarkers(List<Map<String, dynamic>> markers) async {
-    if (_webViewController != null && _isReady) {
-      try {
-        final markersJson = json.encode(markers);
-        await _webViewController!.runJavaScript(
-          'window.setEditorMarkers && window.setEditorMarkers($markersJson)',
-        );
-        debugPrint('[MonacoBridgePlatform] Markers set: ${markers.length}');
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error setting markers: $e');
-      }
-    }
-  }
-
-  /// Sets the editor theme
-  Future<void> _setTheme(String theme) async {
-    if (_lastTheme == theme) return;
-    _lastTheme = theme;
-
-    if (_webViewController != null && _isReady) {
-      try {
-        await _webViewController!.runJavaScript(
-          'window.setEditorTheme("$theme")',
-        );
-        debugPrint('[MonacoBridgePlatform] Theme set to: $theme');
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error setting theme: $e');
-      }
-    }
-  }
-
-  // ========================================
-  // EDITOR ACTIONS
-  // ========================================
-
-  /// Formats the document
-  Future<void> format() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.formatDocument")?.run()',
-      );
-    }
-  }
-
-  /// Finds text in the editor
-  Future<void> find() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("actions.find")?.run()',
-      );
-    }
-  }
-
-  /// Replace text in the editor
-  Future<void> findAndReplace() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.startFindReplaceAction")?.run()',
-      );
-    }
-  }
-
-  /// Goes to a specific line
-  Future<void> goToLine([int? line]) async {
-    if (_webViewController != null && _isReady) {
-      if (line != null) {
-        await _webViewController!.runJavaScript(
-          'if (window.editor) { window.editor.revealLineInCenter($line); window.editor.setPosition({ lineNumber: $line, column: 1 }); }',
-        );
-      } else {
-        await _webViewController!.runJavaScript(
-          'window.editor?.getAction("editor.action.gotoLine")?.run()',
-        );
-      }
-    }
-  }
-
-  /// Toggles line comments
-  Future<void> toggleLineComment() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.commentLine")?.run()',
-      );
-    }
-  }
-
-  /// Toggles block comments
-  Future<void> toggleBlockComment() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.blockComment")?.run()',
-      );
-    }
-  }
-
-  /// Triggers auto-completion
-  Future<void> triggerSuggest() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.triggerSuggest")?.run()',
-      );
-    }
-  }
-
-  /// Shows the command palette
-  Future<void> showCommandPalette() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.quickCommand")?.run()',
-      );
-    }
-  }
-
-  /// Scrolls to top
-  Future<void> scrollToTop() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.setScrollPosition({ scrollTop: 0, scrollLeft: 0 })',
-      );
-    }
-  }
-
-  /// Scrolls to bottom
-  Future<void> scrollToBottom() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        '''
-        if (window.editor) {
-          const lineCount = window.editor.getModel()?.getLineCount() || 1;
-          window.editor.revealLine(lineCount);
-        }
-        ''',
-      );
-    }
-  }
-
-  /// Fold all code blocks
-  Future<void> foldAll() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.foldAll")?.run()',
-      );
-    }
-  }
-
-  /// Unfold all code blocks
-  Future<void> unfoldAll() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.unfoldAll")?.run()',
-      );
-    }
-  }
-
-  /// Select all content
-  Future<void> selectAll() async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("editor.action.selectAll")?.run()',
-      );
-    }
-  }
-
-  /// Execute a custom Monaco action by ID
-  Future<void> executeAction(String actionId) async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.editor?.getAction("$actionId")?.run()',
-      );
-    }
-  }
-
-  /// Execute a custom keybinding
-  Future<void> executeKeybinding(String keybinding) async {
-    if (_webViewController != null && _isReady) {
-      await _webViewController!.runJavaScript(
-        'window.executeKeybinding("$keybinding")',
-      );
-    }
-  }
-
-  /// Get editor statistics
-  Future<Map<String, dynamic>> getEditorStats() async {
-    if (_webViewController != null && _isReady) {
-      try {
-        final result =
-            await _webViewController!.runJavaScriptReturningResult(r"""
-          JSON.stringify({
-            lineCount: window.editor?.getModel()?.getLineCount() || 0,
-            characterCount: window.editor?.getValue()?.length || 0,
-            wordCount: (window.editor?.getValue()?.match(/\b\w+\b/g) || []).length,
-            selectedText: window.editor?.getSelection()?.isEmpty() === false,
-            language: window.editor?.getModel()?.getLanguageId() || 'unknown',
-            cursorPosition: window.editor?.getPosition(),
-            viewState: {
-              scrollTop: window.editor?.getScrollTop() || 0,
-              scrollLeft: window.editor?.getScrollLeft() || 0
-            },
-            selectedLineCount: window.editor?.getSelection()?.isEmpty()
-              ? 0
-              : (window.editor?.getSelection()?.endLineNumber || 0) - (window.editor?.getSelection()?.startLineNumber || 0) + 1,
-            selectedCharCount: window.editor?.getModel()?.getValueInRange(window.editor?.getSelection())?.length || 0
-          })
-        """);
-
-        if (result is String) {
-          return json.decode(result) as Map<String, dynamic>;
-        }
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error getting editor stats: $e');
-      }
-    }
-    return {};
-  }
-
-  /// Debug method to check Monaco initialization and language support
-  Future<Map<String, dynamic>> getDebugInfo() async {
-    if (_webViewController != null && _isReady) {
-      try {
-        final result =
-            await _webViewController!.runJavaScriptReturningResult("""
-          JSON.stringify({
-            editorExists: !!window.editor,
-            editorReady: !!(window.editor && window.editor.getModel()),
-            currentLanguage: window.editor?.getModel()?.getLanguageId() || 'none',
-            availableLanguages: window.monaco?.languages?.getLanguages?.()?.map(l => l.id) || [],
-            functionsAvailable: {
-              setEditorContent: !!window.setEditorContent,
-              setEditorLanguage: !!window.setEditorLanguage,
-              setEditorOptions: !!window.setEditorOptions,
-              setEditorTheme: !!window.setEditorTheme
-            },
-            monacoVersion: window.monaco?.editor?.VERSION || 'unknown'
-          })
-        """);
-
-        if (result is String) {
-          final debugInfo = json.decode(result) as Map<String, dynamic>;
-          debugPrint('[MonacoBridgePlatform] Debug info: $debugInfo');
-          return debugInfo;
-        }
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error getting debug info: $e');
-      }
-    }
-    return {'error': 'WebView not ready or not available'};
-  }
-
-  // ========================================
-  // PRIVATE METHODS
-  // ========================================
-
-  /// Push content to the editor
-  Future<void> _pushContentToEditor() async {
-    if (_webViewController == null || !_isReady) return;
-
-    try {
-      final escapedContent = json.encode(_content);
-      await _webViewController!.runJavaScript(
-        'window.setEditorContent($escapedContent)',
-      );
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Error pushing content: $e');
-    }
-  }
-
-  /// Push settings to the editor
-  Future<void> _pushSettingsToEditor() async {
-    if (_webViewController == null || !_isReady) return;
-
-    try {
-      final options = _settings.toMonacoOptions();
-      final optionsJson = json.encode(options);
-
-      await _webViewController!.runJavaScript(
-        'window.setEditorOptions($optionsJson)',
-      );
-      debugPrint('[MonacoBridgePlatform] Settings pushed to editor');
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Error pushing settings: $e');
-    }
-  }
-
-  /// Push language-specific settings
-  Future<void> _pushLanguageSpecificSettings(
-      EditorSettings languageSettings, String language) async {
-    if (_webViewController == null || !_isReady) return;
-
-    try {
-      final options = languageSettings.toMonacoOptions();
-      final optionsJson = json.encode(options);
-
-      await _webViewController!.runJavaScript(
-        'window.setLanguageSpecificOptions && window.setLanguageSpecificOptions("$language", $optionsJson)',
-      );
-    } catch (e) {
-      debugPrint(
-          '[MonacoBridgePlatform] Error pushing language-specific settings: $e');
-    }
-  }
-
-  /// Save current editor state
-  Future<void> _saveEditorState() async {
-    try {
-      final stateJson = (await _webViewController!.runJavaScriptReturningResult(
-        '''
-JSON.stringify({
-  position: window.editor?.getPosition(),
-  selection: window.editor?.getSelection(),
-  scrollTop: window.editor?.getScrollTop(),
-  scrollLeft: window.editor?.getScrollLeft(),
-  viewState: window.editor?.saveViewState()
-})''',
-      ))! as String;
-      _lastState = json.decode(stateJson) as Map<String, dynamic>?;
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Error saving editor state: $e');
-      _lastState = null;
-    }
-  }
-
-  /// Restore editor state
-  Future<void> _restoreEditorState() async {
-    if (_lastState == null || _webViewController == null || !_isReady) return;
-
-    try {
-      await _webViewController!.runJavaScript('''
-        if (window.editor) {
-          const state = ${json.encode(_lastState)};
-          if (state.viewState) {
-            window.editor.restoreViewState(state.viewState);
-          } else {
-            if (state.position) {
-              window.editor.setPosition(state.position);
-            }
-            if (state.selection) {
-              window.editor.setSelection(state.selection);
-            }
-            if (state.scrollTop !== undefined) {
-              window.editor.setScrollPosition({
-                scrollTop: state.scrollTop,
-                scrollLeft: state.scrollLeft || 0
-              });
-            }
-          }
-        }
-      ''');
-    } catch (e) {
-      debugPrint('[MonacoBridgePlatform] Error restoring editor state: $e');
-    }
-  }
-
-  /// Register custom themes (for future use)
-  Future<void> registerCustomTheme(
-      String themeName, Map<String, dynamic> themeData) async {
-    if (_webViewController != null && _isReady) {
-      try {
-        final themeJson = json.encode(themeData);
-        await _webViewController!.runJavaScript(
-          'monaco.editor.defineTheme("$themeName", $themeJson)',
-        );
-      } catch (e) {
-        debugPrint('[MonacoBridgePlatform] Error registering custom theme: $e');
-      }
-    }
-  }
-
-  /// Register custom language (for future use)
-  Future<void> registerCustomLanguage(
-      String languageId, Map<String, dynamic> languageDefinition) async {
-    if (_webViewController != null && _isReady) {
-      try {
-        final langJson = json.encode(languageDefinition);
-        await _webViewController!.runJavaScript(
-          'monaco.languages.register($langJson)',
-        );
-      } catch (e) {
-        debugPrint(
-            '[MonacoBridgePlatform] Error registering custom language: $e');
-      }
-    }
-  }
-
-  @override
-  void dispose() {
-    debugPrint('[MonacoBridgePlatform] Disposing bridge');
-    liveStats.dispose();
-    _webViewController?.dispose();
-    _webViewController = null;
-    super.dispose();
-  }
-}
diff --git a/lib/src/features/editor/bridge/platform_webview_controller.dart b/lib/src/features/editor/bridge/webview_controller.dart
similarity index 86%
rename from lib/src/features/editor/bridge/platform_webview_controller.dart
rename to lib/src/features/editor/bridge/webview_controller.dart
index 0e496e5..96be055 100644
--- a/lib/src/features/editor/bridge/platform_webview_controller.dart
+++ b/lib/src/features/editor/bridge/webview_controller.dart
@@ -14,7 +14,9 @@ abstract class PlatformWebViewController {
   Future<Object?> runJavaScriptReturningResult(String script);
 
   Future<Object?> addJavaScriptChannel(
-      String name, void Function(String) onMessage);
+    String name,
+    void Function(String) onMessage,
+  );
 
   Future<Object?> removeJavaScriptChannel(String name);
 
@@ -27,7 +29,7 @@ class FlutterWebViewController implements PlatformWebViewController {
     _controller = wf.WebViewController();
   }
 
-  late wf.WebViewController _controller;
+  late final wf.WebViewController _controller;
 
   wf.WebViewController get flutterController => _controller;
 
@@ -55,6 +57,13 @@ class FlutterWebViewController implements PlatformWebViewController {
     _controller.setNavigationDelegate(delegate);
   }
 
+  /// Allows the service to listen for console messages from the WebView.
+  Future<void> setOnConsoleMessage(
+    void Function(wf.JavaScriptConsoleMessage) onConsoleMessage,
+  ) async {
+    await _controller.setOnConsoleMessage(onConsoleMessage);
+  }
+
   @override
   Future<Object?> runJavaScript(String script) async {
     try {
@@ -78,7 +87,9 @@ class FlutterWebViewController implements PlatformWebViewController {
 
   @override
   Future<Object?> addJavaScriptChannel(
-      String name, void Function(String) onMessage) async {
+    String name,
+    void Function(String) onMessage,
+  ) async {
     await _controller.addJavaScriptChannel(
       name,
       onMessageReceived: (wf.JavaScriptMessage message) {
@@ -96,7 +107,7 @@ class FlutterWebViewController implements PlatformWebViewController {
 
   @override
   void dispose() {
-    // WebViewController doesn't have explicit dispose in webview_flutter
+    // WebViewController doesn't have an explicit dispose method in webview_flutter
   }
 }
 
@@ -106,7 +117,7 @@ class WindowsWebViewController implements PlatformWebViewController {
     _controller = ww.WebviewController();
   }
 
-  late ww.WebviewController _controller;
+  late final ww.WebviewController _controller;
   final Map<String, void Function(String)> _channels = {};
   StreamSubscription<dynamic>? _webMessageSubscription;
   bool _isInitialized = false;
@@ -133,16 +144,16 @@ class WindowsWebViewController implements PlatformWebViewController {
   void _setupWebMessageHandler() {
     _webMessageSubscription?.cancel();
 
-    // Use the controller's postWebMessage method to set up proper message handling
-    _webMessageSubscription =
-        _controller.webMessage.listen((dynamic rawMessage) {
+    _webMessageSubscription = _controller.webMessage.listen((
+      dynamic rawMessage,
+    ) {
       debugPrint(
-          '[WindowsWebViewController] Raw message: $rawMessage (${rawMessage.runtimeType})');
+        '[WindowsWebViewController] Raw message: $rawMessage (${rawMessage.runtimeType})',
+      );
 
       try {
         String messageStr;
 
-        // Handle different message formats
         if (rawMessage is String) {
           messageStr = rawMessage;
         } else if (rawMessage is Map) {
@@ -151,10 +162,10 @@ class WindowsWebViewController implements PlatformWebViewController {
           messageStr = rawMessage.toString();
         }
 
-        // Send to all registered channels (usually just flutterChannel)
         _channels.forEach((channelName, handler) {
           debugPrint(
-              '[WindowsWebViewController] Forwarding to channel: $channelName');
+            '[WindowsWebViewController] Forwarding to channel: $channelName',
+          );
           handler(messageStr);
         });
       } catch (e) {
@@ -165,10 +176,17 @@ class WindowsWebViewController implements PlatformWebViewController {
 
   Future<void> loadHtmlString(String html, {String? baseUrl}) async {
     debugPrint(
-        '[WindowsWebViewController] Loading HTML string (length: ${html.length})');
+      '[WindowsWebViewController] Loading HTML string (length: ${html.length})',
+    );
     await _controller.loadStringContent(html);
   }
 
+  /// Load a URL (including file:// URLs) in the WebView
+  Future<void> loadUrl(String url) async {
+    debugPrint('[WindowsWebViewController] Loading URL: $url');
+    await _controller.loadUrl(url);
+  }
+
   @override
   Future<Object?> runJavaScript(String script) async {
     try {
@@ -182,21 +200,17 @@ class WindowsWebViewController implements PlatformWebViewController {
   @override
   Future<dynamic> runJavaScriptReturningResult(String script) async {
     try {
-      // Windows WebView2 returns results differently than webview_flutter
       final result = await _controller.executeScript(script);
 
       if (result == null) return null;
 
-      // Try to parse if it's JSON
       if (result is String) {
         try {
-          // Remove quotes if it's a quoted string
           if (result.startsWith('"') &&
               result.endsWith('"') &&
               result.length > 2) {
             return result.substring(1, result.length - 1);
           }
-          // Try parsing as JSON
           if (result.startsWith('{') || result.startsWith('[')) {
             return json.decode(result);
           }
@@ -214,7 +228,9 @@ class WindowsWebViewController implements PlatformWebViewController {
 
   @override
   Future<Object?> addJavaScriptChannel(
-      String name, void Function(String) onMessage) async {
+    String name,
+    void Function(String) onMessage,
+  ) async {
     debugPrint('[WindowsWebViewController] Adding JavaScript channel: $name');
 
     // Store the handler
diff --git a/lib/src/features/editor/core/actions/monaco_editor_actions.dart b/lib/src/features/editor/core/actions/monaco_editor_actions.dart
new file mode 100644
index 0000000..5807251
--- /dev/null
+++ b/lib/src/features/editor/core/actions/monaco_editor_actions.dart
@@ -0,0 +1,97 @@
+import 'package:context_collector/context_collector.dart';
+
+/// Mixin containing a comprehensive set of Monaco Editor action methods.
+///
+/// By using this mixin, a class gains a rich API for controlling the editor
+/// without needing to know the underlying command IDs or JavaScript implementation.
+mixin MonacoEditorActions {
+  /// Executes a specific editor action by its ID, with optional arguments.
+  ///
+  /// This method must be implemented by the class using the mixin. It serves
+  /// as the core bridge to the editor's action system.
+  ///
+  /// - [actionId]: The command identifier for the action (e.g., 'editor.action.formatDocument').
+  /// - [args]: An optional payload for actions that require it (e.g., line number).
+  Future<void> executeEditorAction(String actionId, [dynamic args]);
+
+  /// Format the entire document.
+  Future<void> format() async =>
+      executeEditorAction(MonacoActions.format.command);
+
+  /// Open the find widget.
+  Future<void> find() async => executeEditorAction(MonacoActions.find.command);
+
+  /// Open the replace widget.
+  Future<void> replace() async =>
+      executeEditorAction(MonacoActions.replace.command);
+
+  /// Open the "Go to Line" dialog.
+  /// To programmatically go to a line, use `executeEditorAction` directly:
+  /// `executeEditorAction('editor.action.revealLine', {'lineNumber': 10})`
+  Future<void> gotoLine() async =>
+      executeEditorAction(MonacoActions.gotoLine.command);
+
+  /// Toggle word wrap.
+  Future<void> toggleWordWrap() async =>
+      executeEditorAction(MonacoActions.toggleWordWrap.command);
+
+  /// Toggle the minimap.
+  Future<void> toggleMinimap() async =>
+      executeEditorAction(MonacoActions.toggleMinimap.command);
+
+  /// Toggle a line comment.
+  Future<void> toggleLineComment() async =>
+      executeEditorAction(MonacoActions.toggleLineComment.command);
+
+  /// Toggle a block comment.
+  Future<void> toggleBlockComment() async =>
+      executeEditorAction(MonacoActions.toggleBlockComment.command);
+
+  /// Trigger the auto-completion suggestion box.
+  Future<void> triggerSuggest() async =>
+      executeEditorAction(MonacoActions.triggerSuggest.command);
+
+  /// Show the command palette.
+  Future<void> showCommandPalette() async =>
+      executeEditorAction(MonacoActions.showCommandPalette.command);
+
+  /// Fold all collapsible code blocks.
+  Future<void> foldAll() async =>
+      executeEditorAction(MonacoActions.foldAll.command);
+
+  /// Unfold all folded code blocks.
+  Future<void> unfoldAll() async =>
+      executeEditorAction(MonacoActions.unfoldAll.command);
+
+  /// Select all content in the editor.
+  Future<void> selectAll() async =>
+      executeEditorAction(MonacoActions.selectAll.command);
+
+  /// Undo the last action.
+  Future<void> undo() async => executeEditorAction(MonacoActions.undo.command);
+
+  /// Redo the last undone action.
+  Future<void> redo() async => executeEditorAction(MonacoActions.redo.command);
+
+  /// Cut the selected content.
+  Future<void> cut() async => executeEditorAction(MonacoActions.cut.command);
+
+  /// Copy the selected content.
+  Future<void> copy() async => executeEditorAction(MonacoActions.copy.command);
+
+  /// Paste content from the clipboard.
+  Future<void> paste() async =>
+      executeEditorAction(MonacoActions.paste.command);
+
+  /// Increase the editor's font size.
+  Future<void> increaseFontSize() async =>
+      executeEditorAction(MonacoActions.increaseFontSize.command);
+
+  /// Decrease the editor's font size.
+  Future<void> decreaseFontSize() async =>
+      executeEditorAction(MonacoActions.decreaseFontSize.command);
+
+  /// Reset the editor's font size to its default.
+  Future<void> resetFontSize() async =>
+      executeEditorAction(MonacoActions.resetFontSize.command);
+}
diff --git a/lib/src/features/editor/core/model/editor_constants.dart b/lib/src/features/editor/core/model/editor_constants.dart
new file mode 100644
index 0000000..83f685a
--- /dev/null
+++ b/lib/src/features/editor/core/model/editor_constants.dart
@@ -0,0 +1,257 @@
+/// Unified constants for the Monaco editor
+class EditorConstants {
+  // Prevent instantiation
+  EditorConstants._();
+
+  /// Theme display names
+  static const Map<String, String> themeNames = {
+    'vs': 'Light',
+    'vs-dark': 'Dark',
+    'hc-black': 'High Contrast Dark',
+    'hc-light': 'High Contrast Light',
+  };
+
+  /// Available languages with display names
+  static const Map<String, String> languages = {
+    'plaintext': 'Plain Text',
+    'abap': 'ABAP',
+    'apex': 'Apex',
+    'azcli': 'Azure CLI',
+    'bat': 'Batch',
+    'bicep': 'Bicep',
+    'cameligo': 'Cameligo',
+    'clojure': 'Clojure',
+    'coffeescript': 'CoffeeScript',
+    'c': 'C',
+    'cpp': 'C++',
+    'csharp': 'C#',
+    'csp': 'CSP',
+    'css': 'CSS',
+    'cypher': 'Cypher',
+    'dart': 'Dart',
+    'dockerfile': 'Dockerfile',
+    'ecl': 'ECL',
+    'elixir': 'Elixir',
+    'flow9': 'Flow9',
+    'fsharp': 'F#',
+    'freemarker2': 'Freemarker2',
+    'go': 'Go',
+    'graphql': 'GraphQL',
+    'handlebars': 'Handlebars',
+    'hcl': 'HCL',
+    'html': 'HTML',
+    'ini': 'INI',
+    'java': 'Java',
+    'javascript': 'JavaScript',
+    'julia': 'Julia',
+    'kotlin': 'Kotlin',
+    'less': 'Less',
+    'lexon': 'Lexon',
+    'lua': 'Lua',
+    'liquid': 'Liquid',
+    'm3': 'M3',
+    'markdown': 'Markdown',
+    'mdx': 'MDX',
+    'mips': 'MIPS',
+    'msdax': 'MSDAX',
+    'mysql': 'MySQL',
+    'objective-c': 'Objective-C',
+    'pascal': 'Pascal',
+    'pascaligo': 'Pascaligo',
+    'perl': 'Perl',
+    'pgsql': 'PostgreSQL',
+    'php': 'PHP',
+    'pla': 'PLA',
+    'postiats': 'Postiats',
+    'powerquery': 'Power Query',
+    'powershell': 'PowerShell',
+    'proto': 'Protocol Buffers',
+    'pug': 'Pug',
+    'python': 'Python',
+    'qsharp': 'Q#',
+    'r': 'R',
+    'razor': 'Razor',
+    'redis': 'Redis',
+    'redshift': 'Redshift',
+    'restructuredtext': 'reStructuredText',
+    'ruby': 'Ruby',
+    'rust': 'Rust',
+    'sb': 'Small Basic',
+    'scala': 'Scala',
+    'scheme': 'Scheme',
+    'scss': 'SCSS',
+    'shell': 'Shell Script',
+    'sol': 'Solidity',
+    'aes': 'AES',
+    'sparql': 'SPARQL',
+    'sql': 'SQL',
+    'st': 'Structured Text',
+    'swift': 'Swift',
+    'systemverilog': 'SystemVerilog',
+    'verilog': 'Verilog',
+    'tcl': 'Tcl',
+    'twig': 'Twig',
+    'typescript': 'TypeScript',
+    'typespec': 'TypeSpec',
+    'vb': 'Visual Basic',
+    'wgsl': 'WGSL',
+    'xml': 'XML',
+    'yaml': 'YAML',
+    'json': 'JSON',
+  };
+
+  /// Common font families
+  static const List<String> fontFamilies = [
+    'Cascadia Code, Fira Code, Consolas, monospace',
+    'Fira Code, Consolas, monospace',
+    'SF Mono, Monaco, monospace',
+    'JetBrains Mono, monospace',
+    'Source Code Pro, monospace',
+    'Consolas, monospace',
+    'Monaco, monospace',
+    'Menlo, monospace',
+    'Courier New, monospace',
+    'monospace',
+  ];
+
+  /// Font size range
+  static const double minFontSize = 8;
+  static const double maxFontSize = 48;
+  static const double defaultFontSize = 14;
+
+  /// Tab size range
+  static const int minTabSize = 1;
+  static const int maxTabSize = 8;
+  static const int defaultTabSize = 2;
+
+  /// Keybinding presets
+  static const Map<String, String> keybindingPresets = {
+    'vscode': 'VS Code',
+    'intellij': 'IntelliJ',
+    'vim': 'Vim',
+    'emacs': 'Emacs',
+    'custom': 'Custom',
+  };
+
+  /// Common ruler positions
+  static const List<List<int>> commonRulers = [
+    [],
+    [80],
+    [100],
+    [120],
+    [80, 120],
+    [80, 100, 120],
+  ];
+
+  /// Monaco asset files
+  static const String monacoVersion = '0.45.0';
+
+  /// File size limits
+  static const int maxFileSize = 10 * 1024 * 1024; // 10 MB
+  static const int warningFileSize = 1 * 1024 * 1024; // 1 MB
+
+  /// Default settings
+  static const String defaultTheme = 'vs-dark';
+  static const String defaultLanguage = 'markdown';
+  static const String defaultKeybindingPreset = 'vscode';
+
+  static String indexHtmlContent(String vsPath) =>
+      '''
+<!DOCTYPE html>
+<html>
+  <head>
+    <meta charset="utf-8" />
+    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
+    <!-- FIXED: Relaxed CSP to allow file:// scripts and unsafe-eval (required by Monaco) -->
+    <meta
+      http-equiv="Content-Security-Policy"
+      content="default-src 'self' file: 'unsafe-inline' 'unsafe-eval'; script-src 'self' file: 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; font-src 'self' file:; worker-src 'self' blob:;"
+    />
+    <style>
+      html, body, #editor-container {
+        width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
+      }
+    </style>
+  </head>
+  <body>
+    <div id="editor-container"></div>
+
+    <script>
+      var require = { paths: { vs: '$vsPath' } };
+      console.log('[Monaco HTML] Require config set. VS_PATH is: ' + '$vsPath');
+    </script>
+
+    <script src="$vsPath/loader.js"
+            onload="console.log('[Monaco HTML] loader.js successfully loaded.')"
+            onerror="console.error('[Monaco HTML] FATAL: loader.js FAILED TO LOAD.')"
+    ></script>
+
+    <script>
+      console.log('[Monaco HTML] Attempting to require editor.main...');
+      try {
+        // This is the standard Monaco loader pattern, now with an error callback.
+        require(
+          ['vs/editor/editor.main'],
+          function () { // SUCCESS CALLBACK
+            console.log('[Monaco] SUCCESS: editor.main.js has loaded. Initializing editor...');
+
+            function postMessageToFlutter(message) {
+              if (typeof message !== 'string') {
+                message = JSON.stringify(message);
+              }
+              if (window.flutterChannel && window.flutterChannel.postMessage) {
+                window.flutterChannel.postMessage(message);
+              } else {
+                console.error('[Monaco] Flutter communication channel is not available.');
+              }
+            }
+
+            monaco.editor.onDidCreateEditor(function (editor) {
+              window.editor = editor;
+              window.setEditorContent = (content) => editor.setValue(content || '');
+              window.setEditorLanguage = (language) => monaco.editor.setModelLanguage(editor.getModel(), language);
+              window.setEditorTheme = (theme) => monaco.editor.setTheme(theme);
+              window.setEditorOptions = (options) => editor.updateOptions(options);
+
+              const sendStats = () => {
+                if (!editor.getModel() || !editor.getSelection()) return;
+                const model = editor.getModel(), selection = editor.getSelection(), selections = editor.getSelections() || [];
+                postMessageToFlutter({
+                  event: 'stats',
+                  lineCount: model.getLineCount(),
+                  charCount: model.getValueLength(),
+                  selLines: selection.endLineNumber - selection.startLineNumber + 1,
+                  selChars: model.getValueInRange(selection).length,
+                  caretCount: selections.length,
+                });
+              };
+              editor.onDidChangeModelContent(sendStats);
+              editor.onDidChangeCursorSelection(sendStats);
+              sendStats();
+
+              postMessageToFlutter({ event: 'onEditorReady' });
+              console.log('[Monaco] Editor is ready and has sent the onEditorReady event.');
+            });
+
+            monaco.editor.create(document.getElementById('editor-container'), {
+              value: '// Context Collector is ready.',
+              language: 'markdown',
+              theme: 'vs-dark',
+              automaticLayout: true,
+              wordWrap: 'on',
+              padding: { top: 10 },
+              minimap: { enabled: false }
+            });
+          },
+          function (error) { // ERROR CALLBACK
+            console.error('[Monaco] FATAL: require() failed to load editor.main.js. Error:', error);
+          }
+        );
+      } catch (e) {
+        console.error('[Monaco] FATAL: A critical error occurred trying to call require(). Error:', e);
+      }
+    </script>
+  </body>
+</html>
+  ''';
+}
diff --git a/lib/src/features/editor/core/model/editor_settings.dart b/lib/src/features/editor/core/model/editor_settings.dart
new file mode 100644
index 0000000..a1c2445
--- /dev/null
+++ b/lib/src/features/editor/core/model/editor_settings.dart
@@ -0,0 +1,458 @@
+// ignore_for_file: invalid_annotation_target
+
+import 'package:freezed_annotation/freezed_annotation.dart';
+
+part 'editor_settings.freezed.dart';
+part 'editor_settings.g.dart';
+
+// --- ENUMS (Unchanged) ---
+enum WordWrap {
+  off,
+  on,
+  wordWrapColumn,
+  bounded;
+
+  bool get enabled => this != WordWrap.off;
+}
+
+enum LineNumbersStyle { off, on, relative, interval }
+
+enum MinimapSide { left, right }
+
+enum RenderWhitespace { none, boundary, selection, trailing, all }
+
+enum CursorBlinking { blink, smooth, phase, expand, solid }
+
+enum CursorStyle {
+  line,
+  block,
+  underline,
+  lineThin,
+  blockOutline,
+  underlineThin,
+}
+
+enum MultiCursorModifier { ctrlCmd, alt }
+
+enum AcceptSuggestionOnEnter { on, off, smart }
+
+enum SnippetSuggestions { top, bottom, inline, none }
+
+enum WordBasedSuggestions {
+  off,
+  currentDocument,
+  matchingDocuments,
+  allDocuments,
+}
+
+enum AccessibilitySupport { auto, off, on }
+
+enum KeybindingPresetEnum {
+  vscode,
+  intellij,
+  vim,
+  emacs,
+  custom;
+
+  String get monacoPreset => name;
+}
+
+// --- MODELS (Refactored for Freezed 3) ---
+
+@freezed
+abstract class LanguageConfig with _$LanguageConfig {
+  const factory LanguageConfig({
+    int? tabSize,
+    bool? insertSpaces,
+    WordWrap? wordWrap,
+    @Default([]) List<int> rulers,
+    bool? formatOnSave,
+    bool? formatOnPaste,
+    bool? formatOnType,
+    String? autoClosingBrackets,
+    String? autoClosingQuotes,
+    bool? bracketPairColorization,
+    Map<String, dynamic>? customTheme,
+  }) = _LanguageConfig;
+
+  factory LanguageConfig.fromJson(Map<String, dynamic> json) =>
+      _$LanguageConfigFromJson(json);
+}
+
+@freezed
+abstract class EditorSettings with _$EditorSettings {
+  const factory EditorSettings({
+    // General Settings
+    @JsonKey(name: 'editor_theme') @Default('vs-dark') String theme,
+    @JsonKey(name: 'editor_font_size') @Default(14) double fontSize,
+    @JsonKey(name: 'editor_font_family')
+    @Default(
+      'JetBrains Mono, SF Mono, Menlo, Consolas, "Courier New", monospace',
+    )
+    String fontFamily,
+    @JsonKey(name: 'editor_line_height') @Default(1.4) double lineHeight,
+    @JsonKey(name: 'editor_letter_spacing') @Default(0) double letterSpacing,
+
+    // Display Settings
+    @JsonKey(name: 'editor_show_line_numbers')
+    @Default(true)
+    bool showLineNumbers,
+    @JsonKey(name: 'editor_line_numbers_style')
+    @Default(LineNumbersStyle.on)
+    LineNumbersStyle lineNumbersStyle,
+    @JsonKey(name: 'editor_show_minimap') @Default(false) bool showMinimap,
+    @JsonKey(name: 'editor_minimap_side')
+    @Default(MinimapSide.right)
+    MinimapSide minimapSide,
+    @JsonKey(name: 'editor_minimap_render_characters')
+    @Default(false)
+    bool minimapRenderCharacters,
+    @JsonKey(name: 'editor_minimap_size') @Default(1) int minimapSize,
+    @JsonKey(name: 'editor_show_indent_guides')
+    @Default(true)
+    bool showIndentGuides,
+    @JsonKey(name: 'editor_render_whitespace')
+    @Default(RenderWhitespace.selection)
+    RenderWhitespace renderWhitespace,
+    @JsonKey(name: 'editor_rulers') @Default([]) List<int> rulers,
+    @JsonKey(name: 'editor_sticky_scroll') @Default(false) bool stickyScroll,
+    @JsonKey(name: 'editor_show_folding_controls')
+    @Default('mouseover')
+    String showFoldingControls,
+    @JsonKey(name: 'editor_glyph_margin') @Default(true) bool glyphMargin,
+    @JsonKey(name: 'editor_render_line_highlight')
+    @Default('line')
+    String renderLineHighlight,
+
+    // Editor Behavior
+    @JsonKey(name: 'editor_word_wrap') @Default(WordWrap.on) WordWrap wordWrap,
+    @JsonKey(name: 'editor_word_wrap_column') @Default(80) int wordWrapColumn,
+    @JsonKey(name: 'editor_tab_size') @Default(4) int tabSize,
+    @JsonKey(name: 'editor_insert_spaces') @Default(true) bool insertSpaces,
+    @JsonKey(name: 'editor_auto_indent') @Default('advanced') String autoIndent,
+    @JsonKey(name: 'editor_auto_closing_brackets')
+    @Default('languageDefined')
+    String autoClosingBrackets,
+    @JsonKey(name: 'editor_auto_closing_quotes')
+    @Default('languageDefined')
+    String autoClosingQuotes,
+    @JsonKey(name: 'editor_auto_surround')
+    @Default('languageDefined')
+    String autoSurround,
+    @JsonKey(name: 'editor_bracket_pair_colorization')
+    @Default(true)
+    bool bracketPairColorization,
+    @JsonKey(name: 'editor_code_folding') @Default(true) bool codeFolding,
+    @JsonKey(name: 'editor_scroll_beyond_last_line')
+    @Default(true)
+    bool scrollBeyondLastLine,
+    @JsonKey(name: 'editor_smooth_scrolling')
+    @Default(false)
+    bool smoothScrolling,
+    @JsonKey(name: 'editor_fast_scroll_sensitivity')
+    @Default(5)
+    double fastScrollSensitivity,
+    @JsonKey(name: 'editor_scroll_predominant_axis')
+    @Default(true)
+    bool scrollPredominantAxis,
+
+    // Cursor Settings
+    @JsonKey(name: 'editor_cursor_blinking')
+    @Default(CursorBlinking.blink)
+    CursorBlinking cursorBlinking,
+    @JsonKey(name: 'editor_cursor_smooth_caret_animation')
+    @Default('off')
+    String cursorSmoothCaretAnimation,
+    @JsonKey(name: 'editor_cursor_style')
+    @Default(CursorStyle.line)
+    CursorStyle cursorStyle,
+    @JsonKey(name: 'editor_cursor_width') @Default(0) int cursorWidth,
+    @JsonKey(name: 'editor_multi_cursor_modifier')
+    @Default(MultiCursorModifier.ctrlCmd)
+    MultiCursorModifier multiCursorModifier,
+    @JsonKey(name: 'editor_multi_cursor_merge_overlapping')
+    @Default(true)
+    bool multiCursorMergeOverlapping,
+
+    // Editing Features
+    @JsonKey(name: 'editor_format_on_save') @Default(false) bool formatOnSave,
+    @JsonKey(name: 'editor_format_on_paste') @Default(false) bool formatOnPaste,
+    @JsonKey(name: 'editor_format_on_type') @Default(false) bool formatOnType,
+    @JsonKey(name: 'editor_quick_suggestions')
+    @Default(true)
+    bool quickSuggestions,
+    @JsonKey(name: 'editor_quick_suggestions_delay')
+    @Default(10)
+    int quickSuggestionsDelay,
+    @JsonKey(name: 'editor_suggest_on_trigger_characters')
+    @Default(true)
+    bool suggestOnTriggerCharacters,
+    @JsonKey(name: 'editor_accept_suggestion_on_enter')
+    @Default(AcceptSuggestionOnEnter.on)
+    AcceptSuggestionOnEnter acceptSuggestionOnEnter,
+    @JsonKey(name: 'editor_accept_suggestion_on_commit_character')
+    @Default(true)
+    bool acceptSuggestionOnCommitCharacter,
+    @JsonKey(name: 'editor_snippet_suggestions')
+    @Default(SnippetSuggestions.inline)
+    SnippetSuggestions snippetSuggestions,
+    @JsonKey(name: 'editor_word_based_suggestions')
+    @Default(WordBasedSuggestions.currentDocument)
+    WordBasedSuggestions wordBasedSuggestions,
+    @JsonKey(name: 'editor_parameter_hints') @Default(true) bool parameterHints,
+    @JsonKey(name: 'editor_hover') @Default(true) bool hover,
+    @JsonKey(name: 'editor_context_menu') @Default(true) bool contextMenu,
+
+    // Find & Replace
+    @JsonKey(name: 'editor_find') @Default(true) bool find,
+    @JsonKey(name: 'editor_seed_search_string_from_selection')
+    @Default('selection')
+    String seedSearchStringFromSelection,
+
+    // Accessibility
+    @JsonKey(name: 'editor_accessibility_support')
+    @Default(AccessibilitySupport.auto)
+    AccessibilitySupport accessibilitySupport,
+    @JsonKey(name: 'editor_accessibility_page_size')
+    @Default(10)
+    int accessibilityPageSize,
+
+    // Performance
+    @JsonKey(name: 'editor_render_validation_decorations')
+    @Default('editable')
+    String renderValidationDecorations,
+    @JsonKey(name: 'editor_render_control_characters')
+    @Default(false)
+    bool renderControlCharacters,
+    @JsonKey(name: 'editor_disable_layer_hinting')
+    @Default(false)
+    bool disableLayerHinting,
+    @JsonKey(name: 'editor_disable_monospace_optimizations')
+    @Default(false)
+    bool disableMonospaceOptimizations,
+    @JsonKey(name: 'editor_max_tokenization_line_length')
+    @Default(20000)
+    int maxTokenizationLineLength,
+
+    // Language Specific
+    @JsonKey(name: 'editor_language_configs')
+    @Default({})
+    Map<String, LanguageConfig> languageConfigs,
+
+    // Keybindings
+    @JsonKey(name: 'editor_keybinding_preset')
+    @Default(KeybindingPresetEnum.vscode)
+    KeybindingPresetEnum keybindingPreset,
+    @JsonKey(name: 'editor_custom_keybindings')
+    @Default({})
+    Map<String, String> customKeybindings,
+
+    // Advanced
+    @JsonKey(name: 'editor_read_only') @Default(false) bool readOnly,
+    @JsonKey(name: 'editor_dom_read_only') @Default(false) bool domReadOnly,
+    @JsonKey(name: 'editor_drag_and_drop') @Default(true) bool dragAndDrop,
+    @JsonKey(name: 'editor_links') @Default(true) bool links,
+    @JsonKey(name: 'editor_mouse_wheel_zoom')
+    @Default(false)
+    bool mouseWheelZoom,
+    @JsonKey(name: 'editor_mouse_wheel_scroll_sensitivity')
+    @Default(1)
+    double mouseWheelScrollSensitivity,
+    @JsonKey(name: 'editor_automatic_layout')
+    @Default(true)
+    bool automaticLayout,
+    @JsonKey(name: 'editor_padding')
+    @Default({'top': 10, 'bottom': 10, 'start': 10, 'end': 10})
+    Map<String, int> padding,
+    @JsonKey(name: 'editor_rounded_selection')
+    @Default(true)
+    bool roundedSelection,
+    @JsonKey(name: 'editor_selection_highlight')
+    @Default(true)
+    bool selectionHighlight,
+    @JsonKey(name: 'editor_occurrences_highlight')
+    @Default('singleFile')
+    String occurrencesHighlight,
+    @JsonKey(name: 'editor_overview_ruler_border')
+    @Default(true)
+    bool overviewRulerBorder,
+    @JsonKey(name: 'editor_hide_cursor_in_overview_ruler')
+    @Default(false)
+    bool hideCursorInOverviewRuler,
+    @JsonKey(name: 'editor_scrollbar')
+    @Default({
+      'vertical': 'auto',
+      'horizontal': 'auto',
+      'arrowSize': 11,
+      'useShadows': true,
+      'verticalScrollbarSize': 14,
+      'horizontalScrollbarSize': 10,
+      'scrollByPage': false,
+    })
+    Map<String, dynamic> scrollbar,
+    @JsonKey(name: 'editor_experimental_features')
+    @Default({})
+    Map<String, dynamic> experimentalFeatures,
+  }) = _EditorSettings;
+  // Private constructor enables "mixed mode" for adding custom logic.
+  const EditorSettings._();
+
+  /// Handles JSON conversion.
+  factory EditorSettings.fromJson(Map<String, dynamic> json) =>
+      _$EditorSettingsFromJson(json);
+
+  /// Create preset configurations
+  factory EditorSettings.createPreset(String presetName) {
+    switch (presetName.toLowerCase()) {
+      case 'beginner':
+        return const EditorSettings(
+          showMinimap: false,
+          fontSize: 16,
+          formatOnSave: true,
+          formatOnPaste: true,
+          autoClosingBrackets: 'always',
+          autoClosingQuotes: 'always',
+        );
+      case 'developer':
+        return const EditorSettings(
+          showMinimap: true,
+          wordWrap: WordWrap.off,
+          rulers: [80, 120],
+          formatOnSave: true,
+          renderWhitespace: RenderWhitespace.boundary,
+        );
+      case 'poweruser':
+        return const EditorSettings(
+          lineNumbersStyle: LineNumbersStyle.relative,
+          showMinimap: true,
+          fontSize: 13,
+          wordWrap: WordWrap.off,
+          rulers: [80, 100, 120],
+          formatOnSave: true,
+          formatOnType: true,
+          stickyScroll: true,
+          renderWhitespace: RenderWhitespace.all,
+          cursorBlinking: CursorBlinking.smooth,
+          multiCursorModifier: MultiCursorModifier.alt,
+        );
+      case 'accessibility':
+        return const EditorSettings(
+          fontSize: 18,
+          lineHeight: 1.6,
+          accessibilitySupport: AccessibilitySupport.on,
+          renderWhitespace: RenderWhitespace.all,
+          renderControlCharacters: true,
+          cursorBlinking: CursorBlinking.solid,
+          cursorStyle: CursorStyle.block,
+          cursorWidth: 3,
+        );
+      default:
+        return const EditorSettings();
+    }
+  }
+
+  /// Get settings for a specific language, merging global and language-specific settings.
+  EditorSettings getLanguageSettings(String language) {
+    final langConfig = languageConfigs[language];
+    if (langConfig == null) return this;
+
+    return copyWith(
+      tabSize: langConfig.tabSize ?? tabSize,
+      insertSpaces: langConfig.insertSpaces ?? insertSpaces,
+      wordWrap: langConfig.wordWrap ?? wordWrap,
+      rulers: langConfig.rulers,
+      formatOnSave: langConfig.formatOnSave ?? formatOnSave,
+      formatOnPaste: langConfig.formatOnPaste ?? formatOnPaste,
+      formatOnType: langConfig.formatOnType ?? formatOnType,
+      autoClosingBrackets:
+          langConfig.autoClosingBrackets ?? autoClosingBrackets,
+      autoClosingQuotes: langConfig.autoClosingQuotes ?? autoClosingQuotes,
+      bracketPairColorization:
+          langConfig.bracketPairColorization ?? bracketPairColorization,
+    );
+  }
+
+  /// Convert to Monaco editor options format (without prefixes)
+  Map<String, dynamic> toMonacoOptions() {
+    return {
+      'fontSize': fontSize,
+      'fontFamily': fontFamily,
+      'lineHeight': lineHeight,
+      'letterSpacing': letterSpacing,
+      'lineNumbers': showLineNumbers ? lineNumbersStyle.name : 'off',
+      'minimap': {
+        'enabled': showMinimap,
+        'side': minimapSide.name,
+        'renderCharacters': minimapRenderCharacters,
+        'size': minimapSize == 1
+            ? 'proportional'
+            : (minimapSize == 2 ? 'fill' : 'fit'),
+      },
+      'renderIndentGuides': showIndentGuides,
+      'renderWhitespace': renderWhitespace.name,
+      'rulers': rulers,
+      'stickyScroll': {'enabled': stickyScroll},
+      'showFoldingControls': showFoldingControls,
+      'glyphMargin': glyphMargin,
+      'renderLineHighlight': renderLineHighlight,
+      'wordWrap': wordWrap.name,
+      'wordWrapColumn': wordWrapColumn,
+      'tabSize': tabSize,
+      'insertSpaces': insertSpaces,
+      'autoIndent': autoIndent,
+      'autoClosingBrackets': autoClosingBrackets,
+      'autoClosingQuotes': autoClosingQuotes,
+      'autoSurround': autoSurround,
+      'bracketPairColorization': {'enabled': bracketPairColorization},
+      'folding': codeFolding,
+      'scrollBeyondLastLine': scrollBeyondLastLine,
+      'smoothScrolling': smoothScrolling,
+      'fastScrollSensitivity': fastScrollSensitivity,
+      'scrollPredominantAxis': scrollPredominantAxis,
+      'cursorBlinking': cursorBlinking.name,
+      'cursorSmoothCaretAnimation': cursorSmoothCaretAnimation,
+      'cursorStyle': cursorStyle.name,
+      'cursorWidth': cursorWidth,
+      'multiCursorModifier': multiCursorModifier == MultiCursorModifier.ctrlCmd
+          ? 'ctrlCmd'
+          : 'alt',
+      'multiCursorMergeOverlapping': multiCursorMergeOverlapping,
+      'formatOnPaste': formatOnPaste,
+      'formatOnType': formatOnType,
+      'quickSuggestions': quickSuggestions,
+      'quickSuggestionsDelay': quickSuggestionsDelay,
+      'suggestOnTriggerCharacters': suggestOnTriggerCharacters,
+      'acceptSuggestionOnEnter': acceptSuggestionOnEnter.name,
+      'acceptSuggestionOnCommitCharacter': acceptSuggestionOnCommitCharacter,
+      'snippetSuggestions': snippetSuggestions.name,
+      'wordBasedSuggestions': wordBasedSuggestions.name,
+      'parameterHints': {'enabled': parameterHints},
+      'hover': {'enabled': hover},
+      'contextmenu': contextMenu,
+      'find': {
+        'seedSearchStringFromSelection': seedSearchStringFromSelection,
+      },
+      'accessibilitySupport': accessibilitySupport.name,
+      'accessibilityPageSize': accessibilityPageSize,
+      'renderValidationDecorations': renderValidationDecorations,
+      'renderControlCharacters': renderControlCharacters,
+      'disableLayerHinting': disableLayerHinting,
+      'disableMonospaceOptimizations': disableMonospaceOptimizations,
+      'maxTokenizationLineLength': maxTokenizationLineLength,
+      'readOnly': readOnly,
+      'domReadOnly': domReadOnly,
+      'dragAndDrop': dragAndDrop,
+      'links': links,
+      'mouseWheelZoom': mouseWheelZoom,
+      'mouseWheelScrollSensitivity': mouseWheelScrollSensitivity,
+      'automaticLayout': automaticLayout,
+      'padding': padding,
+      'roundedSelection': roundedSelection,
+      'selectionHighlight': selectionHighlight,
+      'occurrencesHighlight': occurrencesHighlight == 'singleFile',
+      'overviewRulerBorder': overviewRulerBorder,
+      'hideCursorInOverviewRuler': hideCursorInOverviewRuler,
+      'scrollbar': scrollbar,
+    };
+  }
+}
diff --git a/lib/src/features/editor/core/model/editor_settings.freezed.dart b/lib/src/features/editor/core/model/editor_settings.freezed.dart
new file mode 100644
index 0000000..5c1e938
--- /dev/null
+++ b/lib/src/features/editor/core/model/editor_settings.freezed.dart
@@ -0,0 +1,615 @@
+// dart format width=80
+// coverage:ignore-file
+// GENERATED CODE - DO NOT MODIFY BY HAND
+// ignore_for_file: type=lint
+// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
+
+part of 'editor_settings.dart';
+
+// **************************************************************************
+// FreezedGenerator
+// **************************************************************************
+
+// dart format off
+T _$identity<T>(T value) => value;
+
+/// @nodoc
+mixin _$LanguageConfig {
+
+ int? get tabSize; bool? get insertSpaces; WordWrap? get wordWrap; List<int> get rulers; bool? get formatOnSave; bool? get formatOnPaste; bool? get formatOnType; String? get autoClosingBrackets; String? get autoClosingQuotes; bool? get bracketPairColorization; Map<String, dynamic>? get customTheme;
+/// Create a copy of LanguageConfig
+/// with the given fields replaced by the non-null parameter values.
+@JsonKey(includeFromJson: false, includeToJson: false)
+@pragma('vm:prefer-inline')
+$LanguageConfigCopyWith<LanguageConfig> get copyWith => _$LanguageConfigCopyWithImpl<LanguageConfig>(this as LanguageConfig, _$identity);
+
+  /// Serializes this LanguageConfig to a JSON map.
+  Map<String, dynamic> toJson();
+
+
+@override
+bool operator ==(Object other) {
+  return identical(this, other) || (other.runtimeType == runtimeType&&other is LanguageConfig&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.wordWrap, wordWrap) || other.wordWrap == wordWrap)&&const DeepCollectionEquality().equals(other.rulers, rulers)&&(identical(other.formatOnSave, formatOnSave) || other.formatOnSave == formatOnSave)&&(identical(other.formatOnPaste, formatOnPaste) || other.formatOnPaste == formatOnPaste)&&(identical(other.formatOnType, formatOnType) || other.formatOnType == formatOnType)&&(identical(other.autoClosingBrackets, autoClosingBrackets) || other.autoClosingBrackets == autoClosingBrackets)&&(identical(other.autoClosingQuotes, autoClosingQuotes) || other.autoClosingQuotes == autoClosingQuotes)&&(identical(other.bracketPairColorization, bracketPairColorization) || other.bracketPairColorization == bracketPairColorization)&&const DeepCollectionEquality().equals(other.customTheme, customTheme));
+}
+
+@JsonKey(includeFromJson: false, includeToJson: false)
+@override
+int get hashCode => Object.hash(runtimeType,tabSize,insertSpaces,wordWrap,const DeepCollectionEquality().hash(rulers),formatOnSave,formatOnPaste,formatOnType,autoClosingBrackets,autoClosingQuotes,bracketPairColorization,const DeepCollectionEquality().hash(customTheme));
+
+@override
+String toString() {
+  return 'LanguageConfig(tabSize: $tabSize, insertSpaces: $insertSpaces, wordWrap: $wordWrap, rulers: $rulers, formatOnSave: $formatOnSave, formatOnPaste: $formatOnPaste, formatOnType: $formatOnType, autoClosingBrackets: $autoClosingBrackets, autoClosingQuotes: $autoClosingQuotes, bracketPairColorization: $bracketPairColorization, customTheme: $customTheme)';
+}
+
+
+}
+
+/// @nodoc
+abstract mixin class $LanguageConfigCopyWith<$Res>  {
+  factory $LanguageConfigCopyWith(LanguageConfig value, $Res Function(LanguageConfig) _then) = _$LanguageConfigCopyWithImpl;
+@useResult
+$Res call({
+ int? tabSize, bool? insertSpaces, WordWrap? wordWrap, List<int> rulers, bool? formatOnSave, bool? formatOnPaste, bool? formatOnType, String? autoClosingBrackets, String? autoClosingQuotes, bool? bracketPairColorization, Map<String, dynamic>? customTheme
+});
+
+
+
+
+}
+/// @nodoc
+class _$LanguageConfigCopyWithImpl<$Res>
+    implements $LanguageConfigCopyWith<$Res> {
+  _$LanguageConfigCopyWithImpl(this._self, this._then);
+
+  final LanguageConfig _self;
+  final $Res Function(LanguageConfig) _then;
+
+/// Create a copy of LanguageConfig
+/// with the given fields replaced by the non-null parameter values.
+@pragma('vm:prefer-inline') @override $Res call({Object? tabSize = freezed,Object? insertSpaces = freezed,Object? wordWrap = freezed,Object? rulers = null,Object? formatOnSave = freezed,Object? formatOnPaste = freezed,Object? formatOnType = freezed,Object? autoClosingBrackets = freezed,Object? autoClosingQuotes = freezed,Object? bracketPairColorization = freezed,Object? customTheme = freezed,}) {
+  return _then(_self.copyWith(
+tabSize: freezed == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
+as int?,insertSpaces: freezed == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
+as bool?,wordWrap: freezed == wordWrap ? _self.wordWrap : wordWrap // ignore: cast_nullable_to_non_nullable
+as WordWrap?,rulers: null == rulers ? _self.rulers : rulers // ignore: cast_nullable_to_non_nullable
+as List<int>,formatOnSave: freezed == formatOnSave ? _self.formatOnSave : formatOnSave // ignore: cast_nullable_to_non_nullable
+as bool?,formatOnPaste: freezed == formatOnPaste ? _self.formatOnPaste : formatOnPaste // ignore: cast_nullable_to_non_nullable
+as bool?,formatOnType: freezed == formatOnType ? _self.formatOnType : formatOnType // ignore: cast_nullable_to_non_nullable
+as bool?,autoClosingBrackets: freezed == autoClosingBrackets ? _self.autoClosingBrackets : autoClosingBrackets // ignore: cast_nullable_to_non_nullable
+as String?,autoClosingQuotes: freezed == autoClosingQuotes ? _self.autoClosingQuotes : autoClosingQuotes // ignore: cast_nullable_to_non_nullable
+as String?,bracketPairColorization: freezed == bracketPairColorization ? _self.bracketPairColorization : bracketPairColorization // ignore: cast_nullable_to_non_nullable
+as bool?,customTheme: freezed == customTheme ? _self.customTheme : customTheme // ignore: cast_nullable_to_non_nullable
+as Map<String, dynamic>?,
+  ));
+}
+
+}
+
+
+/// @nodoc
+@JsonSerializable()
+
+class _LanguageConfig implements LanguageConfig {
+  const _LanguageConfig({this.tabSize, this.insertSpaces, this.wordWrap, final  List<int> rulers = const [], this.formatOnSave, this.formatOnPaste, this.formatOnType, this.autoClosingBrackets, this.autoClosingQuotes, this.bracketPairColorization, final  Map<String, dynamic>? customTheme}): _rulers = rulers,_customTheme = customTheme;
+  factory _LanguageConfig.fromJson(Map<String, dynamic> json) => _$LanguageConfigFromJson(json);
+
+@override final  int? tabSize;
+@override final  bool? insertSpaces;
+@override final  WordWrap? wordWrap;
+ final  List<int> _rulers;
+@override@JsonKey() List<int> get rulers {
+  if (_rulers is EqualUnmodifiableListView) return _rulers;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableListView(_rulers);
+}
+
+@override final  bool? formatOnSave;
+@override final  bool? formatOnPaste;
+@override final  bool? formatOnType;
+@override final  String? autoClosingBrackets;
+@override final  String? autoClosingQuotes;
+@override final  bool? bracketPairColorization;
+ final  Map<String, dynamic>? _customTheme;
+@override Map<String, dynamic>? get customTheme {
+  final value = _customTheme;
+  if (value == null) return null;
+  if (_customTheme is EqualUnmodifiableMapView) return _customTheme;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableMapView(value);
+}
+
+
+/// Create a copy of LanguageConfig
+/// with the given fields replaced by the non-null parameter values.
+@override @JsonKey(includeFromJson: false, includeToJson: false)
+@pragma('vm:prefer-inline')
+_$LanguageConfigCopyWith<_LanguageConfig> get copyWith => __$LanguageConfigCopyWithImpl<_LanguageConfig>(this, _$identity);
+
+@override
+Map<String, dynamic> toJson() {
+  return _$LanguageConfigToJson(this, );
+}
+
+@override
+bool operator ==(Object other) {
+  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LanguageConfig&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.wordWrap, wordWrap) || other.wordWrap == wordWrap)&&const DeepCollectionEquality().equals(other._rulers, _rulers)&&(identical(other.formatOnSave, formatOnSave) || other.formatOnSave == formatOnSave)&&(identical(other.formatOnPaste, formatOnPaste) || other.formatOnPaste == formatOnPaste)&&(identical(other.formatOnType, formatOnType) || other.formatOnType == formatOnType)&&(identical(other.autoClosingBrackets, autoClosingBrackets) || other.autoClosingBrackets == autoClosingBrackets)&&(identical(other.autoClosingQuotes, autoClosingQuotes) || other.autoClosingQuotes == autoClosingQuotes)&&(identical(other.bracketPairColorization, bracketPairColorization) || other.bracketPairColorization == bracketPairColorization)&&const DeepCollectionEquality().equals(other._customTheme, _customTheme));
+}
+
+@JsonKey(includeFromJson: false, includeToJson: false)
+@override
+int get hashCode => Object.hash(runtimeType,tabSize,insertSpaces,wordWrap,const DeepCollectionEquality().hash(_rulers),formatOnSave,formatOnPaste,formatOnType,autoClosingBrackets,autoClosingQuotes,bracketPairColorization,const DeepCollectionEquality().hash(_customTheme));
+
+@override
+String toString() {
+  return 'LanguageConfig(tabSize: $tabSize, insertSpaces: $insertSpaces, wordWrap: $wordWrap, rulers: $rulers, formatOnSave: $formatOnSave, formatOnPaste: $formatOnPaste, formatOnType: $formatOnType, autoClosingBrackets: $autoClosingBrackets, autoClosingQuotes: $autoClosingQuotes, bracketPairColorization: $bracketPairColorization, customTheme: $customTheme)';
+}
+
+
+}
+
+/// @nodoc
+abstract mixin class _$LanguageConfigCopyWith<$Res> implements $LanguageConfigCopyWith<$Res> {
+  factory _$LanguageConfigCopyWith(_LanguageConfig value, $Res Function(_LanguageConfig) _then) = __$LanguageConfigCopyWithImpl;
+@override @useResult
+$Res call({
+ int? tabSize, bool? insertSpaces, WordWrap? wordWrap, List<int> rulers, bool? formatOnSave, bool? formatOnPaste, bool? formatOnType, String? autoClosingBrackets, String? autoClosingQuotes, bool? bracketPairColorization, Map<String, dynamic>? customTheme
+});
+
+
+
+
+}
+/// @nodoc
+class __$LanguageConfigCopyWithImpl<$Res>
+    implements _$LanguageConfigCopyWith<$Res> {
+  __$LanguageConfigCopyWithImpl(this._self, this._then);
+
+  final _LanguageConfig _self;
+  final $Res Function(_LanguageConfig) _then;
+
+/// Create a copy of LanguageConfig
+/// with the given fields replaced by the non-null parameter values.
+@override @pragma('vm:prefer-inline') $Res call({Object? tabSize = freezed,Object? insertSpaces = freezed,Object? wordWrap = freezed,Object? rulers = null,Object? formatOnSave = freezed,Object? formatOnPaste = freezed,Object? formatOnType = freezed,Object? autoClosingBrackets = freezed,Object? autoClosingQuotes = freezed,Object? bracketPairColorization = freezed,Object? customTheme = freezed,}) {
+  return _then(_LanguageConfig(
+tabSize: freezed == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
+as int?,insertSpaces: freezed == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
+as bool?,wordWrap: freezed == wordWrap ? _self.wordWrap : wordWrap // ignore: cast_nullable_to_non_nullable
+as WordWrap?,rulers: null == rulers ? _self._rulers : rulers // ignore: cast_nullable_to_non_nullable
+as List<int>,formatOnSave: freezed == formatOnSave ? _self.formatOnSave : formatOnSave // ignore: cast_nullable_to_non_nullable
+as bool?,formatOnPaste: freezed == formatOnPaste ? _self.formatOnPaste : formatOnPaste // ignore: cast_nullable_to_non_nullable
+as bool?,formatOnType: freezed == formatOnType ? _self.formatOnType : formatOnType // ignore: cast_nullable_to_non_nullable
+as bool?,autoClosingBrackets: freezed == autoClosingBrackets ? _self.autoClosingBrackets : autoClosingBrackets // ignore: cast_nullable_to_non_nullable
+as String?,autoClosingQuotes: freezed == autoClosingQuotes ? _self.autoClosingQuotes : autoClosingQuotes // ignore: cast_nullable_to_non_nullable
+as String?,bracketPairColorization: freezed == bracketPairColorization ? _self.bracketPairColorization : bracketPairColorization // ignore: cast_nullable_to_non_nullable
+as bool?,customTheme: freezed == customTheme ? _self._customTheme : customTheme // ignore: cast_nullable_to_non_nullable
+as Map<String, dynamic>?,
+  ));
+}
+
+
+}
+
+
+/// @nodoc
+mixin _$EditorSettings {
+
+// General Settings
+@JsonKey(name: 'editor_theme') String get theme;@JsonKey(name: 'editor_font_size') double get fontSize;@JsonKey(name: 'editor_font_family') String get fontFamily;@JsonKey(name: 'editor_line_height') double get lineHeight;@JsonKey(name: 'editor_letter_spacing') double get letterSpacing;// Display Settings
+@JsonKey(name: 'editor_show_line_numbers') bool get showLineNumbers;@JsonKey(name: 'editor_line_numbers_style') LineNumbersStyle get lineNumbersStyle;@JsonKey(name: 'editor_show_minimap') bool get showMinimap;@JsonKey(name: 'editor_minimap_side') MinimapSide get minimapSide;@JsonKey(name: 'editor_minimap_render_characters') bool get minimapRenderCharacters;@JsonKey(name: 'editor_minimap_size') int get minimapSize;@JsonKey(name: 'editor_show_indent_guides') bool get showIndentGuides;@JsonKey(name: 'editor_render_whitespace') RenderWhitespace get renderWhitespace;@JsonKey(name: 'editor_rulers') List<int> get rulers;@JsonKey(name: 'editor_sticky_scroll') bool get stickyScroll;@JsonKey(name: 'editor_show_folding_controls') String get showFoldingControls;@JsonKey(name: 'editor_glyph_margin') bool get glyphMargin;@JsonKey(name: 'editor_render_line_highlight') String get renderLineHighlight;// Editor Behavior
+@JsonKey(name: 'editor_word_wrap') WordWrap get wordWrap;@JsonKey(name: 'editor_word_wrap_column') int get wordWrapColumn;@JsonKey(name: 'editor_tab_size') int get tabSize;@JsonKey(name: 'editor_insert_spaces') bool get insertSpaces;@JsonKey(name: 'editor_auto_indent') String get autoIndent;@JsonKey(name: 'editor_auto_closing_brackets') String get autoClosingBrackets;@JsonKey(name: 'editor_auto_closing_quotes') String get autoClosingQuotes;@JsonKey(name: 'editor_auto_surround') String get autoSurround;@JsonKey(name: 'editor_bracket_pair_colorization') bool get bracketPairColorization;@JsonKey(name: 'editor_code_folding') bool get codeFolding;@JsonKey(name: 'editor_scroll_beyond_last_line') bool get scrollBeyondLastLine;@JsonKey(name: 'editor_smooth_scrolling') bool get smoothScrolling;@JsonKey(name: 'editor_fast_scroll_sensitivity') double get fastScrollSensitivity;@JsonKey(name: 'editor_scroll_predominant_axis') bool get scrollPredominantAxis;// Cursor Settings
+@JsonKey(name: 'editor_cursor_blinking') CursorBlinking get cursorBlinking;@JsonKey(name: 'editor_cursor_smooth_caret_animation') String get cursorSmoothCaretAnimation;@JsonKey(name: 'editor_cursor_style') CursorStyle get cursorStyle;@JsonKey(name: 'editor_cursor_width') int get cursorWidth;@JsonKey(name: 'editor_multi_cursor_modifier') MultiCursorModifier get multiCursorModifier;@JsonKey(name: 'editor_multi_cursor_merge_overlapping') bool get multiCursorMergeOverlapping;// Editing Features
+@JsonKey(name: 'editor_format_on_save') bool get formatOnSave;@JsonKey(name: 'editor_format_on_paste') bool get formatOnPaste;@JsonKey(name: 'editor_format_on_type') bool get formatOnType;@JsonKey(name: 'editor_quick_suggestions') bool get quickSuggestions;@JsonKey(name: 'editor_quick_suggestions_delay') int get quickSuggestionsDelay;@JsonKey(name: 'editor_suggest_on_trigger_characters') bool get suggestOnTriggerCharacters;@JsonKey(name: 'editor_accept_suggestion_on_enter') AcceptSuggestionOnEnter get acceptSuggestionOnEnter;@JsonKey(name: 'editor_accept_suggestion_on_commit_character') bool get acceptSuggestionOnCommitCharacter;@JsonKey(name: 'editor_snippet_suggestions') SnippetSuggestions get snippetSuggestions;@JsonKey(name: 'editor_word_based_suggestions') WordBasedSuggestions get wordBasedSuggestions;@JsonKey(name: 'editor_parameter_hints') bool get parameterHints;@JsonKey(name: 'editor_hover') bool get hover;@JsonKey(name: 'editor_context_menu') bool get contextMenu;// Find & Replace
+@JsonKey(name: 'editor_find') bool get find;@JsonKey(name: 'editor_seed_search_string_from_selection') String get seedSearchStringFromSelection;// Accessibility
+@JsonKey(name: 'editor_accessibility_support') AccessibilitySupport get accessibilitySupport;@JsonKey(name: 'editor_accessibility_page_size') int get accessibilityPageSize;// Performance
+@JsonKey(name: 'editor_render_validation_decorations') String get renderValidationDecorations;@JsonKey(name: 'editor_render_control_characters') bool get renderControlCharacters;@JsonKey(name: 'editor_disable_layer_hinting') bool get disableLayerHinting;@JsonKey(name: 'editor_disable_monospace_optimizations') bool get disableMonospaceOptimizations;@JsonKey(name: 'editor_max_tokenization_line_length') int get maxTokenizationLineLength;// Language Specific
+@JsonKey(name: 'editor_language_configs') Map<String, LanguageConfig> get languageConfigs;// Keybindings
+@JsonKey(name: 'editor_keybinding_preset') KeybindingPresetEnum get keybindingPreset;@JsonKey(name: 'editor_custom_keybindings') Map<String, String> get customKeybindings;// Advanced
+@JsonKey(name: 'editor_read_only') bool get readOnly;@JsonKey(name: 'editor_dom_read_only') bool get domReadOnly;@JsonKey(name: 'editor_drag_and_drop') bool get dragAndDrop;@JsonKey(name: 'editor_links') bool get links;@JsonKey(name: 'editor_mouse_wheel_zoom') bool get mouseWheelZoom;@JsonKey(name: 'editor_mouse_wheel_scroll_sensitivity') double get mouseWheelScrollSensitivity;@JsonKey(name: 'editor_automatic_layout') bool get automaticLayout;@JsonKey(name: 'editor_padding') Map<String, int> get padding;@JsonKey(name: 'editor_rounded_selection') bool get roundedSelection;@JsonKey(name: 'editor_selection_highlight') bool get selectionHighlight;@JsonKey(name: 'editor_occurrences_highlight') String get occurrencesHighlight;@JsonKey(name: 'editor_overview_ruler_border') bool get overviewRulerBorder;@JsonKey(name: 'editor_hide_cursor_in_overview_ruler') bool get hideCursorInOverviewRuler;@JsonKey(name: 'editor_scrollbar') Map<String, dynamic> get scrollbar;@JsonKey(name: 'editor_experimental_features') Map<String, dynamic> get experimentalFeatures;
+/// Create a copy of EditorSettings
+/// with the given fields replaced by the non-null parameter values.
+@JsonKey(includeFromJson: false, includeToJson: false)
+@pragma('vm:prefer-inline')
+$EditorSettingsCopyWith<EditorSettings> get copyWith => _$EditorSettingsCopyWithImpl<EditorSettings>(this as EditorSettings, _$identity);
+
+  /// Serializes this EditorSettings to a JSON map.
+  Map<String, dynamic> toJson();
+
+
+@override
+bool operator ==(Object other) {
+  return identical(this, other) || (other.runtimeType == runtimeType&&other is EditorSettings&&(identical(other.theme, theme) || other.theme == theme)&&(identical(other.fontSize, fontSize) || other.fontSize == fontSize)&&(identical(other.fontFamily, fontFamily) || other.fontFamily == fontFamily)&&(identical(other.lineHeight, lineHeight) || other.lineHeight == lineHeight)&&(identical(other.letterSpacing, letterSpacing) || other.letterSpacing == letterSpacing)&&(identical(other.showLineNumbers, showLineNumbers) || other.showLineNumbers == showLineNumbers)&&(identical(other.lineNumbersStyle, lineNumbersStyle) || other.lineNumbersStyle == lineNumbersStyle)&&(identical(other.showMinimap, showMinimap) || other.showMinimap == showMinimap)&&(identical(other.minimapSide, minimapSide) || other.minimapSide == minimapSide)&&(identical(other.minimapRenderCharacters, minimapRenderCharacters) || other.minimapRenderCharacters == minimapRenderCharacters)&&(identical(other.minimapSize, minimapSize) || other.minimapSize == minimapSize)&&(identical(other.showIndentGuides, showIndentGuides) || other.showIndentGuides == showIndentGuides)&&(identical(other.renderWhitespace, renderWhitespace) || other.renderWhitespace == renderWhitespace)&&const DeepCollectionEquality().equals(other.rulers, rulers)&&(identical(other.stickyScroll, stickyScroll) || other.stickyScroll == stickyScroll)&&(identical(other.showFoldingControls, showFoldingControls) || other.showFoldingControls == showFoldingControls)&&(identical(other.glyphMargin, glyphMargin) || other.glyphMargin == glyphMargin)&&(identical(other.renderLineHighlight, renderLineHighlight) || other.renderLineHighlight == renderLineHighlight)&&(identical(other.wordWrap, wordWrap) || other.wordWrap == wordWrap)&&(identical(other.wordWrapColumn, wordWrapColumn) || other.wordWrapColumn == wordWrapColumn)&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.autoIndent, autoIndent) || other.autoIndent == autoIndent)&&(identical(other.autoClosingBrackets, autoClosingBrackets) || other.autoClosingBrackets == autoClosingBrackets)&&(identical(other.autoClosingQuotes, autoClosingQuotes) || other.autoClosingQuotes == autoClosingQuotes)&&(identical(other.autoSurround, autoSurround) || other.autoSurround == autoSurround)&&(identical(other.bracketPairColorization, bracketPairColorization) || other.bracketPairColorization == bracketPairColorization)&&(identical(other.codeFolding, codeFolding) || other.codeFolding == codeFolding)&&(identical(other.scrollBeyondLastLine, scrollBeyondLastLine) || other.scrollBeyondLastLine == scrollBeyondLastLine)&&(identical(other.smoothScrolling, smoothScrolling) || other.smoothScrolling == smoothScrolling)&&(identical(other.fastScrollSensitivity, fastScrollSensitivity) || other.fastScrollSensitivity == fastScrollSensitivity)&&(identical(other.scrollPredominantAxis, scrollPredominantAxis) || other.scrollPredominantAxis == scrollPredominantAxis)&&(identical(other.cursorBlinking, cursorBlinking) || other.cursorBlinking == cursorBlinking)&&(identical(other.cursorSmoothCaretAnimation, cursorSmoothCaretAnimation) || other.cursorSmoothCaretAnimation == cursorSmoothCaretAnimation)&&(identical(other.cursorStyle, cursorStyle) || other.cursorStyle == cursorStyle)&&(identical(other.cursorWidth, cursorWidth) || other.cursorWidth == cursorWidth)&&(identical(other.multiCursorModifier, multiCursorModifier) || other.multiCursorModifier == multiCursorModifier)&&(identical(other.multiCursorMergeOverlapping, multiCursorMergeOverlapping) || other.multiCursorMergeOverlapping == multiCursorMergeOverlapping)&&(identical(other.formatOnSave, formatOnSave) || other.formatOnSave == formatOnSave)&&(identical(other.formatOnPaste, formatOnPaste) || other.formatOnPaste == formatOnPaste)&&(identical(other.formatOnType, formatOnType) || other.formatOnType == formatOnType)&&(identical(other.quickSuggestions, quickSuggestions) || other.quickSuggestions == quickSuggestions)&&(identical(other.quickSuggestionsDelay, quickSuggestionsDelay) || other.quickSuggestionsDelay == quickSuggestionsDelay)&&(identical(other.suggestOnTriggerCharacters, suggestOnTriggerCharacters) || other.suggestOnTriggerCharacters == suggestOnTriggerCharacters)&&(identical(other.acceptSuggestionOnEnter, acceptSuggestionOnEnter) || other.acceptSuggestionOnEnter == acceptSuggestionOnEnter)&&(identical(other.acceptSuggestionOnCommitCharacter, acceptSuggestionOnCommitCharacter) || other.acceptSuggestionOnCommitCharacter == acceptSuggestionOnCommitCharacter)&&(identical(other.snippetSuggestions, snippetSuggestions) || other.snippetSuggestions == snippetSuggestions)&&(identical(other.wordBasedSuggestions, wordBasedSuggestions) || other.wordBasedSuggestions == wordBasedSuggestions)&&(identical(other.parameterHints, parameterHints) || other.parameterHints == parameterHints)&&(identical(other.hover, hover) || other.hover == hover)&&(identical(other.contextMenu, contextMenu) || other.contextMenu == contextMenu)&&(identical(other.find, find) || other.find == find)&&(identical(other.seedSearchStringFromSelection, seedSearchStringFromSelection) || other.seedSearchStringFromSelection == seedSearchStringFromSelection)&&(identical(other.accessibilitySupport, accessibilitySupport) || other.accessibilitySupport == accessibilitySupport)&&(identical(other.accessibilityPageSize, accessibilityPageSize) || other.accessibilityPageSize == accessibilityPageSize)&&(identical(other.renderValidationDecorations, renderValidationDecorations) || other.renderValidationDecorations == renderValidationDecorations)&&(identical(other.renderControlCharacters, renderControlCharacters) || other.renderControlCharacters == renderControlCharacters)&&(identical(other.disableLayerHinting, disableLayerHinting) || other.disableLayerHinting == disableLayerHinting)&&(identical(other.disableMonospaceOptimizations, disableMonospaceOptimizations) || other.disableMonospaceOptimizations == disableMonospaceOptimizations)&&(identical(other.maxTokenizationLineLength, maxTokenizationLineLength) || other.maxTokenizationLineLength == maxTokenizationLineLength)&&const DeepCollectionEquality().equals(other.languageConfigs, languageConfigs)&&(identical(other.keybindingPreset, keybindingPreset) || other.keybindingPreset == keybindingPreset)&&const DeepCollectionEquality().equals(other.customKeybindings, customKeybindings)&&(identical(other.readOnly, readOnly) || other.readOnly == readOnly)&&(identical(other.domReadOnly, domReadOnly) || other.domReadOnly == domReadOnly)&&(identical(other.dragAndDrop, dragAndDrop) || other.dragAndDrop == dragAndDrop)&&(identical(other.links, links) || other.links == links)&&(identical(other.mouseWheelZoom, mouseWheelZoom) || other.mouseWheelZoom == mouseWheelZoom)&&(identical(other.mouseWheelScrollSensitivity, mouseWheelScrollSensitivity) || other.mouseWheelScrollSensitivity == mouseWheelScrollSensitivity)&&(identical(other.automaticLayout, automaticLayout) || other.automaticLayout == automaticLayout)&&const DeepCollectionEquality().equals(other.padding, padding)&&(identical(other.roundedSelection, roundedSelection) || other.roundedSelection == roundedSelection)&&(identical(other.selectionHighlight, selectionHighlight) || other.selectionHighlight == selectionHighlight)&&(identical(other.occurrencesHighlight, occurrencesHighlight) || other.occurrencesHighlight == occurrencesHighlight)&&(identical(other.overviewRulerBorder, overviewRulerBorder) || other.overviewRulerBorder == overviewRulerBorder)&&(identical(other.hideCursorInOverviewRuler, hideCursorInOverviewRuler) || other.hideCursorInOverviewRuler == hideCursorInOverviewRuler)&&const DeepCollectionEquality().equals(other.scrollbar, scrollbar)&&const DeepCollectionEquality().equals(other.experimentalFeatures, experimentalFeatures));
+}
+
+@JsonKey(includeFromJson: false, includeToJson: false)
+@override
+int get hashCode => Object.hashAll([runtimeType,theme,fontSize,fontFamily,lineHeight,letterSpacing,showLineNumbers,lineNumbersStyle,showMinimap,minimapSide,minimapRenderCharacters,minimapSize,showIndentGuides,renderWhitespace,const DeepCollectionEquality().hash(rulers),stickyScroll,showFoldingControls,glyphMargin,renderLineHighlight,wordWrap,wordWrapColumn,tabSize,insertSpaces,autoIndent,autoClosingBrackets,autoClosingQuotes,autoSurround,bracketPairColorization,codeFolding,scrollBeyondLastLine,smoothScrolling,fastScrollSensitivity,scrollPredominantAxis,cursorBlinking,cursorSmoothCaretAnimation,cursorStyle,cursorWidth,multiCursorModifier,multiCursorMergeOverlapping,formatOnSave,formatOnPaste,formatOnType,quickSuggestions,quickSuggestionsDelay,suggestOnTriggerCharacters,acceptSuggestionOnEnter,acceptSuggestionOnCommitCharacter,snippetSuggestions,wordBasedSuggestions,parameterHints,hover,contextMenu,find,seedSearchStringFromSelection,accessibilitySupport,accessibilityPageSize,renderValidationDecorations,renderControlCharacters,disableLayerHinting,disableMonospaceOptimizations,maxTokenizationLineLength,const DeepCollectionEquality().hash(languageConfigs),keybindingPreset,const DeepCollectionEquality().hash(customKeybindings),readOnly,domReadOnly,dragAndDrop,links,mouseWheelZoom,mouseWheelScrollSensitivity,automaticLayout,const DeepCollectionEquality().hash(padding),roundedSelection,selectionHighlight,occurrencesHighlight,overviewRulerBorder,hideCursorInOverviewRuler,const DeepCollectionEquality().hash(scrollbar),const DeepCollectionEquality().hash(experimentalFeatures)]);
+
+@override
+String toString() {
+  return 'EditorSettings(theme: $theme, fontSize: $fontSize, fontFamily: $fontFamily, lineHeight: $lineHeight, letterSpacing: $letterSpacing, showLineNumbers: $showLineNumbers, lineNumbersStyle: $lineNumbersStyle, showMinimap: $showMinimap, minimapSide: $minimapSide, minimapRenderCharacters: $minimapRenderCharacters, minimapSize: $minimapSize, showIndentGuides: $showIndentGuides, renderWhitespace: $renderWhitespace, rulers: $rulers, stickyScroll: $stickyScroll, showFoldingControls: $showFoldingControls, glyphMargin: $glyphMargin, renderLineHighlight: $renderLineHighlight, wordWrap: $wordWrap, wordWrapColumn: $wordWrapColumn, tabSize: $tabSize, insertSpaces: $insertSpaces, autoIndent: $autoIndent, autoClosingBrackets: $autoClosingBrackets, autoClosingQuotes: $autoClosingQuotes, autoSurround: $autoSurround, bracketPairColorization: $bracketPairColorization, codeFolding: $codeFolding, scrollBeyondLastLine: $scrollBeyondLastLine, smoothScrolling: $smoothScrolling, fastScrollSensitivity: $fastScrollSensitivity, scrollPredominantAxis: $scrollPredominantAxis, cursorBlinking: $cursorBlinking, cursorSmoothCaretAnimation: $cursorSmoothCaretAnimation, cursorStyle: $cursorStyle, cursorWidth: $cursorWidth, multiCursorModifier: $multiCursorModifier, multiCursorMergeOverlapping: $multiCursorMergeOverlapping, formatOnSave: $formatOnSave, formatOnPaste: $formatOnPaste, formatOnType: $formatOnType, quickSuggestions: $quickSuggestions, quickSuggestionsDelay: $quickSuggestionsDelay, suggestOnTriggerCharacters: $suggestOnTriggerCharacters, acceptSuggestionOnEnter: $acceptSuggestionOnEnter, acceptSuggestionOnCommitCharacter: $acceptSuggestionOnCommitCharacter, snippetSuggestions: $snippetSuggestions, wordBasedSuggestions: $wordBasedSuggestions, parameterHints: $parameterHints, hover: $hover, contextMenu: $contextMenu, find: $find, seedSearchStringFromSelection: $seedSearchStringFromSelection, accessibilitySupport: $accessibilitySupport, accessibilityPageSize: $accessibilityPageSize, renderValidationDecorations: $renderValidationDecorations, renderControlCharacters: $renderControlCharacters, disableLayerHinting: $disableLayerHinting, disableMonospaceOptimizations: $disableMonospaceOptimizations, maxTokenizationLineLength: $maxTokenizationLineLength, languageConfigs: $languageConfigs, keybindingPreset: $keybindingPreset, customKeybindings: $customKeybindings, readOnly: $readOnly, domReadOnly: $domReadOnly, dragAndDrop: $dragAndDrop, links: $links, mouseWheelZoom: $mouseWheelZoom, mouseWheelScrollSensitivity: $mouseWheelScrollSensitivity, automaticLayout: $automaticLayout, padding: $padding, roundedSelection: $roundedSelection, selectionHighlight: $selectionHighlight, occurrencesHighlight: $occurrencesHighlight, overviewRulerBorder: $overviewRulerBorder, hideCursorInOverviewRuler: $hideCursorInOverviewRuler, scrollbar: $scrollbar, experimentalFeatures: $experimentalFeatures)';
+}
+
+
+}
+
+/// @nodoc
+abstract mixin class $EditorSettingsCopyWith<$Res>  {
+  factory $EditorSettingsCopyWith(EditorSettings value, $Res Function(EditorSettings) _then) = _$EditorSettingsCopyWithImpl;
+@useResult
+$Res call({
+@JsonKey(name: 'editor_theme') String theme,@JsonKey(name: 'editor_font_size') double fontSize,@JsonKey(name: 'editor_font_family') String fontFamily,@JsonKey(name: 'editor_line_height') double lineHeight,@JsonKey(name: 'editor_letter_spacing') double letterSpacing,@JsonKey(name: 'editor_show_line_numbers') bool showLineNumbers,@JsonKey(name: 'editor_line_numbers_style') LineNumbersStyle lineNumbersStyle,@JsonKey(name: 'editor_show_minimap') bool showMinimap,@JsonKey(name: 'editor_minimap_side') MinimapSide minimapSide,@JsonKey(name: 'editor_minimap_render_characters') bool minimapRenderCharacters,@JsonKey(name: 'editor_minimap_size') int minimapSize,@JsonKey(name: 'editor_show_indent_guides') bool showIndentGuides,@JsonKey(name: 'editor_render_whitespace') RenderWhitespace renderWhitespace,@JsonKey(name: 'editor_rulers') List<int> rulers,@JsonKey(name: 'editor_sticky_scroll') bool stickyScroll,@JsonKey(name: 'editor_show_folding_controls') String showFoldingControls,@JsonKey(name: 'editor_glyph_margin') bool glyphMargin,@JsonKey(name: 'editor_render_line_highlight') String renderLineHighlight,@JsonKey(name: 'editor_word_wrap') WordWrap wordWrap,@JsonKey(name: 'editor_word_wrap_column') int wordWrapColumn,@JsonKey(name: 'editor_tab_size') int tabSize,@JsonKey(name: 'editor_insert_spaces') bool insertSpaces,@JsonKey(name: 'editor_auto_indent') String autoIndent,@JsonKey(name: 'editor_auto_closing_brackets') String autoClosingBrackets,@JsonKey(name: 'editor_auto_closing_quotes') String autoClosingQuotes,@JsonKey(name: 'editor_auto_surround') String autoSurround,@JsonKey(name: 'editor_bracket_pair_colorization') bool bracketPairColorization,@JsonKey(name: 'editor_code_folding') bool codeFolding,@JsonKey(name: 'editor_scroll_beyond_last_line') bool scrollBeyondLastLine,@JsonKey(name: 'editor_smooth_scrolling') bool smoothScrolling,@JsonKey(name: 'editor_fast_scroll_sensitivity') double fastScrollSensitivity,@JsonKey(name: 'editor_scroll_predominant_axis') bool scrollPredominantAxis,@JsonKey(name: 'editor_cursor_blinking') CursorBlinking cursorBlinking,@JsonKey(name: 'editor_cursor_smooth_caret_animation') String cursorSmoothCaretAnimation,@JsonKey(name: 'editor_cursor_style') CursorStyle cursorStyle,@JsonKey(name: 'editor_cursor_width') int cursorWidth,@JsonKey(name: 'editor_multi_cursor_modifier') MultiCursorModifier multiCursorModifier,@JsonKey(name: 'editor_multi_cursor_merge_overlapping') bool multiCursorMergeOverlapping,@JsonKey(name: 'editor_format_on_save') bool formatOnSave,@JsonKey(name: 'editor_format_on_paste') bool formatOnPaste,@JsonKey(name: 'editor_format_on_type') bool formatOnType,@JsonKey(name: 'editor_quick_suggestions') bool quickSuggestions,@JsonKey(name: 'editor_quick_suggestions_delay') int quickSuggestionsDelay,@JsonKey(name: 'editor_suggest_on_trigger_characters') bool suggestOnTriggerCharacters,@JsonKey(name: 'editor_accept_suggestion_on_enter') AcceptSuggestionOnEnter acceptSuggestionOnEnter,@JsonKey(name: 'editor_accept_suggestion_on_commit_character') bool acceptSuggestionOnCommitCharacter,@JsonKey(name: 'editor_snippet_suggestions') SnippetSuggestions snippetSuggestions,@JsonKey(name: 'editor_word_based_suggestions') WordBasedSuggestions wordBasedSuggestions,@JsonKey(name: 'editor_parameter_hints') bool parameterHints,@JsonKey(name: 'editor_hover') bool hover,@JsonKey(name: 'editor_context_menu') bool contextMenu,@JsonKey(name: 'editor_find') bool find,@JsonKey(name: 'editor_seed_search_string_from_selection') String seedSearchStringFromSelection,@JsonKey(name: 'editor_accessibility_support') AccessibilitySupport accessibilitySupport,@JsonKey(name: 'editor_accessibility_page_size') int accessibilityPageSize,@JsonKey(name: 'editor_render_validation_decorations') String renderValidationDecorations,@JsonKey(name: 'editor_render_control_characters') bool renderControlCharacters,@JsonKey(name: 'editor_disable_layer_hinting') bool disableLayerHinting,@JsonKey(name: 'editor_disable_monospace_optimizations') bool disableMonospaceOptimizations,@JsonKey(name: 'editor_max_tokenization_line_length') int maxTokenizationLineLength,@JsonKey(name: 'editor_language_configs') Map<String, LanguageConfig> languageConfigs,@JsonKey(name: 'editor_keybinding_preset') KeybindingPresetEnum keybindingPreset,@JsonKey(name: 'editor_custom_keybindings') Map<String, String> customKeybindings,@JsonKey(name: 'editor_read_only') bool readOnly,@JsonKey(name: 'editor_dom_read_only') bool domReadOnly,@JsonKey(name: 'editor_drag_and_drop') bool dragAndDrop,@JsonKey(name: 'editor_links') bool links,@JsonKey(name: 'editor_mouse_wheel_zoom') bool mouseWheelZoom,@JsonKey(name: 'editor_mouse_wheel_scroll_sensitivity') double mouseWheelScrollSensitivity,@JsonKey(name: 'editor_automatic_layout') bool automaticLayout,@JsonKey(name: 'editor_padding') Map<String, int> padding,@JsonKey(name: 'editor_rounded_selection') bool roundedSelection,@JsonKey(name: 'editor_selection_highlight') bool selectionHighlight,@JsonKey(name: 'editor_occurrences_highlight') String occurrencesHighlight,@JsonKey(name: 'editor_overview_ruler_border') bool overviewRulerBorder,@JsonKey(name: 'editor_hide_cursor_in_overview_ruler') bool hideCursorInOverviewRuler,@JsonKey(name: 'editor_scrollbar') Map<String, dynamic> scrollbar,@JsonKey(name: 'editor_experimental_features') Map<String, dynamic> experimentalFeatures
+});
+
+
+
+
+}
+/// @nodoc
+class _$EditorSettingsCopyWithImpl<$Res>
+    implements $EditorSettingsCopyWith<$Res> {
+  _$EditorSettingsCopyWithImpl(this._self, this._then);
+
+  final EditorSettings _self;
+  final $Res Function(EditorSettings) _then;
+
+/// Create a copy of EditorSettings
+/// with the given fields replaced by the non-null parameter values.
+@pragma('vm:prefer-inline') @override $Res call({Object? theme = null,Object? fontSize = null,Object? fontFamily = null,Object? lineHeight = null,Object? letterSpacing = null,Object? showLineNumbers = null,Object? lineNumbersStyle = null,Object? showMinimap = null,Object? minimapSide = null,Object? minimapRenderCharacters = null,Object? minimapSize = null,Object? showIndentGuides = null,Object? renderWhitespace = null,Object? rulers = null,Object? stickyScroll = null,Object? showFoldingControls = null,Object? glyphMargin = null,Object? renderLineHighlight = null,Object? wordWrap = null,Object? wordWrapColumn = null,Object? tabSize = null,Object? insertSpaces = null,Object? autoIndent = null,Object? autoClosingBrackets = null,Object? autoClosingQuotes = null,Object? autoSurround = null,Object? bracketPairColorization = null,Object? codeFolding = null,Object? scrollBeyondLastLine = null,Object? smoothScrolling = null,Object? fastScrollSensitivity = null,Object? scrollPredominantAxis = null,Object? cursorBlinking = null,Object? cursorSmoothCaretAnimation = null,Object? cursorStyle = null,Object? cursorWidth = null,Object? multiCursorModifier = null,Object? multiCursorMergeOverlapping = null,Object? formatOnSave = null,Object? formatOnPaste = null,Object? formatOnType = null,Object? quickSuggestions = null,Object? quickSuggestionsDelay = null,Object? suggestOnTriggerCharacters = null,Object? acceptSuggestionOnEnter = null,Object? acceptSuggestionOnCommitCharacter = null,Object? snippetSuggestions = null,Object? wordBasedSuggestions = null,Object? parameterHints = null,Object? hover = null,Object? contextMenu = null,Object? find = null,Object? seedSearchStringFromSelection = null,Object? accessibilitySupport = null,Object? accessibilityPageSize = null,Object? renderValidationDecorations = null,Object? renderControlCharacters = null,Object? disableLayerHinting = null,Object? disableMonospaceOptimizations = null,Object? maxTokenizationLineLength = null,Object? languageConfigs = null,Object? keybindingPreset = null,Object? customKeybindings = null,Object? readOnly = null,Object? domReadOnly = null,Object? dragAndDrop = null,Object? links = null,Object? mouseWheelZoom = null,Object? mouseWheelScrollSensitivity = null,Object? automaticLayout = null,Object? padding = null,Object? roundedSelection = null,Object? selectionHighlight = null,Object? occurrencesHighlight = null,Object? overviewRulerBorder = null,Object? hideCursorInOverviewRuler = null,Object? scrollbar = null,Object? experimentalFeatures = null,}) {
+  return _then(_self.copyWith(
+theme: null == theme ? _self.theme : theme // ignore: cast_nullable_to_non_nullable
+as String,fontSize: null == fontSize ? _self.fontSize : fontSize // ignore: cast_nullable_to_non_nullable
+as double,fontFamily: null == fontFamily ? _self.fontFamily : fontFamily // ignore: cast_nullable_to_non_nullable
+as String,lineHeight: null == lineHeight ? _self.lineHeight : lineHeight // ignore: cast_nullable_to_non_nullable
+as double,letterSpacing: null == letterSpacing ? _self.letterSpacing : letterSpacing // ignore: cast_nullable_to_non_nullable
+as double,showLineNumbers: null == showLineNumbers ? _self.showLineNumbers : showLineNumbers // ignore: cast_nullable_to_non_nullable
+as bool,lineNumbersStyle: null == lineNumbersStyle ? _self.lineNumbersStyle : lineNumbersStyle // ignore: cast_nullable_to_non_nullable
+as LineNumbersStyle,showMinimap: null == showMinimap ? _self.showMinimap : showMinimap // ignore: cast_nullable_to_non_nullable
+as bool,minimapSide: null == minimapSide ? _self.minimapSide : minimapSide // ignore: cast_nullable_to_non_nullable
+as MinimapSide,minimapRenderCharacters: null == minimapRenderCharacters ? _self.minimapRenderCharacters : minimapRenderCharacters // ignore: cast_nullable_to_non_nullable
+as bool,minimapSize: null == minimapSize ? _self.minimapSize : minimapSize // ignore: cast_nullable_to_non_nullable
+as int,showIndentGuides: null == showIndentGuides ? _self.showIndentGuides : showIndentGuides // ignore: cast_nullable_to_non_nullable
+as bool,renderWhitespace: null == renderWhitespace ? _self.renderWhitespace : renderWhitespace // ignore: cast_nullable_to_non_nullable
+as RenderWhitespace,rulers: null == rulers ? _self.rulers : rulers // ignore: cast_nullable_to_non_nullable
+as List<int>,stickyScroll: null == stickyScroll ? _self.stickyScroll : stickyScroll // ignore: cast_nullable_to_non_nullable
+as bool,showFoldingControls: null == showFoldingControls ? _self.showFoldingControls : showFoldingControls // ignore: cast_nullable_to_non_nullable
+as String,glyphMargin: null == glyphMargin ? _self.glyphMargin : glyphMargin // ignore: cast_nullable_to_non_nullable
+as bool,renderLineHighlight: null == renderLineHighlight ? _self.renderLineHighlight : renderLineHighlight // ignore: cast_nullable_to_non_nullable
+as String,wordWrap: null == wordWrap ? _self.wordWrap : wordWrap // ignore: cast_nullable_to_non_nullable
+as WordWrap,wordWrapColumn: null == wordWrapColumn ? _self.wordWrapColumn : wordWrapColumn // ignore: cast_nullable_to_non_nullable
+as int,tabSize: null == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
+as int,insertSpaces: null == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
+as bool,autoIndent: null == autoIndent ? _self.autoIndent : autoIndent // ignore: cast_nullable_to_non_nullable
+as String,autoClosingBrackets: null == autoClosingBrackets ? _self.autoClosingBrackets : autoClosingBrackets // ignore: cast_nullable_to_non_nullable
+as String,autoClosingQuotes: null == autoClosingQuotes ? _self.autoClosingQuotes : autoClosingQuotes // ignore: cast_nullable_to_non_nullable
+as String,autoSurround: null == autoSurround ? _self.autoSurround : autoSurround // ignore: cast_nullable_to_non_nullable
+as String,bracketPairColorization: null == bracketPairColorization ? _self.bracketPairColorization : bracketPairColorization // ignore: cast_nullable_to_non_nullable
+as bool,codeFolding: null == codeFolding ? _self.codeFolding : codeFolding // ignore: cast_nullable_to_non_nullable
+as bool,scrollBeyondLastLine: null == scrollBeyondLastLine ? _self.scrollBeyondLastLine : scrollBeyondLastLine // ignore: cast_nullable_to_non_nullable
+as bool,smoothScrolling: null == smoothScrolling ? _self.smoothScrolling : smoothScrolling // ignore: cast_nullable_to_non_nullable
+as bool,fastScrollSensitivity: null == fastScrollSensitivity ? _self.fastScrollSensitivity : fastScrollSensitivity // ignore: cast_nullable_to_non_nullable
+as double,scrollPredominantAxis: null == scrollPredominantAxis ? _self.scrollPredominantAxis : scrollPredominantAxis // ignore: cast_nullable_to_non_nullable
+as bool,cursorBlinking: null == cursorBlinking ? _self.cursorBlinking : cursorBlinking // ignore: cast_nullable_to_non_nullable
+as CursorBlinking,cursorSmoothCaretAnimation: null == cursorSmoothCaretAnimation ? _self.cursorSmoothCaretAnimation : cursorSmoothCaretAnimation // ignore: cast_nullable_to_non_nullable
+as String,cursorStyle: null == cursorStyle ? _self.cursorStyle : cursorStyle // ignore: cast_nullable_to_non_nullable
+as CursorStyle,cursorWidth: null == cursorWidth ? _self.cursorWidth : cursorWidth // ignore: cast_nullable_to_non_nullable
+as int,multiCursorModifier: null == multiCursorModifier ? _self.multiCursorModifier : multiCursorModifier // ignore: cast_nullable_to_non_nullable
+as MultiCursorModifier,multiCursorMergeOverlapping: null == multiCursorMergeOverlapping ? _self.multiCursorMergeOverlapping : multiCursorMergeOverlapping // ignore: cast_nullable_to_non_nullable
+as bool,formatOnSave: null == formatOnSave ? _self.formatOnSave : formatOnSave // ignore: cast_nullable_to_non_nullable
+as bool,formatOnPaste: null == formatOnPaste ? _self.formatOnPaste : formatOnPaste // ignore: cast_nullable_to_non_nullable
+as bool,formatOnType: null == formatOnType ? _self.formatOnType : formatOnType // ignore: cast_nullable_to_non_nullable
+as bool,quickSuggestions: null == quickSuggestions ? _self.quickSuggestions : quickSuggestions // ignore: cast_nullable_to_non_nullable
+as bool,quickSuggestionsDelay: null == quickSuggestionsDelay ? _self.quickSuggestionsDelay : quickSuggestionsDelay // ignore: cast_nullable_to_non_nullable
+as int,suggestOnTriggerCharacters: null == suggestOnTriggerCharacters ? _self.suggestOnTriggerCharacters : suggestOnTriggerCharacters // ignore: cast_nullable_to_non_nullable
+as bool,acceptSuggestionOnEnter: null == acceptSuggestionOnEnter ? _self.acceptSuggestionOnEnter : acceptSuggestionOnEnter // ignore: cast_nullable_to_non_nullable
+as AcceptSuggestionOnEnter,acceptSuggestionOnCommitCharacter: null == acceptSuggestionOnCommitCharacter ? _self.acceptSuggestionOnCommitCharacter : acceptSuggestionOnCommitCharacter // ignore: cast_nullable_to_non_nullable
+as bool,snippetSuggestions: null == snippetSuggestions ? _self.snippetSuggestions : snippetSuggestions // ignore: cast_nullable_to_non_nullable
+as SnippetSuggestions,wordBasedSuggestions: null == wordBasedSuggestions ? _self.wordBasedSuggestions : wordBasedSuggestions // ignore: cast_nullable_to_non_nullable
+as WordBasedSuggestions,parameterHints: null == parameterHints ? _self.parameterHints : parameterHints // ignore: cast_nullable_to_non_nullable
+as bool,hover: null == hover ? _self.hover : hover // ignore: cast_nullable_to_non_nullable
+as bool,contextMenu: null == contextMenu ? _self.contextMenu : contextMenu // ignore: cast_nullable_to_non_nullable
+as bool,find: null == find ? _self.find : find // ignore: cast_nullable_to_non_nullable
+as bool,seedSearchStringFromSelection: null == seedSearchStringFromSelection ? _self.seedSearchStringFromSelection : seedSearchStringFromSelection // ignore: cast_nullable_to_non_nullable
+as String,accessibilitySupport: null == accessibilitySupport ? _self.accessibilitySupport : accessibilitySupport // ignore: cast_nullable_to_non_nullable
+as AccessibilitySupport,accessibilityPageSize: null == accessibilityPageSize ? _self.accessibilityPageSize : accessibilityPageSize // ignore: cast_nullable_to_non_nullable
+as int,renderValidationDecorations: null == renderValidationDecorations ? _self.renderValidationDecorations : renderValidationDecorations // ignore: cast_nullable_to_non_nullable
+as String,renderControlCharacters: null == renderControlCharacters ? _self.renderControlCharacters : renderControlCharacters // ignore: cast_nullable_to_non_nullable
+as bool,disableLayerHinting: null == disableLayerHinting ? _self.disableLayerHinting : disableLayerHinting // ignore: cast_nullable_to_non_nullable
+as bool,disableMonospaceOptimizations: null == disableMonospaceOptimizations ? _self.disableMonospaceOptimizations : disableMonospaceOptimizations // ignore: cast_nullable_to_non_nullable
+as bool,maxTokenizationLineLength: null == maxTokenizationLineLength ? _self.maxTokenizationLineLength : maxTokenizationLineLength // ignore: cast_nullable_to_non_nullable
+as int,languageConfigs: null == languageConfigs ? _self.languageConfigs : languageConfigs // ignore: cast_nullable_to_non_nullable
+as Map<String, LanguageConfig>,keybindingPreset: null == keybindingPreset ? _self.keybindingPreset : keybindingPreset // ignore: cast_nullable_to_non_nullable
+as KeybindingPresetEnum,customKeybindings: null == customKeybindings ? _self.customKeybindings : customKeybindings // ignore: cast_nullable_to_non_nullable
+as Map<String, String>,readOnly: null == readOnly ? _self.readOnly : readOnly // ignore: cast_nullable_to_non_nullable
+as bool,domReadOnly: null == domReadOnly ? _self.domReadOnly : domReadOnly // ignore: cast_nullable_to_non_nullable
+as bool,dragAndDrop: null == dragAndDrop ? _self.dragAndDrop : dragAndDrop // ignore: cast_nullable_to_non_nullable
+as bool,links: null == links ? _self.links : links // ignore: cast_nullable_to_non_nullable
+as bool,mouseWheelZoom: null == mouseWheelZoom ? _self.mouseWheelZoom : mouseWheelZoom // ignore: cast_nullable_to_non_nullable
+as bool,mouseWheelScrollSensitivity: null == mouseWheelScrollSensitivity ? _self.mouseWheelScrollSensitivity : mouseWheelScrollSensitivity // ignore: cast_nullable_to_non_nullable
+as double,automaticLayout: null == automaticLayout ? _self.automaticLayout : automaticLayout // ignore: cast_nullable_to_non_nullable
+as bool,padding: null == padding ? _self.padding : padding // ignore: cast_nullable_to_non_nullable
+as Map<String, int>,roundedSelection: null == roundedSelection ? _self.roundedSelection : roundedSelection // ignore: cast_nullable_to_non_nullable
+as bool,selectionHighlight: null == selectionHighlight ? _self.selectionHighlight : selectionHighlight // ignore: cast_nullable_to_non_nullable
+as bool,occurrencesHighlight: null == occurrencesHighlight ? _self.occurrencesHighlight : occurrencesHighlight // ignore: cast_nullable_to_non_nullable
+as String,overviewRulerBorder: null == overviewRulerBorder ? _self.overviewRulerBorder : overviewRulerBorder // ignore: cast_nullable_to_non_nullable
+as bool,hideCursorInOverviewRuler: null == hideCursorInOverviewRuler ? _self.hideCursorInOverviewRuler : hideCursorInOverviewRuler // ignore: cast_nullable_to_non_nullable
+as bool,scrollbar: null == scrollbar ? _self.scrollbar : scrollbar // ignore: cast_nullable_to_non_nullable
+as Map<String, dynamic>,experimentalFeatures: null == experimentalFeatures ? _self.experimentalFeatures : experimentalFeatures // ignore: cast_nullable_to_non_nullable
+as Map<String, dynamic>,
+  ));
+}
+
+}
+
+
+/// @nodoc
+@JsonSerializable()
+
+class _EditorSettings extends EditorSettings {
+  const _EditorSettings({@JsonKey(name: 'editor_theme') this.theme = 'vs-dark', @JsonKey(name: 'editor_font_size') this.fontSize = 14, @JsonKey(name: 'editor_font_family') this.fontFamily = 'JetBrains Mono, SF Mono, Menlo, Consolas, "Courier New", monospace', @JsonKey(name: 'editor_line_height') this.lineHeight = 1.4, @JsonKey(name: 'editor_letter_spacing') this.letterSpacing = 0, @JsonKey(name: 'editor_show_line_numbers') this.showLineNumbers = true, @JsonKey(name: 'editor_line_numbers_style') this.lineNumbersStyle = LineNumbersStyle.on, @JsonKey(name: 'editor_show_minimap') this.showMinimap = false, @JsonKey(name: 'editor_minimap_side') this.minimapSide = MinimapSide.right, @JsonKey(name: 'editor_minimap_render_characters') this.minimapRenderCharacters = false, @JsonKey(name: 'editor_minimap_size') this.minimapSize = 1, @JsonKey(name: 'editor_show_indent_guides') this.showIndentGuides = true, @JsonKey(name: 'editor_render_whitespace') this.renderWhitespace = RenderWhitespace.selection, @JsonKey(name: 'editor_rulers') final  List<int> rulers = const [], @JsonKey(name: 'editor_sticky_scroll') this.stickyScroll = false, @JsonKey(name: 'editor_show_folding_controls') this.showFoldingControls = 'mouseover', @JsonKey(name: 'editor_glyph_margin') this.glyphMargin = true, @JsonKey(name: 'editor_render_line_highlight') this.renderLineHighlight = 'line', @JsonKey(name: 'editor_word_wrap') this.wordWrap = WordWrap.on, @JsonKey(name: 'editor_word_wrap_column') this.wordWrapColumn = 80, @JsonKey(name: 'editor_tab_size') this.tabSize = 4, @JsonKey(name: 'editor_insert_spaces') this.insertSpaces = true, @JsonKey(name: 'editor_auto_indent') this.autoIndent = 'advanced', @JsonKey(name: 'editor_auto_closing_brackets') this.autoClosingBrackets = 'languageDefined', @JsonKey(name: 'editor_auto_closing_quotes') this.autoClosingQuotes = 'languageDefined', @JsonKey(name: 'editor_auto_surround') this.autoSurround = 'languageDefined', @JsonKey(name: 'editor_bracket_pair_colorization') this.bracketPairColorization = true, @JsonKey(name: 'editor_code_folding') this.codeFolding = true, @JsonKey(name: 'editor_scroll_beyond_last_line') this.scrollBeyondLastLine = true, @JsonKey(name: 'editor_smooth_scrolling') this.smoothScrolling = false, @JsonKey(name: 'editor_fast_scroll_sensitivity') this.fastScrollSensitivity = 5, @JsonKey(name: 'editor_scroll_predominant_axis') this.scrollPredominantAxis = true, @JsonKey(name: 'editor_cursor_blinking') this.cursorBlinking = CursorBlinking.blink, @JsonKey(name: 'editor_cursor_smooth_caret_animation') this.cursorSmoothCaretAnimation = 'off', @JsonKey(name: 'editor_cursor_style') this.cursorStyle = CursorStyle.line, @JsonKey(name: 'editor_cursor_width') this.cursorWidth = 0, @JsonKey(name: 'editor_multi_cursor_modifier') this.multiCursorModifier = MultiCursorModifier.ctrlCmd, @JsonKey(name: 'editor_multi_cursor_merge_overlapping') this.multiCursorMergeOverlapping = true, @JsonKey(name: 'editor_format_on_save') this.formatOnSave = false, @JsonKey(name: 'editor_format_on_paste') this.formatOnPaste = false, @JsonKey(name: 'editor_format_on_type') this.formatOnType = false, @JsonKey(name: 'editor_quick_suggestions') this.quickSuggestions = true, @JsonKey(name: 'editor_quick_suggestions_delay') this.quickSuggestionsDelay = 10, @JsonKey(name: 'editor_suggest_on_trigger_characters') this.suggestOnTriggerCharacters = true, @JsonKey(name: 'editor_accept_suggestion_on_enter') this.acceptSuggestionOnEnter = AcceptSuggestionOnEnter.on, @JsonKey(name: 'editor_accept_suggestion_on_commit_character') this.acceptSuggestionOnCommitCharacter = true, @JsonKey(name: 'editor_snippet_suggestions') this.snippetSuggestions = SnippetSuggestions.inline, @JsonKey(name: 'editor_word_based_suggestions') this.wordBasedSuggestions = WordBasedSuggestions.currentDocument, @JsonKey(name: 'editor_parameter_hints') this.parameterHints = true, @JsonKey(name: 'editor_hover') this.hover = true, @JsonKey(name: 'editor_context_menu') this.contextMenu = true, @JsonKey(name: 'editor_find') this.find = true, @JsonKey(name: 'editor_seed_search_string_from_selection') this.seedSearchStringFromSelection = 'selection', @JsonKey(name: 'editor_accessibility_support') this.accessibilitySupport = AccessibilitySupport.auto, @JsonKey(name: 'editor_accessibility_page_size') this.accessibilityPageSize = 10, @JsonKey(name: 'editor_render_validation_decorations') this.renderValidationDecorations = 'editable', @JsonKey(name: 'editor_render_control_characters') this.renderControlCharacters = false, @JsonKey(name: 'editor_disable_layer_hinting') this.disableLayerHinting = false, @JsonKey(name: 'editor_disable_monospace_optimizations') this.disableMonospaceOptimizations = false, @JsonKey(name: 'editor_max_tokenization_line_length') this.maxTokenizationLineLength = 20000, @JsonKey(name: 'editor_language_configs') final  Map<String, LanguageConfig> languageConfigs = const {}, @JsonKey(name: 'editor_keybinding_preset') this.keybindingPreset = KeybindingPresetEnum.vscode, @JsonKey(name: 'editor_custom_keybindings') final  Map<String, String> customKeybindings = const {}, @JsonKey(name: 'editor_read_only') this.readOnly = false, @JsonKey(name: 'editor_dom_read_only') this.domReadOnly = false, @JsonKey(name: 'editor_drag_and_drop') this.dragAndDrop = true, @JsonKey(name: 'editor_links') this.links = true, @JsonKey(name: 'editor_mouse_wheel_zoom') this.mouseWheelZoom = false, @JsonKey(name: 'editor_mouse_wheel_scroll_sensitivity') this.mouseWheelScrollSensitivity = 1, @JsonKey(name: 'editor_automatic_layout') this.automaticLayout = true, @JsonKey(name: 'editor_padding') final  Map<String, int> padding = const {'top' : 10, 'bottom' : 10, 'start' : 10, 'end' : 10}, @JsonKey(name: 'editor_rounded_selection') this.roundedSelection = true, @JsonKey(name: 'editor_selection_highlight') this.selectionHighlight = true, @JsonKey(name: 'editor_occurrences_highlight') this.occurrencesHighlight = 'singleFile', @JsonKey(name: 'editor_overview_ruler_border') this.overviewRulerBorder = true, @JsonKey(name: 'editor_hide_cursor_in_overview_ruler') this.hideCursorInOverviewRuler = false, @JsonKey(name: 'editor_scrollbar') final  Map<String, dynamic> scrollbar = const {'vertical' : 'auto', 'horizontal' : 'auto', 'arrowSize' : 11, 'useShadows' : true, 'verticalScrollbarSize' : 14, 'horizontalScrollbarSize' : 10, 'scrollByPage' : false}, @JsonKey(name: 'editor_experimental_features') final  Map<String, dynamic> experimentalFeatures = const {}}): _rulers = rulers,_languageConfigs = languageConfigs,_customKeybindings = customKeybindings,_padding = padding,_scrollbar = scrollbar,_experimentalFeatures = experimentalFeatures,super._();
+  factory _EditorSettings.fromJson(Map<String, dynamic> json) => _$EditorSettingsFromJson(json);
+
+// General Settings
+@override@JsonKey(name: 'editor_theme') final  String theme;
+@override@JsonKey(name: 'editor_font_size') final  double fontSize;
+@override@JsonKey(name: 'editor_font_family') final  String fontFamily;
+@override@JsonKey(name: 'editor_line_height') final  double lineHeight;
+@override@JsonKey(name: 'editor_letter_spacing') final  double letterSpacing;
+// Display Settings
+@override@JsonKey(name: 'editor_show_line_numbers') final  bool showLineNumbers;
+@override@JsonKey(name: 'editor_line_numbers_style') final  LineNumbersStyle lineNumbersStyle;
+@override@JsonKey(name: 'editor_show_minimap') final  bool showMinimap;
+@override@JsonKey(name: 'editor_minimap_side') final  MinimapSide minimapSide;
+@override@JsonKey(name: 'editor_minimap_render_characters') final  bool minimapRenderCharacters;
+@override@JsonKey(name: 'editor_minimap_size') final  int minimapSize;
+@override@JsonKey(name: 'editor_show_indent_guides') final  bool showIndentGuides;
+@override@JsonKey(name: 'editor_render_whitespace') final  RenderWhitespace renderWhitespace;
+ final  List<int> _rulers;
+@override@JsonKey(name: 'editor_rulers') List<int> get rulers {
+  if (_rulers is EqualUnmodifiableListView) return _rulers;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableListView(_rulers);
+}
+
+@override@JsonKey(name: 'editor_sticky_scroll') final  bool stickyScroll;
+@override@JsonKey(name: 'editor_show_folding_controls') final  String showFoldingControls;
+@override@JsonKey(name: 'editor_glyph_margin') final  bool glyphMargin;
+@override@JsonKey(name: 'editor_render_line_highlight') final  String renderLineHighlight;
+// Editor Behavior
+@override@JsonKey(name: 'editor_word_wrap') final  WordWrap wordWrap;
+@override@JsonKey(name: 'editor_word_wrap_column') final  int wordWrapColumn;
+@override@JsonKey(name: 'editor_tab_size') final  int tabSize;
+@override@JsonKey(name: 'editor_insert_spaces') final  bool insertSpaces;
+@override@JsonKey(name: 'editor_auto_indent') final  String autoIndent;
+@override@JsonKey(name: 'editor_auto_closing_brackets') final  String autoClosingBrackets;
+@override@JsonKey(name: 'editor_auto_closing_quotes') final  String autoClosingQuotes;
+@override@JsonKey(name: 'editor_auto_surround') final  String autoSurround;
+@override@JsonKey(name: 'editor_bracket_pair_colorization') final  bool bracketPairColorization;
+@override@JsonKey(name: 'editor_code_folding') final  bool codeFolding;
+@override@JsonKey(name: 'editor_scroll_beyond_last_line') final  bool scrollBeyondLastLine;
+@override@JsonKey(name: 'editor_smooth_scrolling') final  bool smoothScrolling;
+@override@JsonKey(name: 'editor_fast_scroll_sensitivity') final  double fastScrollSensitivity;
+@override@JsonKey(name: 'editor_scroll_predominant_axis') final  bool scrollPredominantAxis;
+// Cursor Settings
+@override@JsonKey(name: 'editor_cursor_blinking') final  CursorBlinking cursorBlinking;
+@override@JsonKey(name: 'editor_cursor_smooth_caret_animation') final  String cursorSmoothCaretAnimation;
+@override@JsonKey(name: 'editor_cursor_style') final  CursorStyle cursorStyle;
+@override@JsonKey(name: 'editor_cursor_width') final  int cursorWidth;
+@override@JsonKey(name: 'editor_multi_cursor_modifier') final  MultiCursorModifier multiCursorModifier;
+@override@JsonKey(name: 'editor_multi_cursor_merge_overlapping') final  bool multiCursorMergeOverlapping;
+// Editing Features
+@override@JsonKey(name: 'editor_format_on_save') final  bool formatOnSave;
+@override@JsonKey(name: 'editor_format_on_paste') final  bool formatOnPaste;
+@override@JsonKey(name: 'editor_format_on_type') final  bool formatOnType;
+@override@JsonKey(name: 'editor_quick_suggestions') final  bool quickSuggestions;
+@override@JsonKey(name: 'editor_quick_suggestions_delay') final  int quickSuggestionsDelay;
+@override@JsonKey(name: 'editor_suggest_on_trigger_characters') final  bool suggestOnTriggerCharacters;
+@override@JsonKey(name: 'editor_accept_suggestion_on_enter') final  AcceptSuggestionOnEnter acceptSuggestionOnEnter;
+@override@JsonKey(name: 'editor_accept_suggestion_on_commit_character') final  bool acceptSuggestionOnCommitCharacter;
+@override@JsonKey(name: 'editor_snippet_suggestions') final  SnippetSuggestions snippetSuggestions;
+@override@JsonKey(name: 'editor_word_based_suggestions') final  WordBasedSuggestions wordBasedSuggestions;
+@override@JsonKey(name: 'editor_parameter_hints') final  bool parameterHints;
+@override@JsonKey(name: 'editor_hover') final  bool hover;
+@override@JsonKey(name: 'editor_context_menu') final  bool contextMenu;
+// Find & Replace
+@override@JsonKey(name: 'editor_find') final  bool find;
+@override@JsonKey(name: 'editor_seed_search_string_from_selection') final  String seedSearchStringFromSelection;
+// Accessibility
+@override@JsonKey(name: 'editor_accessibility_support') final  AccessibilitySupport accessibilitySupport;
+@override@JsonKey(name: 'editor_accessibility_page_size') final  int accessibilityPageSize;
+// Performance
+@override@JsonKey(name: 'editor_render_validation_decorations') final  String renderValidationDecorations;
+@override@JsonKey(name: 'editor_render_control_characters') final  bool renderControlCharacters;
+@override@JsonKey(name: 'editor_disable_layer_hinting') final  bool disableLayerHinting;
+@override@JsonKey(name: 'editor_disable_monospace_optimizations') final  bool disableMonospaceOptimizations;
+@override@JsonKey(name: 'editor_max_tokenization_line_length') final  int maxTokenizationLineLength;
+// Language Specific
+ final  Map<String, LanguageConfig> _languageConfigs;
+// Language Specific
+@override@JsonKey(name: 'editor_language_configs') Map<String, LanguageConfig> get languageConfigs {
+  if (_languageConfigs is EqualUnmodifiableMapView) return _languageConfigs;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableMapView(_languageConfigs);
+}
+
+// Keybindings
+@override@JsonKey(name: 'editor_keybinding_preset') final  KeybindingPresetEnum keybindingPreset;
+ final  Map<String, String> _customKeybindings;
+@override@JsonKey(name: 'editor_custom_keybindings') Map<String, String> get customKeybindings {
+  if (_customKeybindings is EqualUnmodifiableMapView) return _customKeybindings;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableMapView(_customKeybindings);
+}
+
+// Advanced
+@override@JsonKey(name: 'editor_read_only') final  bool readOnly;
+@override@JsonKey(name: 'editor_dom_read_only') final  bool domReadOnly;
+@override@JsonKey(name: 'editor_drag_and_drop') final  bool dragAndDrop;
+@override@JsonKey(name: 'editor_links') final  bool links;
+@override@JsonKey(name: 'editor_mouse_wheel_zoom') final  bool mouseWheelZoom;
+@override@JsonKey(name: 'editor_mouse_wheel_scroll_sensitivity') final  double mouseWheelScrollSensitivity;
+@override@JsonKey(name: 'editor_automatic_layout') final  bool automaticLayout;
+ final  Map<String, int> _padding;
+@override@JsonKey(name: 'editor_padding') Map<String, int> get padding {
+  if (_padding is EqualUnmodifiableMapView) return _padding;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableMapView(_padding);
+}
+
+@override@JsonKey(name: 'editor_rounded_selection') final  bool roundedSelection;
+@override@JsonKey(name: 'editor_selection_highlight') final  bool selectionHighlight;
+@override@JsonKey(name: 'editor_occurrences_highlight') final  String occurrencesHighlight;
+@override@JsonKey(name: 'editor_overview_ruler_border') final  bool overviewRulerBorder;
+@override@JsonKey(name: 'editor_hide_cursor_in_overview_ruler') final  bool hideCursorInOverviewRuler;
+ final  Map<String, dynamic> _scrollbar;
+@override@JsonKey(name: 'editor_scrollbar') Map<String, dynamic> get scrollbar {
+  if (_scrollbar is EqualUnmodifiableMapView) return _scrollbar;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableMapView(_scrollbar);
+}
+
+ final  Map<String, dynamic> _experimentalFeatures;
+@override@JsonKey(name: 'editor_experimental_features') Map<String, dynamic> get experimentalFeatures {
+  if (_experimentalFeatures is EqualUnmodifiableMapView) return _experimentalFeatures;
+  // ignore: implicit_dynamic_type
+  return EqualUnmodifiableMapView(_experimentalFeatures);
+}
+
+
+/// Create a copy of EditorSettings
+/// with the given fields replaced by the non-null parameter values.
+@override @JsonKey(includeFromJson: false, includeToJson: false)
+@pragma('vm:prefer-inline')
+_$EditorSettingsCopyWith<_EditorSettings> get copyWith => __$EditorSettingsCopyWithImpl<_EditorSettings>(this, _$identity);
+
+@override
+Map<String, dynamic> toJson() {
+  return _$EditorSettingsToJson(this, );
+}
+
+@override
+bool operator ==(Object other) {
+  return identical(this, other) || (other.runtimeType == runtimeType&&other is _EditorSettings&&(identical(other.theme, theme) || other.theme == theme)&&(identical(other.fontSize, fontSize) || other.fontSize == fontSize)&&(identical(other.fontFamily, fontFamily) || other.fontFamily == fontFamily)&&(identical(other.lineHeight, lineHeight) || other.lineHeight == lineHeight)&&(identical(other.letterSpacing, letterSpacing) || other.letterSpacing == letterSpacing)&&(identical(other.showLineNumbers, showLineNumbers) || other.showLineNumbers == showLineNumbers)&&(identical(other.lineNumbersStyle, lineNumbersStyle) || other.lineNumbersStyle == lineNumbersStyle)&&(identical(other.showMinimap, showMinimap) || other.showMinimap == showMinimap)&&(identical(other.minimapSide, minimapSide) || other.minimapSide == minimapSide)&&(identical(other.minimapRenderCharacters, minimapRenderCharacters) || other.minimapRenderCharacters == minimapRenderCharacters)&&(identical(other.minimapSize, minimapSize) || other.minimapSize == minimapSize)&&(identical(other.showIndentGuides, showIndentGuides) || other.showIndentGuides == showIndentGuides)&&(identical(other.renderWhitespace, renderWhitespace) || other.renderWhitespace == renderWhitespace)&&const DeepCollectionEquality().equals(other._rulers, _rulers)&&(identical(other.stickyScroll, stickyScroll) || other.stickyScroll == stickyScroll)&&(identical(other.showFoldingControls, showFoldingControls) || other.showFoldingControls == showFoldingControls)&&(identical(other.glyphMargin, glyphMargin) || other.glyphMargin == glyphMargin)&&(identical(other.renderLineHighlight, renderLineHighlight) || other.renderLineHighlight == renderLineHighlight)&&(identical(other.wordWrap, wordWrap) || other.wordWrap == wordWrap)&&(identical(other.wordWrapColumn, wordWrapColumn) || other.wordWrapColumn == wordWrapColumn)&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.autoIndent, autoIndent) || other.autoIndent == autoIndent)&&(identical(other.autoClosingBrackets, autoClosingBrackets) || other.autoClosingBrackets == autoClosingBrackets)&&(identical(other.autoClosingQuotes, autoClosingQuotes) || other.autoClosingQuotes == autoClosingQuotes)&&(identical(other.autoSurround, autoSurround) || other.autoSurround == autoSurround)&&(identical(other.bracketPairColorization, bracketPairColorization) || other.bracketPairColorization == bracketPairColorization)&&(identical(other.codeFolding, codeFolding) || other.codeFolding == codeFolding)&&(identical(other.scrollBeyondLastLine, scrollBeyondLastLine) || other.scrollBeyondLastLine == scrollBeyondLastLine)&&(identical(other.smoothScrolling, smoothScrolling) || other.smoothScrolling == smoothScrolling)&&(identical(other.fastScrollSensitivity, fastScrollSensitivity) || other.fastScrollSensitivity == fastScrollSensitivity)&&(identical(other.scrollPredominantAxis, scrollPredominantAxis) || other.scrollPredominantAxis == scrollPredominantAxis)&&(identical(other.cursorBlinking, cursorBlinking) || other.cursorBlinking == cursorBlinking)&&(identical(other.cursorSmoothCaretAnimation, cursorSmoothCaretAnimation) || other.cursorSmoothCaretAnimation == cursorSmoothCaretAnimation)&&(identical(other.cursorStyle, cursorStyle) || other.cursorStyle == cursorStyle)&&(identical(other.cursorWidth, cursorWidth) || other.cursorWidth == cursorWidth)&&(identical(other.multiCursorModifier, multiCursorModifier) || other.multiCursorModifier == multiCursorModifier)&&(identical(other.multiCursorMergeOverlapping, multiCursorMergeOverlapping) || other.multiCursorMergeOverlapping == multiCursorMergeOverlapping)&&(identical(other.formatOnSave, formatOnSave) || other.formatOnSave == formatOnSave)&&(identical(other.formatOnPaste, formatOnPaste) || other.formatOnPaste == formatOnPaste)&&(identical(other.formatOnType, formatOnType) || other.formatOnType == formatOnType)&&(identical(other.quickSuggestions, quickSuggestions) || other.quickSuggestions == quickSuggestions)&&(identical(other.quickSuggestionsDelay, quickSuggestionsDelay) || other.quickSuggestionsDelay == quickSuggestionsDelay)&&(identical(other.suggestOnTriggerCharacters, suggestOnTriggerCharacters) || other.suggestOnTriggerCharacters == suggestOnTriggerCharacters)&&(identical(other.acceptSuggestionOnEnter, acceptSuggestionOnEnter) || other.acceptSuggestionOnEnter == acceptSuggestionOnEnter)&&(identical(other.acceptSuggestionOnCommitCharacter, acceptSuggestionOnCommitCharacter) || other.acceptSuggestionOnCommitCharacter == acceptSuggestionOnCommitCharacter)&&(identical(other.snippetSuggestions, snippetSuggestions) || other.snippetSuggestions == snippetSuggestions)&&(identical(other.wordBasedSuggestions, wordBasedSuggestions) || other.wordBasedSuggestions == wordBasedSuggestions)&&(identical(other.parameterHints, parameterHints) || other.parameterHints == parameterHints)&&(identical(other.hover, hover) || other.hover == hover)&&(identical(other.contextMenu, contextMenu) || other.contextMenu == contextMenu)&&(identical(other.find, find) || other.find == find)&&(identical(other.seedSearchStringFromSelection, seedSearchStringFromSelection) || other.seedSearchStringFromSelection == seedSearchStringFromSelection)&&(identical(other.accessibilitySupport, accessibilitySupport) || other.accessibilitySupport == accessibilitySupport)&&(identical(other.accessibilityPageSize, accessibilityPageSize) || other.accessibilityPageSize == accessibilityPageSize)&&(identical(other.renderValidationDecorations, renderValidationDecorations) || other.renderValidationDecorations == renderValidationDecorations)&&(identical(other.renderControlCharacters, renderControlCharacters) || other.renderControlCharacters == renderControlCharacters)&&(identical(other.disableLayerHinting, disableLayerHinting) || other.disableLayerHinting == disableLayerHinting)&&(identical(other.disableMonospaceOptimizations, disableMonospaceOptimizations) || other.disableMonospaceOptimizations == disableMonospaceOptimizations)&&(identical(other.maxTokenizationLineLength, maxTokenizationLineLength) || other.maxTokenizationLineLength == maxTokenizationLineLength)&&const DeepCollectionEquality().equals(other._languageConfigs, _languageConfigs)&&(identical(other.keybindingPreset, keybindingPreset) || other.keybindingPreset == keybindingPreset)&&const DeepCollectionEquality().equals(other._customKeybindings, _customKeybindings)&&(identical(other.readOnly, readOnly) || other.readOnly == readOnly)&&(identical(other.domReadOnly, domReadOnly) || other.domReadOnly == domReadOnly)&&(identical(other.dragAndDrop, dragAndDrop) || other.dragAndDrop == dragAndDrop)&&(identical(other.links, links) || other.links == links)&&(identical(other.mouseWheelZoom, mouseWheelZoom) || other.mouseWheelZoom == mouseWheelZoom)&&(identical(other.mouseWheelScrollSensitivity, mouseWheelScrollSensitivity) || other.mouseWheelScrollSensitivity == mouseWheelScrollSensitivity)&&(identical(other.automaticLayout, automaticLayout) || other.automaticLayout == automaticLayout)&&const DeepCollectionEquality().equals(other._padding, _padding)&&(identical(other.roundedSelection, roundedSelection) || other.roundedSelection == roundedSelection)&&(identical(other.selectionHighlight, selectionHighlight) || other.selectionHighlight == selectionHighlight)&&(identical(other.occurrencesHighlight, occurrencesHighlight) || other.occurrencesHighlight == occurrencesHighlight)&&(identical(other.overviewRulerBorder, overviewRulerBorder) || other.overviewRulerBorder == overviewRulerBorder)&&(identical(other.hideCursorInOverviewRuler, hideCursorInOverviewRuler) || other.hideCursorInOverviewRuler == hideCursorInOverviewRuler)&&const DeepCollectionEquality().equals(other._scrollbar, _scrollbar)&&const DeepCollectionEquality().equals(other._experimentalFeatures, _experimentalFeatures));
+}
+
+@JsonKey(includeFromJson: false, includeToJson: false)
+@override
+int get hashCode => Object.hashAll([runtimeType,theme,fontSize,fontFamily,lineHeight,letterSpacing,showLineNumbers,lineNumbersStyle,showMinimap,minimapSide,minimapRenderCharacters,minimapSize,showIndentGuides,renderWhitespace,const DeepCollectionEquality().hash(_rulers),stickyScroll,showFoldingControls,glyphMargin,renderLineHighlight,wordWrap,wordWrapColumn,tabSize,insertSpaces,autoIndent,autoClosingBrackets,autoClosingQuotes,autoSurround,bracketPairColorization,codeFolding,scrollBeyondLastLine,smoothScrolling,fastScrollSensitivity,scrollPredominantAxis,cursorBlinking,cursorSmoothCaretAnimation,cursorStyle,cursorWidth,multiCursorModifier,multiCursorMergeOverlapping,formatOnSave,formatOnPaste,formatOnType,quickSuggestions,quickSuggestionsDelay,suggestOnTriggerCharacters,acceptSuggestionOnEnter,acceptSuggestionOnCommitCharacter,snippetSuggestions,wordBasedSuggestions,parameterHints,hover,contextMenu,find,seedSearchStringFromSelection,accessibilitySupport,accessibilityPageSize,renderValidationDecorations,renderControlCharacters,disableLayerHinting,disableMonospaceOptimizations,maxTokenizationLineLength,const DeepCollectionEquality().hash(_languageConfigs),keybindingPreset,const DeepCollectionEquality().hash(_customKeybindings),readOnly,domReadOnly,dragAndDrop,links,mouseWheelZoom,mouseWheelScrollSensitivity,automaticLayout,const DeepCollectionEquality().hash(_padding),roundedSelection,selectionHighlight,occurrencesHighlight,overviewRulerBorder,hideCursorInOverviewRuler,const DeepCollectionEquality().hash(_scrollbar),const DeepCollectionEquality().hash(_experimentalFeatures)]);
+
+@override
+String toString() {
+  return 'EditorSettings(theme: $theme, fontSize: $fontSize, fontFamily: $fontFamily, lineHeight: $lineHeight, letterSpacing: $letterSpacing, showLineNumbers: $showLineNumbers, lineNumbersStyle: $lineNumbersStyle, showMinimap: $showMinimap, minimapSide: $minimapSide, minimapRenderCharacters: $minimapRenderCharacters, minimapSize: $minimapSize, showIndentGuides: $showIndentGuides, renderWhitespace: $renderWhitespace, rulers: $rulers, stickyScroll: $stickyScroll, showFoldingControls: $showFoldingControls, glyphMargin: $glyphMargin, renderLineHighlight: $renderLineHighlight, wordWrap: $wordWrap, wordWrapColumn: $wordWrapColumn, tabSize: $tabSize, insertSpaces: $insertSpaces, autoIndent: $autoIndent, autoClosingBrackets: $autoClosingBrackets, autoClosingQuotes: $autoClosingQuotes, autoSurround: $autoSurround, bracketPairColorization: $bracketPairColorization, codeFolding: $codeFolding, scrollBeyondLastLine: $scrollBeyondLastLine, smoothScrolling: $smoothScrolling, fastScrollSensitivity: $fastScrollSensitivity, scrollPredominantAxis: $scrollPredominantAxis, cursorBlinking: $cursorBlinking, cursorSmoothCaretAnimation: $cursorSmoothCaretAnimation, cursorStyle: $cursorStyle, cursorWidth: $cursorWidth, multiCursorModifier: $multiCursorModifier, multiCursorMergeOverlapping: $multiCursorMergeOverlapping, formatOnSave: $formatOnSave, formatOnPaste: $formatOnPaste, formatOnType: $formatOnType, quickSuggestions: $quickSuggestions, quickSuggestionsDelay: $quickSuggestionsDelay, suggestOnTriggerCharacters: $suggestOnTriggerCharacters, acceptSuggestionOnEnter: $acceptSuggestionOnEnter, acceptSuggestionOnCommitCharacter: $acceptSuggestionOnCommitCharacter, snippetSuggestions: $snippetSuggestions, wordBasedSuggestions: $wordBasedSuggestions, parameterHints: $parameterHints, hover: $hover, contextMenu: $contextMenu, find: $find, seedSearchStringFromSelection: $seedSearchStringFromSelection, accessibilitySupport: $accessibilitySupport, accessibilityPageSize: $accessibilityPageSize, renderValidationDecorations: $renderValidationDecorations, renderControlCharacters: $renderControlCharacters, disableLayerHinting: $disableLayerHinting, disableMonospaceOptimizations: $disableMonospaceOptimizations, maxTokenizationLineLength: $maxTokenizationLineLength, languageConfigs: $languageConfigs, keybindingPreset: $keybindingPreset, customKeybindings: $customKeybindings, readOnly: $readOnly, domReadOnly: $domReadOnly, dragAndDrop: $dragAndDrop, links: $links, mouseWheelZoom: $mouseWheelZoom, mouseWheelScrollSensitivity: $mouseWheelScrollSensitivity, automaticLayout: $automaticLayout, padding: $padding, roundedSelection: $roundedSelection, selectionHighlight: $selectionHighlight, occurrencesHighlight: $occurrencesHighlight, overviewRulerBorder: $overviewRulerBorder, hideCursorInOverviewRuler: $hideCursorInOverviewRuler, scrollbar: $scrollbar, experimentalFeatures: $experimentalFeatures)';
+}
+
+
+}
+
+/// @nodoc
+abstract mixin class _$EditorSettingsCopyWith<$Res> implements $EditorSettingsCopyWith<$Res> {
+  factory _$EditorSettingsCopyWith(_EditorSettings value, $Res Function(_EditorSettings) _then) = __$EditorSettingsCopyWithImpl;
+@override @useResult
+$Res call({
+@JsonKey(name: 'editor_theme') String theme,@JsonKey(name: 'editor_font_size') double fontSize,@JsonKey(name: 'editor_font_family') String fontFamily,@JsonKey(name: 'editor_line_height') double lineHeight,@JsonKey(name: 'editor_letter_spacing') double letterSpacing,@JsonKey(name: 'editor_show_line_numbers') bool showLineNumbers,@JsonKey(name: 'editor_line_numbers_style') LineNumbersStyle lineNumbersStyle,@JsonKey(name: 'editor_show_minimap') bool showMinimap,@JsonKey(name: 'editor_minimap_side') MinimapSide minimapSide,@JsonKey(name: 'editor_minimap_render_characters') bool minimapRenderCharacters,@JsonKey(name: 'editor_minimap_size') int minimapSize,@JsonKey(name: 'editor_show_indent_guides') bool showIndentGuides,@JsonKey(name: 'editor_render_whitespace') RenderWhitespace renderWhitespace,@JsonKey(name: 'editor_rulers') List<int> rulers,@JsonKey(name: 'editor_sticky_scroll') bool stickyScroll,@JsonKey(name: 'editor_show_folding_controls') String showFoldingControls,@JsonKey(name: 'editor_glyph_margin') bool glyphMargin,@JsonKey(name: 'editor_render_line_highlight') String renderLineHighlight,@JsonKey(name: 'editor_word_wrap') WordWrap wordWrap,@JsonKey(name: 'editor_word_wrap_column') int wordWrapColumn,@JsonKey(name: 'editor_tab_size') int tabSize,@JsonKey(name: 'editor_insert_spaces') bool insertSpaces,@JsonKey(name: 'editor_auto_indent') String autoIndent,@JsonKey(name: 'editor_auto_closing_brackets') String autoClosingBrackets,@JsonKey(name: 'editor_auto_closing_quotes') String autoClosingQuotes,@JsonKey(name: 'editor_auto_surround') String autoSurround,@JsonKey(name: 'editor_bracket_pair_colorization') bool bracketPairColorization,@JsonKey(name: 'editor_code_folding') bool codeFolding,@JsonKey(name: 'editor_scroll_beyond_last_line') bool scrollBeyondLastLine,@JsonKey(name: 'editor_smooth_scrolling') bool smoothScrolling,@JsonKey(name: 'editor_fast_scroll_sensitivity') double fastScrollSensitivity,@JsonKey(name: 'editor_scroll_predominant_axis') bool scrollPredominantAxis,@JsonKey(name: 'editor_cursor_blinking') CursorBlinking cursorBlinking,@JsonKey(name: 'editor_cursor_smooth_caret_animation') String cursorSmoothCaretAnimation,@JsonKey(name: 'editor_cursor_style') CursorStyle cursorStyle,@JsonKey(name: 'editor_cursor_width') int cursorWidth,@JsonKey(name: 'editor_multi_cursor_modifier') MultiCursorModifier multiCursorModifier,@JsonKey(name: 'editor_multi_cursor_merge_overlapping') bool multiCursorMergeOverlapping,@JsonKey(name: 'editor_format_on_save') bool formatOnSave,@JsonKey(name: 'editor_format_on_paste') bool formatOnPaste,@JsonKey(name: 'editor_format_on_type') bool formatOnType,@JsonKey(name: 'editor_quick_suggestions') bool quickSuggestions,@JsonKey(name: 'editor_quick_suggestions_delay') int quickSuggestionsDelay,@JsonKey(name: 'editor_suggest_on_trigger_characters') bool suggestOnTriggerCharacters,@JsonKey(name: 'editor_accept_suggestion_on_enter') AcceptSuggestionOnEnter acceptSuggestionOnEnter,@JsonKey(name: 'editor_accept_suggestion_on_commit_character') bool acceptSuggestionOnCommitCharacter,@JsonKey(name: 'editor_snippet_suggestions') SnippetSuggestions snippetSuggestions,@JsonKey(name: 'editor_word_based_suggestions') WordBasedSuggestions wordBasedSuggestions,@JsonKey(name: 'editor_parameter_hints') bool parameterHints,@JsonKey(name: 'editor_hover') bool hover,@JsonKey(name: 'editor_context_menu') bool contextMenu,@JsonKey(name: 'editor_find') bool find,@JsonKey(name: 'editor_seed_search_string_from_selection') String seedSearchStringFromSelection,@JsonKey(name: 'editor_accessibility_support') AccessibilitySupport accessibilitySupport,@JsonKey(name: 'editor_accessibility_page_size') int accessibilityPageSize,@JsonKey(name: 'editor_render_validation_decorations') String renderValidationDecorations,@JsonKey(name: 'editor_render_control_characters') bool renderControlCharacters,@JsonKey(name: 'editor_disable_layer_hinting') bool disableLayerHinting,@JsonKey(name: 'editor_disable_monospace_optimizations') bool disableMonospaceOptimizations,@JsonKey(name: 'editor_max_tokenization_line_length') int maxTokenizationLineLength,@JsonKey(name: 'editor_language_configs') Map<String, LanguageConfig> languageConfigs,@JsonKey(name: 'editor_keybinding_preset') KeybindingPresetEnum keybindingPreset,@JsonKey(name: 'editor_custom_keybindings') Map<String, String> customKeybindings,@JsonKey(name: 'editor_read_only') bool readOnly,@JsonKey(name: 'editor_dom_read_only') bool domReadOnly,@JsonKey(name: 'editor_drag_and_drop') bool dragAndDrop,@JsonKey(name: 'editor_links') bool links,@JsonKey(name: 'editor_mouse_wheel_zoom') bool mouseWheelZoom,@JsonKey(name: 'editor_mouse_wheel_scroll_sensitivity') double mouseWheelScrollSensitivity,@JsonKey(name: 'editor_automatic_layout') bool automaticLayout,@JsonKey(name: 'editor_padding') Map<String, int> padding,@JsonKey(name: 'editor_rounded_selection') bool roundedSelection,@JsonKey(name: 'editor_selection_highlight') bool selectionHighlight,@JsonKey(name: 'editor_occurrences_highlight') String occurrencesHighlight,@JsonKey(name: 'editor_overview_ruler_border') bool overviewRulerBorder,@JsonKey(name: 'editor_hide_cursor_in_overview_ruler') bool hideCursorInOverviewRuler,@JsonKey(name: 'editor_scrollbar') Map<String, dynamic> scrollbar,@JsonKey(name: 'editor_experimental_features') Map<String, dynamic> experimentalFeatures
+});
+
+
+
+
+}
+/// @nodoc
+class __$EditorSettingsCopyWithImpl<$Res>
+    implements _$EditorSettingsCopyWith<$Res> {
+  __$EditorSettingsCopyWithImpl(this._self, this._then);
+
+  final _EditorSettings _self;
+  final $Res Function(_EditorSettings) _then;
+
+/// Create a copy of EditorSettings
+/// with the given fields replaced by the non-null parameter values.
+@override @pragma('vm:prefer-inline') $Res call({Object? theme = null,Object? fontSize = null,Object? fontFamily = null,Object? lineHeight = null,Object? letterSpacing = null,Object? showLineNumbers = null,Object? lineNumbersStyle = null,Object? showMinimap = null,Object? minimapSide = null,Object? minimapRenderCharacters = null,Object? minimapSize = null,Object? showIndentGuides = null,Object? renderWhitespace = null,Object? rulers = null,Object? stickyScroll = null,Object? showFoldingControls = null,Object? glyphMargin = null,Object? renderLineHighlight = null,Object? wordWrap = null,Object? wordWrapColumn = null,Object? tabSize = null,Object? insertSpaces = null,Object? autoIndent = null,Object? autoClosingBrackets = null,Object? autoClosingQuotes = null,Object? autoSurround = null,Object? bracketPairColorization = null,Object? codeFolding = null,Object? scrollBeyondLastLine = null,Object? smoothScrolling = null,Object? fastScrollSensitivity = null,Object? scrollPredominantAxis = null,Object? cursorBlinking = null,Object? cursorSmoothCaretAnimation = null,Object? cursorStyle = null,Object? cursorWidth = null,Object? multiCursorModifier = null,Object? multiCursorMergeOverlapping = null,Object? formatOnSave = null,Object? formatOnPaste = null,Object? formatOnType = null,Object? quickSuggestions = null,Object? quickSuggestionsDelay = null,Object? suggestOnTriggerCharacters = null,Object? acceptSuggestionOnEnter = null,Object? acceptSuggestionOnCommitCharacter = null,Object? snippetSuggestions = null,Object? wordBasedSuggestions = null,Object? parameterHints = null,Object? hover = null,Object? contextMenu = null,Object? find = null,Object? seedSearchStringFromSelection = null,Object? accessibilitySupport = null,Object? accessibilityPageSize = null,Object? renderValidationDecorations = null,Object? renderControlCharacters = null,Object? disableLayerHinting = null,Object? disableMonospaceOptimizations = null,Object? maxTokenizationLineLength = null,Object? languageConfigs = null,Object? keybindingPreset = null,Object? customKeybindings = null,Object? readOnly = null,Object? domReadOnly = null,Object? dragAndDrop = null,Object? links = null,Object? mouseWheelZoom = null,Object? mouseWheelScrollSensitivity = null,Object? automaticLayout = null,Object? padding = null,Object? roundedSelection = null,Object? selectionHighlight = null,Object? occurrencesHighlight = null,Object? overviewRulerBorder = null,Object? hideCursorInOverviewRuler = null,Object? scrollbar = null,Object? experimentalFeatures = null,}) {
+  return _then(_EditorSettings(
+theme: null == theme ? _self.theme : theme // ignore: cast_nullable_to_non_nullable
+as String,fontSize: null == fontSize ? _self.fontSize : fontSize // ignore: cast_nullable_to_non_nullable
+as double,fontFamily: null == fontFamily ? _self.fontFamily : fontFamily // ignore: cast_nullable_to_non_nullable
+as String,lineHeight: null == lineHeight ? _self.lineHeight : lineHeight // ignore: cast_nullable_to_non_nullable
+as double,letterSpacing: null == letterSpacing ? _self.letterSpacing : letterSpacing // ignore: cast_nullable_to_non_nullable
+as double,showLineNumbers: null == showLineNumbers ? _self.showLineNumbers : showLineNumbers // ignore: cast_nullable_to_non_nullable
+as bool,lineNumbersStyle: null == lineNumbersStyle ? _self.lineNumbersStyle : lineNumbersStyle // ignore: cast_nullable_to_non_nullable
+as LineNumbersStyle,showMinimap: null == showMinimap ? _self.showMinimap : showMinimap // ignore: cast_nullable_to_non_nullable
+as bool,minimapSide: null == minimapSide ? _self.minimapSide : minimapSide // ignore: cast_nullable_to_non_nullable
+as MinimapSide,minimapRenderCharacters: null == minimapRenderCharacters ? _self.minimapRenderCharacters : minimapRenderCharacters // ignore: cast_nullable_to_non_nullable
+as bool,minimapSize: null == minimapSize ? _self.minimapSize : minimapSize // ignore: cast_nullable_to_non_nullable
+as int,showIndentGuides: null == showIndentGuides ? _self.showIndentGuides : showIndentGuides // ignore: cast_nullable_to_non_nullable
+as bool,renderWhitespace: null == renderWhitespace ? _self.renderWhitespace : renderWhitespace // ignore: cast_nullable_to_non_nullable
+as RenderWhitespace,rulers: null == rulers ? _self._rulers : rulers // ignore: cast_nullable_to_non_nullable
+as List<int>,stickyScroll: null == stickyScroll ? _self.stickyScroll : stickyScroll // ignore: cast_nullable_to_non_nullable
+as bool,showFoldingControls: null == showFoldingControls ? _self.showFoldingControls : showFoldingControls // ignore: cast_nullable_to_non_nullable
+as String,glyphMargin: null == glyphMargin ? _self.glyphMargin : glyphMargin // ignore: cast_nullable_to_non_nullable
+as bool,renderLineHighlight: null == renderLineHighlight ? _self.renderLineHighlight : renderLineHighlight // ignore: cast_nullable_to_non_nullable
+as String,wordWrap: null == wordWrap ? _self.wordWrap : wordWrap // ignore: cast_nullable_to_non_nullable
+as WordWrap,wordWrapColumn: null == wordWrapColumn ? _self.wordWrapColumn : wordWrapColumn // ignore: cast_nullable_to_non_nullable
+as int,tabSize: null == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
+as int,insertSpaces: null == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
+as bool,autoIndent: null == autoIndent ? _self.autoIndent : autoIndent // ignore: cast_nullable_to_non_nullable
+as String,autoClosingBrackets: null == autoClosingBrackets ? _self.autoClosingBrackets : autoClosingBrackets // ignore: cast_nullable_to_non_nullable
+as String,autoClosingQuotes: null == autoClosingQuotes ? _self.autoClosingQuotes : autoClosingQuotes // ignore: cast_nullable_to_non_nullable
+as String,autoSurround: null == autoSurround ? _self.autoSurround : autoSurround // ignore: cast_nullable_to_non_nullable
+as String,bracketPairColorization: null == bracketPairColorization ? _self.bracketPairColorization : bracketPairColorization // ignore: cast_nullable_to_non_nullable
+as bool,codeFolding: null == codeFolding ? _self.codeFolding : codeFolding // ignore: cast_nullable_to_non_nullable
+as bool,scrollBeyondLastLine: null == scrollBeyondLastLine ? _self.scrollBeyondLastLine : scrollBeyondLastLine // ignore: cast_nullable_to_non_nullable
+as bool,smoothScrolling: null == smoothScrolling ? _self.smoothScrolling : smoothScrolling // ignore: cast_nullable_to_non_nullable
+as bool,fastScrollSensitivity: null == fastScrollSensitivity ? _self.fastScrollSensitivity : fastScrollSensitivity // ignore: cast_nullable_to_non_nullable
+as double,scrollPredominantAxis: null == scrollPredominantAxis ? _self.scrollPredominantAxis : scrollPredominantAxis // ignore: cast_nullable_to_non_nullable
+as bool,cursorBlinking: null == cursorBlinking ? _self.cursorBlinking : cursorBlinking // ignore: cast_nullable_to_non_nullable
+as CursorBlinking,cursorSmoothCaretAnimation: null == cursorSmoothCaretAnimation ? _self.cursorSmoothCaretAnimation : cursorSmoothCaretAnimation // ignore: cast_nullable_to_non_nullable
+as String,cursorStyle: null == cursorStyle ? _self.cursorStyle : cursorStyle // ignore: cast_nullable_to_non_nullable
+as CursorStyle,cursorWidth: null == cursorWidth ? _self.cursorWidth : cursorWidth // ignore: cast_nullable_to_non_nullable
+as int,multiCursorModifier: null == multiCursorModifier ? _self.multiCursorModifier : multiCursorModifier // ignore: cast_nullable_to_non_nullable
+as MultiCursorModifier,multiCursorMergeOverlapping: null == multiCursorMergeOverlapping ? _self.multiCursorMergeOverlapping : multiCursorMergeOverlapping // ignore: cast_nullable_to_non_nullable
+as bool,formatOnSave: null == formatOnSave ? _self.formatOnSave : formatOnSave // ignore: cast_nullable_to_non_nullable
+as bool,formatOnPaste: null == formatOnPaste ? _self.formatOnPaste : formatOnPaste // ignore: cast_nullable_to_non_nullable
+as bool,formatOnType: null == formatOnType ? _self.formatOnType : formatOnType // ignore: cast_nullable_to_non_nullable
+as bool,quickSuggestions: null == quickSuggestions ? _self.quickSuggestions : quickSuggestions // ignore: cast_nullable_to_non_nullable
+as bool,quickSuggestionsDelay: null == quickSuggestionsDelay ? _self.quickSuggestionsDelay : quickSuggestionsDelay // ignore: cast_nullable_to_non_nullable
+as int,suggestOnTriggerCharacters: null == suggestOnTriggerCharacters ? _self.suggestOnTriggerCharacters : suggestOnTriggerCharacters // ignore: cast_nullable_to_non_nullable
+as bool,acceptSuggestionOnEnter: null == acceptSuggestionOnEnter ? _self.acceptSuggestionOnEnter : acceptSuggestionOnEnter // ignore: cast_nullable_to_non_nullable
+as AcceptSuggestionOnEnter,acceptSuggestionOnCommitCharacter: null == acceptSuggestionOnCommitCharacter ? _self.acceptSuggestionOnCommitCharacter : acceptSuggestionOnCommitCharacter // ignore: cast_nullable_to_non_nullable
+as bool,snippetSuggestions: null == snippetSuggestions ? _self.snippetSuggestions : snippetSuggestions // ignore: cast_nullable_to_non_nullable
+as SnippetSuggestions,wordBasedSuggestions: null == wordBasedSuggestions ? _self.wordBasedSuggestions : wordBasedSuggestions // ignore: cast_nullable_to_non_nullable
+as WordBasedSuggestions,parameterHints: null == parameterHints ? _self.parameterHints : parameterHints // ignore: cast_nullable_to_non_nullable
+as bool,hover: null == hover ? _self.hover : hover // ignore: cast_nullable_to_non_nullable
+as bool,contextMenu: null == contextMenu ? _self.contextMenu : contextMenu // ignore: cast_nullable_to_non_nullable
+as bool,find: null == find ? _self.find : find // ignore: cast_nullable_to_non_nullable
+as bool,seedSearchStringFromSelection: null == seedSearchStringFromSelection ? _self.seedSearchStringFromSelection : seedSearchStringFromSelection // ignore: cast_nullable_to_non_nullable
+as String,accessibilitySupport: null == accessibilitySupport ? _self.accessibilitySupport : accessibilitySupport // ignore: cast_nullable_to_non_nullable
+as AccessibilitySupport,accessibilityPageSize: null == accessibilityPageSize ? _self.accessibilityPageSize : accessibilityPageSize // ignore: cast_nullable_to_non_nullable
+as int,renderValidationDecorations: null == renderValidationDecorations ? _self.renderValidationDecorations : renderValidationDecorations // ignore: cast_nullable_to_non_nullable
+as String,renderControlCharacters: null == renderControlCharacters ? _self.renderControlCharacters : renderControlCharacters // ignore: cast_nullable_to_non_nullable
+as bool,disableLayerHinting: null == disableLayerHinting ? _self.disableLayerHinting : disableLayerHinting // ignore: cast_nullable_to_non_nullable
+as bool,disableMonospaceOptimizations: null == disableMonospaceOptimizations ? _self.disableMonospaceOptimizations : disableMonospaceOptimizations // ignore: cast_nullable_to_non_nullable
+as bool,maxTokenizationLineLength: null == maxTokenizationLineLength ? _self.maxTokenizationLineLength : maxTokenizationLineLength // ignore: cast_nullable_to_non_nullable
+as int,languageConfigs: null == languageConfigs ? _self._languageConfigs : languageConfigs // ignore: cast_nullable_to_non_nullable
+as Map<String, LanguageConfig>,keybindingPreset: null == keybindingPreset ? _self.keybindingPreset : keybindingPreset // ignore: cast_nullable_to_non_nullable
+as KeybindingPresetEnum,customKeybindings: null == customKeybindings ? _self._customKeybindings : customKeybindings // ignore: cast_nullable_to_non_nullable
+as Map<String, String>,readOnly: null == readOnly ? _self.readOnly : readOnly // ignore: cast_nullable_to_non_nullable
+as bool,domReadOnly: null == domReadOnly ? _self.domReadOnly : domReadOnly // ignore: cast_nullable_to_non_nullable
+as bool,dragAndDrop: null == dragAndDrop ? _self.dragAndDrop : dragAndDrop // ignore: cast_nullable_to_non_nullable
+as bool,links: null == links ? _self.links : links // ignore: cast_nullable_to_non_nullable
+as bool,mouseWheelZoom: null == mouseWheelZoom ? _self.mouseWheelZoom : mouseWheelZoom // ignore: cast_nullable_to_non_nullable
+as bool,mouseWheelScrollSensitivity: null == mouseWheelScrollSensitivity ? _self.mouseWheelScrollSensitivity : mouseWheelScrollSensitivity // ignore: cast_nullable_to_non_nullable
+as double,automaticLayout: null == automaticLayout ? _self.automaticLayout : automaticLayout // ignore: cast_nullable_to_non_nullable
+as bool,padding: null == padding ? _self._padding : padding // ignore: cast_nullable_to_non_nullable
+as Map<String, int>,roundedSelection: null == roundedSelection ? _self.roundedSelection : roundedSelection // ignore: cast_nullable_to_non_nullable
+as bool,selectionHighlight: null == selectionHighlight ? _self.selectionHighlight : selectionHighlight // ignore: cast_nullable_to_non_nullable
+as bool,occurrencesHighlight: null == occurrencesHighlight ? _self.occurrencesHighlight : occurrencesHighlight // ignore: cast_nullable_to_non_nullable
+as String,overviewRulerBorder: null == overviewRulerBorder ? _self.overviewRulerBorder : overviewRulerBorder // ignore: cast_nullable_to_non_nullable
+as bool,hideCursorInOverviewRuler: null == hideCursorInOverviewRuler ? _self.hideCursorInOverviewRuler : hideCursorInOverviewRuler // ignore: cast_nullable_to_non_nullable
+as bool,scrollbar: null == scrollbar ? _self._scrollbar : scrollbar // ignore: cast_nullable_to_non_nullable
+as Map<String, dynamic>,experimentalFeatures: null == experimentalFeatures ? _self._experimentalFeatures : experimentalFeatures // ignore: cast_nullable_to_non_nullable
+as Map<String, dynamic>,
+  ));
+}
+
+
+}
+
+// dart format on
diff --git a/lib/src/features/editor/core/model/editor_settings.g.dart b/lib/src/features/editor/core/model/editor_settings.g.dart
new file mode 100644
index 0000000..a643bc5
--- /dev/null
+++ b/lib/src/features/editor/core/model/editor_settings.g.dart
@@ -0,0 +1,407 @@
+// GENERATED CODE - DO NOT MODIFY BY HAND
+
+part of 'editor_settings.dart';
+
+// **************************************************************************
+// JsonSerializableGenerator
+// **************************************************************************
+
+_LanguageConfig _$LanguageConfigFromJson(Map<String, dynamic> json) =>
+    _LanguageConfig(
+      tabSize: (json['tabSize'] as num?)?.toInt(),
+      insertSpaces: json['insertSpaces'] as bool?,
+      wordWrap: $enumDecodeNullable(_$WordWrapEnumMap, json['wordWrap']),
+      rulers:
+          (json['rulers'] as List<dynamic>?)
+              ?.map((e) => (e as num).toInt())
+              .toList() ??
+          const [],
+      formatOnSave: json['formatOnSave'] as bool?,
+      formatOnPaste: json['formatOnPaste'] as bool?,
+      formatOnType: json['formatOnType'] as bool?,
+      autoClosingBrackets: json['autoClosingBrackets'] as String?,
+      autoClosingQuotes: json['autoClosingQuotes'] as String?,
+      bracketPairColorization: json['bracketPairColorization'] as bool?,
+      customTheme: json['customTheme'] as Map<String, dynamic>?,
+    );
+
+Map<String, dynamic> _$LanguageConfigToJson(_LanguageConfig instance) =>
+    <String, dynamic>{
+      'tabSize': instance.tabSize,
+      'insertSpaces': instance.insertSpaces,
+      'wordWrap': _$WordWrapEnumMap[instance.wordWrap],
+      'rulers': instance.rulers,
+      'formatOnSave': instance.formatOnSave,
+      'formatOnPaste': instance.formatOnPaste,
+      'formatOnType': instance.formatOnType,
+      'autoClosingBrackets': instance.autoClosingBrackets,
+      'autoClosingQuotes': instance.autoClosingQuotes,
+      'bracketPairColorization': instance.bracketPairColorization,
+      'customTheme': instance.customTheme,
+    };
+
+const Map<WordWrap, String> _$WordWrapEnumMap = {
+  WordWrap.off: 'off',
+  WordWrap.on: 'on',
+  WordWrap.wordWrapColumn: 'wordWrapColumn',
+  WordWrap.bounded: 'bounded',
+};
+
+_EditorSettings _$EditorSettingsFromJson(
+  Map<String, dynamic> json,
+) => _EditorSettings(
+  theme: json['editor_theme'] as String? ?? 'vs-dark',
+  fontSize: (json['editor_font_size'] as num?)?.toDouble() ?? 14,
+  fontFamily:
+      json['editor_font_family'] as String? ??
+      'JetBrains Mono, SF Mono, Menlo, Consolas, "Courier New", monospace',
+  lineHeight: (json['editor_line_height'] as num?)?.toDouble() ?? 1.4,
+  letterSpacing: (json['editor_letter_spacing'] as num?)?.toDouble() ?? 0,
+  showLineNumbers: json['editor_show_line_numbers'] as bool? ?? true,
+  lineNumbersStyle:
+      $enumDecodeNullable(
+        _$LineNumbersStyleEnumMap,
+        json['editor_line_numbers_style'],
+      ) ??
+      LineNumbersStyle.on,
+  showMinimap: json['editor_show_minimap'] as bool? ?? false,
+  minimapSide:
+      $enumDecodeNullable(_$MinimapSideEnumMap, json['editor_minimap_side']) ??
+      MinimapSide.right,
+  minimapRenderCharacters:
+      json['editor_minimap_render_characters'] as bool? ?? false,
+  minimapSize: (json['editor_minimap_size'] as num?)?.toInt() ?? 1,
+  showIndentGuides: json['editor_show_indent_guides'] as bool? ?? true,
+  renderWhitespace:
+      $enumDecodeNullable(
+        _$RenderWhitespaceEnumMap,
+        json['editor_render_whitespace'],
+      ) ??
+      RenderWhitespace.selection,
+  rulers:
+      (json['editor_rulers'] as List<dynamic>?)
+          ?.map((e) => (e as num).toInt())
+          .toList() ??
+      const [],
+  stickyScroll: json['editor_sticky_scroll'] as bool? ?? false,
+  showFoldingControls:
+      json['editor_show_folding_controls'] as String? ?? 'mouseover',
+  glyphMargin: json['editor_glyph_margin'] as bool? ?? true,
+  renderLineHighlight:
+      json['editor_render_line_highlight'] as String? ?? 'line',
+  wordWrap:
+      $enumDecodeNullable(_$WordWrapEnumMap, json['editor_word_wrap']) ??
+      WordWrap.on,
+  wordWrapColumn: (json['editor_word_wrap_column'] as num?)?.toInt() ?? 80,
+  tabSize: (json['editor_tab_size'] as num?)?.toInt() ?? 4,
+  insertSpaces: json['editor_insert_spaces'] as bool? ?? true,
+  autoIndent: json['editor_auto_indent'] as String? ?? 'advanced',
+  autoClosingBrackets:
+      json['editor_auto_closing_brackets'] as String? ?? 'languageDefined',
+  autoClosingQuotes:
+      json['editor_auto_closing_quotes'] as String? ?? 'languageDefined',
+  autoSurround: json['editor_auto_surround'] as String? ?? 'languageDefined',
+  bracketPairColorization:
+      json['editor_bracket_pair_colorization'] as bool? ?? true,
+  codeFolding: json['editor_code_folding'] as bool? ?? true,
+  scrollBeyondLastLine: json['editor_scroll_beyond_last_line'] as bool? ?? true,
+  smoothScrolling: json['editor_smooth_scrolling'] as bool? ?? false,
+  fastScrollSensitivity:
+      (json['editor_fast_scroll_sensitivity'] as num?)?.toDouble() ?? 5,
+  scrollPredominantAxis:
+      json['editor_scroll_predominant_axis'] as bool? ?? true,
+  cursorBlinking:
+      $enumDecodeNullable(
+        _$CursorBlinkingEnumMap,
+        json['editor_cursor_blinking'],
+      ) ??
+      CursorBlinking.blink,
+  cursorSmoothCaretAnimation:
+      json['editor_cursor_smooth_caret_animation'] as String? ?? 'off',
+  cursorStyle:
+      $enumDecodeNullable(_$CursorStyleEnumMap, json['editor_cursor_style']) ??
+      CursorStyle.line,
+  cursorWidth: (json['editor_cursor_width'] as num?)?.toInt() ?? 0,
+  multiCursorModifier:
+      $enumDecodeNullable(
+        _$MultiCursorModifierEnumMap,
+        json['editor_multi_cursor_modifier'],
+      ) ??
+      MultiCursorModifier.ctrlCmd,
+  multiCursorMergeOverlapping:
+      json['editor_multi_cursor_merge_overlapping'] as bool? ?? true,
+  formatOnSave: json['editor_format_on_save'] as bool? ?? false,
+  formatOnPaste: json['editor_format_on_paste'] as bool? ?? false,
+  formatOnType: json['editor_format_on_type'] as bool? ?? false,
+  quickSuggestions: json['editor_quick_suggestions'] as bool? ?? true,
+  quickSuggestionsDelay:
+      (json['editor_quick_suggestions_delay'] as num?)?.toInt() ?? 10,
+  suggestOnTriggerCharacters:
+      json['editor_suggest_on_trigger_characters'] as bool? ?? true,
+  acceptSuggestionOnEnter:
+      $enumDecodeNullable(
+        _$AcceptSuggestionOnEnterEnumMap,
+        json['editor_accept_suggestion_on_enter'],
+      ) ??
+      AcceptSuggestionOnEnter.on,
+  acceptSuggestionOnCommitCharacter:
+      json['editor_accept_suggestion_on_commit_character'] as bool? ?? true,
+  snippetSuggestions:
+      $enumDecodeNullable(
+        _$SnippetSuggestionsEnumMap,
+        json['editor_snippet_suggestions'],
+      ) ??
+      SnippetSuggestions.inline,
+  wordBasedSuggestions:
+      $enumDecodeNullable(
+        _$WordBasedSuggestionsEnumMap,
+        json['editor_word_based_suggestions'],
+      ) ??
+      WordBasedSuggestions.currentDocument,
+  parameterHints: json['editor_parameter_hints'] as bool? ?? true,
+  hover: json['editor_hover'] as bool? ?? true,
+  contextMenu: json['editor_context_menu'] as bool? ?? true,
+  find: json['editor_find'] as bool? ?? true,
+  seedSearchStringFromSelection:
+      json['editor_seed_search_string_from_selection'] as String? ??
+      'selection',
+  accessibilitySupport:
+      $enumDecodeNullable(
+        _$AccessibilitySupportEnumMap,
+        json['editor_accessibility_support'],
+      ) ??
+      AccessibilitySupport.auto,
+  accessibilityPageSize:
+      (json['editor_accessibility_page_size'] as num?)?.toInt() ?? 10,
+  renderValidationDecorations:
+      json['editor_render_validation_decorations'] as String? ?? 'editable',
+  renderControlCharacters:
+      json['editor_render_control_characters'] as bool? ?? false,
+  disableLayerHinting: json['editor_disable_layer_hinting'] as bool? ?? false,
+  disableMonospaceOptimizations:
+      json['editor_disable_monospace_optimizations'] as bool? ?? false,
+  maxTokenizationLineLength:
+      (json['editor_max_tokenization_line_length'] as num?)?.toInt() ?? 20000,
+  languageConfigs:
+      (json['editor_language_configs'] as Map<String, dynamic>?)?.map(
+        (k, e) =>
+            MapEntry(k, LanguageConfig.fromJson(e as Map<String, dynamic>)),
+      ) ??
+      const {},
+  keybindingPreset:
+      $enumDecodeNullable(
+        _$KeybindingPresetEnumEnumMap,
+        json['editor_keybinding_preset'],
+      ) ??
+      KeybindingPresetEnum.vscode,
+  customKeybindings:
+      (json['editor_custom_keybindings'] as Map<String, dynamic>?)?.map(
+        (k, e) => MapEntry(k, e as String),
+      ) ??
+      const {},
+  readOnly: json['editor_read_only'] as bool? ?? false,
+  domReadOnly: json['editor_dom_read_only'] as bool? ?? false,
+  dragAndDrop: json['editor_drag_and_drop'] as bool? ?? true,
+  links: json['editor_links'] as bool? ?? true,
+  mouseWheelZoom: json['editor_mouse_wheel_zoom'] as bool? ?? false,
+  mouseWheelScrollSensitivity:
+      (json['editor_mouse_wheel_scroll_sensitivity'] as num?)?.toDouble() ?? 1,
+  automaticLayout: json['editor_automatic_layout'] as bool? ?? true,
+  padding:
+      (json['editor_padding'] as Map<String, dynamic>?)?.map(
+        (k, e) => MapEntry(k, (e as num).toInt()),
+      ) ??
+      const {'top': 10, 'bottom': 10, 'start': 10, 'end': 10},
+  roundedSelection: json['editor_rounded_selection'] as bool? ?? true,
+  selectionHighlight: json['editor_selection_highlight'] as bool? ?? true,
+  occurrencesHighlight:
+      json['editor_occurrences_highlight'] as String? ?? 'singleFile',
+  overviewRulerBorder: json['editor_overview_ruler_border'] as bool? ?? true,
+  hideCursorInOverviewRuler:
+      json['editor_hide_cursor_in_overview_ruler'] as bool? ?? false,
+  scrollbar:
+      json['editor_scrollbar'] as Map<String, dynamic>? ??
+      const {
+        'vertical': 'auto',
+        'horizontal': 'auto',
+        'arrowSize': 11,
+        'useShadows': true,
+        'verticalScrollbarSize': 14,
+        'horizontalScrollbarSize': 10,
+        'scrollByPage': false,
+      },
+  experimentalFeatures:
+      json['editor_experimental_features'] as Map<String, dynamic>? ?? const {},
+);
+
+Map<String, dynamic> _$EditorSettingsToJson(
+  _EditorSettings instance,
+) => <String, dynamic>{
+  'editor_theme': instance.theme,
+  'editor_font_size': instance.fontSize,
+  'editor_font_family': instance.fontFamily,
+  'editor_line_height': instance.lineHeight,
+  'editor_letter_spacing': instance.letterSpacing,
+  'editor_show_line_numbers': instance.showLineNumbers,
+  'editor_line_numbers_style':
+      _$LineNumbersStyleEnumMap[instance.lineNumbersStyle],
+  'editor_show_minimap': instance.showMinimap,
+  'editor_minimap_side': _$MinimapSideEnumMap[instance.minimapSide],
+  'editor_minimap_render_characters': instance.minimapRenderCharacters,
+  'editor_minimap_size': instance.minimapSize,
+  'editor_show_indent_guides': instance.showIndentGuides,
+  'editor_render_whitespace':
+      _$RenderWhitespaceEnumMap[instance.renderWhitespace],
+  'editor_rulers': instance.rulers,
+  'editor_sticky_scroll': instance.stickyScroll,
+  'editor_show_folding_controls': instance.showFoldingControls,
+  'editor_glyph_margin': instance.glyphMargin,
+  'editor_render_line_highlight': instance.renderLineHighlight,
+  'editor_word_wrap': _$WordWrapEnumMap[instance.wordWrap],
+  'editor_word_wrap_column': instance.wordWrapColumn,
+  'editor_tab_size': instance.tabSize,
+  'editor_insert_spaces': instance.insertSpaces,
+  'editor_auto_indent': instance.autoIndent,
+  'editor_auto_closing_brackets': instance.autoClosingBrackets,
+  'editor_auto_closing_quotes': instance.autoClosingQuotes,
+  'editor_auto_surround': instance.autoSurround,
+  'editor_bracket_pair_colorization': instance.bracketPairColorization,
+  'editor_code_folding': instance.codeFolding,
+  'editor_scroll_beyond_last_line': instance.scrollBeyondLastLine,
+  'editor_smooth_scrolling': instance.smoothScrolling,
+  'editor_fast_scroll_sensitivity': instance.fastScrollSensitivity,
+  'editor_scroll_predominant_axis': instance.scrollPredominantAxis,
+  'editor_cursor_blinking': _$CursorBlinkingEnumMap[instance.cursorBlinking],
+  'editor_cursor_smooth_caret_animation': instance.cursorSmoothCaretAnimation,
+  'editor_cursor_style': _$CursorStyleEnumMap[instance.cursorStyle],
+  'editor_cursor_width': instance.cursorWidth,
+  'editor_multi_cursor_modifier':
+      _$MultiCursorModifierEnumMap[instance.multiCursorModifier],
+  'editor_multi_cursor_merge_overlapping': instance.multiCursorMergeOverlapping,
+  'editor_format_on_save': instance.formatOnSave,
+  'editor_format_on_paste': instance.formatOnPaste,
+  'editor_format_on_type': instance.formatOnType,
+  'editor_quick_suggestions': instance.quickSuggestions,
+  'editor_quick_suggestions_delay': instance.quickSuggestionsDelay,
+  'editor_suggest_on_trigger_characters': instance.suggestOnTriggerCharacters,
+  'editor_accept_suggestion_on_enter':
+      _$AcceptSuggestionOnEnterEnumMap[instance.acceptSuggestionOnEnter],
+  'editor_accept_suggestion_on_commit_character':
+      instance.acceptSuggestionOnCommitCharacter,
+  'editor_snippet_suggestions':
+      _$SnippetSuggestionsEnumMap[instance.snippetSuggestions],
+  'editor_word_based_suggestions':
+      _$WordBasedSuggestionsEnumMap[instance.wordBasedSuggestions],
+  'editor_parameter_hints': instance.parameterHints,
+  'editor_hover': instance.hover,
+  'editor_context_menu': instance.contextMenu,
+  'editor_find': instance.find,
+  'editor_seed_search_string_from_selection':
+      instance.seedSearchStringFromSelection,
+  'editor_accessibility_support':
+      _$AccessibilitySupportEnumMap[instance.accessibilitySupport],
+  'editor_accessibility_page_size': instance.accessibilityPageSize,
+  'editor_render_validation_decorations': instance.renderValidationDecorations,
+  'editor_render_control_characters': instance.renderControlCharacters,
+  'editor_disable_layer_hinting': instance.disableLayerHinting,
+  'editor_disable_monospace_optimizations':
+      instance.disableMonospaceOptimizations,
+  'editor_max_tokenization_line_length': instance.maxTokenizationLineLength,
+  'editor_language_configs': instance.languageConfigs.map(
+    (k, e) => MapEntry(k, e.toJson()),
+  ),
+  'editor_keybinding_preset':
+      _$KeybindingPresetEnumEnumMap[instance.keybindingPreset],
+  'editor_custom_keybindings': instance.customKeybindings,
+  'editor_read_only': instance.readOnly,
+  'editor_dom_read_only': instance.domReadOnly,
+  'editor_drag_and_drop': instance.dragAndDrop,
+  'editor_links': instance.links,
+  'editor_mouse_wheel_zoom': instance.mouseWheelZoom,
+  'editor_mouse_wheel_scroll_sensitivity': instance.mouseWheelScrollSensitivity,
+  'editor_automatic_layout': instance.automaticLayout,
+  'editor_padding': instance.padding,
+  'editor_rounded_selection': instance.roundedSelection,
+  'editor_selection_highlight': instance.selectionHighlight,
+  'editor_occurrences_highlight': instance.occurrencesHighlight,
+  'editor_overview_ruler_border': instance.overviewRulerBorder,
+  'editor_hide_cursor_in_overview_ruler': instance.hideCursorInOverviewRuler,
+  'editor_scrollbar': instance.scrollbar,
+  'editor_experimental_features': instance.experimentalFeatures,
+};
+
+const Map<LineNumbersStyle, String> _$LineNumbersStyleEnumMap = {
+  LineNumbersStyle.off: 'off',
+  LineNumbersStyle.on: 'on',
+  LineNumbersStyle.relative: 'relative',
+  LineNumbersStyle.interval: 'interval',
+};
+
+const Map<MinimapSide, String> _$MinimapSideEnumMap = {
+  MinimapSide.left: 'left',
+  MinimapSide.right: 'right',
+};
+
+const Map<RenderWhitespace, String> _$RenderWhitespaceEnumMap = {
+  RenderWhitespace.none: 'none',
+  RenderWhitespace.boundary: 'boundary',
+  RenderWhitespace.selection: 'selection',
+  RenderWhitespace.trailing: 'trailing',
+  RenderWhitespace.all: 'all',
+};
+
+const Map<CursorBlinking, String> _$CursorBlinkingEnumMap = {
+  CursorBlinking.blink: 'blink',
+  CursorBlinking.smooth: 'smooth',
+  CursorBlinking.phase: 'phase',
+  CursorBlinking.expand: 'expand',
+  CursorBlinking.solid: 'solid',
+};
+
+const Map<CursorStyle, String> _$CursorStyleEnumMap = {
+  CursorStyle.line: 'line',
+  CursorStyle.block: 'block',
+  CursorStyle.underline: 'underline',
+  CursorStyle.lineThin: 'lineThin',
+  CursorStyle.blockOutline: 'blockOutline',
+  CursorStyle.underlineThin: 'underlineThin',
+};
+
+const Map<MultiCursorModifier, String> _$MultiCursorModifierEnumMap = {
+  MultiCursorModifier.ctrlCmd: 'ctrlCmd',
+  MultiCursorModifier.alt: 'alt',
+};
+
+const Map<AcceptSuggestionOnEnter, String> _$AcceptSuggestionOnEnterEnumMap = {
+  AcceptSuggestionOnEnter.on: 'on',
+  AcceptSuggestionOnEnter.off: 'off',
+  AcceptSuggestionOnEnter.smart: 'smart',
+};
+
+const Map<SnippetSuggestions, String> _$SnippetSuggestionsEnumMap = {
+  SnippetSuggestions.top: 'top',
+  SnippetSuggestions.bottom: 'bottom',
+  SnippetSuggestions.inline: 'inline',
+  SnippetSuggestions.none: 'none',
+};
+
+const Map<WordBasedSuggestions, String> _$WordBasedSuggestionsEnumMap = {
+  WordBasedSuggestions.off: 'off',
+  WordBasedSuggestions.currentDocument: 'currentDocument',
+  WordBasedSuggestions.matchingDocuments: 'matchingDocuments',
+  WordBasedSuggestions.allDocuments: 'allDocuments',
+};
+
+const Map<AccessibilitySupport, String> _$AccessibilitySupportEnumMap = {
+  AccessibilitySupport.auto: 'auto',
+  AccessibilitySupport.off: 'off',
+  AccessibilitySupport.on: 'on',
+};
+
+const Map<KeybindingPresetEnum, String> _$KeybindingPresetEnumEnumMap = {
+  KeybindingPresetEnum.vscode: 'vscode',
+  KeybindingPresetEnum.intellij: 'intellij',
+  KeybindingPresetEnum.vim: 'vim',
+  KeybindingPresetEnum.emacs: 'emacs',
+  KeybindingPresetEnum.custom: 'custom',
+};
diff --git a/lib/src/features/editor/domain/keybinding_manager.dart b/lib/src/features/editor/core/model/keybinding_manager.dart
similarity index 97%
rename from lib/src/features/editor/domain/keybinding_manager.dart
rename to lib/src/features/editor/core/model/keybinding_manager.dart
index bd55e1f..a2dfad4 100644
--- a/lib/src/features/editor/domain/keybinding_manager.dart
+++ b/lib/src/features/editor/core/model/keybinding_manager.dart
@@ -170,9 +170,9 @@ class KeybindingPreset {
   /// Find keybinding by ID
   Keybinding? findKeybindingById(String id) {
     return keybindings.cast<Keybinding?>().firstWhere(
-          (kb) => kb?.id == id,
-          orElse: () => null,
-        );
+      (kb) => kb?.id == id,
+      orElse: () => null,
+    );
   }
 
   /// Convert to JSON
@@ -674,11 +674,11 @@ class KeybindingManager {
 
   /// Get all built-in presets
   static List<KeybindingPreset> get builtInPresets => [
-        vsCodePreset,
-        intellijPreset,
-        vimPreset,
-        emacsPreset,
-      ];
+    vsCodePreset,
+    intellijPreset,
+    vimPreset,
+    emacsPreset,
+  ];
 
   /// Get all available presets
   static List<KeybindingPreset> getAllPresets({
@@ -692,12 +692,12 @@ class KeybindingManager {
     String id, {
     List<KeybindingPreset> customPresets = const [],
   }) {
-    return getAllPresets(customPresets: customPresets)
-        .cast<KeybindingPreset?>()
-        .firstWhere(
-          (preset) => preset?.id == id,
-          orElse: () => null,
-        );
+    return getAllPresets(
+      customPresets: customPresets,
+    ).cast<KeybindingPreset?>().firstWhere(
+      (preset) => preset?.id == id,
+      orElse: () => null,
+    );
   }
 
   /// Get keybindings by category across all presets
@@ -768,12 +768,14 @@ class KeybindingManager {
       'name': preset.name,
       'description': preset.description,
       'keybindings': preset.keybindings
-          .map((kb) => {
-                'key': kb.key,
-                'command': kb.command,
-                'when': kb.when,
-                'args': kb.args,
-              })
+          .map(
+            (kb) => {
+              'key': kb.key,
+              'command': kb.command,
+              'when': kb.when,
+              'args': kb.args,
+            },
+          )
           .toList(),
     };
   }
diff --git a/lib/src/features/editor/domain/theme_manager.dart b/lib/src/features/editor/core/model/theme_manager.dart
similarity index 90%
rename from lib/src/features/editor/domain/theme_manager.dart
rename to lib/src/features/editor/core/model/theme_manager.dart
index 1b99f40..aa3704c 100644
--- a/lib/src/features/editor/domain/theme_manager.dart
+++ b/lib/src/features/editor/core/model/theme_manager.dart
@@ -36,10 +36,12 @@ class EditorTheme {
       base: json.getString('base', defaultValue: 'vs-dark'),
       inherit: json.getBool('inherit', defaultValue: true),
       colors: json.getMap('colors', defaultValue: {}).cast<String, String>(),
-      rules:
-          json.getList('rules', defaultValue: []).cast<Map<String, dynamic>>(),
-      encodedTokensColors:
-          json.getList('encodedTokensColors', defaultValue: []).cast<String>(),
+      rules: json
+          .getList('rules', defaultValue: [])
+          .cast<Map<String, dynamic>>(),
+      encodedTokensColors: json
+          .getList('encodedTokensColors', defaultValue: [])
+          .cast<String>(),
       isBuiltIn: json.getBool('isBuiltIn', defaultValue: false),
       isCustom: json.getBool('isCustom', defaultValue: false),
     );
@@ -190,9 +192,9 @@ class ThemeManager {
     ThemeCategory category, {
     List<EditorTheme> customThemes = const [],
   }) {
-    return getAllThemes(customThemes: customThemes)
-        .where((theme) => theme.category == category)
-        .toList();
+    return getAllThemes(
+      customThemes: customThemes,
+    ).where((theme) => theme.category == category).toList();
   }
 
   /// Find theme by ID
@@ -200,12 +202,12 @@ class ThemeManager {
     String id, {
     List<EditorTheme> customThemes = const [],
   }) {
-    return getAllThemes(customThemes: customThemes)
-        .cast<EditorTheme?>()
-        .firstWhere(
-          (theme) => theme?.id == id,
-          orElse: () => null,
-        );
+    return getAllThemes(
+      customThemes: customThemes,
+    ).cast<EditorTheme?>().firstWhere(
+      (theme) => theme?.id == id,
+      orElse: () => null,
+    );
   }
 
   /// Get default theme for category
@@ -251,20 +253,23 @@ class ThemeManager {
       base: base,
       colors: (vscodeTheme.tryGetMap('colors') ?? {}).cast<String, String>(),
       rules: _convertVSCodeTokenColors(
-          vscodeTheme.tryGetList('tokenColors') ?? []),
+        vscodeTheme.tryGetList('tokenColors') ?? [],
+      ),
       isCustom: true,
     );
   }
 
   /// Convert VS Code token colors to Monaco rules
   static List<Map<String, dynamic>> _convertVSCodeTokenColors(
-      List<dynamic> tokenColors) {
+    List<dynamic> tokenColors,
+  ) {
     final rules = <Map<String, dynamic>>[];
 
     for (final tokenColor in tokenColors) {
       if (tokenColor is! Map<String, dynamic>) continue;
 
-      final scope = tokenColor.tryGetString('scope') ??
+      final scope =
+          tokenColor.tryGetString('scope') ??
           tokenColor.tryGetList<String>('scope')?.first;
       final settings = tokenColor.tryGetMap('settings');
 
@@ -305,13 +310,17 @@ class ThemeManager {
   static Map<String, String> getThemePreviewColors(EditorTheme theme) {
     final colors = theme.colors;
     return {
-      'background': colors['editor.background'] ??
+      'background':
+          colors['editor.background'] ??
           (theme.base == 'vs' ? '#ffffff' : '#1e1e1e'),
-      'foreground': colors['editor.foreground'] ??
+      'foreground':
+          colors['editor.foreground'] ??
           (theme.base == 'vs' ? '#000000' : '#d4d4d4'),
-      'selection': colors['editor.selectionBackground'] ??
+      'selection':
+          colors['editor.selectionBackground'] ??
           (theme.base == 'vs' ? '#add6ff' : '#264f78'),
-      'lineNumber': colors['editorLineNumber.foreground'] ??
+      'lineNumber':
+          colors['editorLineNumber.foreground'] ??
           (theme.base == 'vs' ? '#237893' : '#858585'),
       'accent':
           colors['focusBorder'] ?? (theme.base == 'vs' ? '#005fb8' : '#007acc'),
diff --git a/lib/src/features/editor/core/scripts/monaco_scripts.dart b/lib/src/features/editor/core/scripts/monaco_scripts.dart
new file mode 100644
index 0000000..ef00e6e
--- /dev/null
+++ b/lib/src/features/editor/core/scripts/monaco_scripts.dart
@@ -0,0 +1,108 @@
+enum MonacoActions {
+  format('editor.action.formatDocument'),
+  find('actions.find'),
+  replace('editor.action.startFindReplaceAction'),
+  gotoLine('editor.action.gotoLine'),
+  toggleWordWrap('editor.action.toggleWordWrap'),
+  toggleMinimap('editor.action.toggleMinimap'),
+  toggleLineComment('editor.action.commentLine'),
+  toggleBlockComment('editor.action.blockComment'),
+  triggerSuggest('editor.action.triggerSuggest'),
+  showCommandPalette('editor.action.quickCommand'),
+  foldAll('editor.foldAll'),
+  unfoldAll('editor.unfoldAll'),
+  selectAll('editor.action.selectAll'),
+  undo('undo'),
+  redo('redo'),
+  cut('editor.action.clipboardCutAction'),
+  copy('editor.action.clipboardCopyAction'),
+  paste('editor.action.clipboardPasteAction'),
+  increaseFontSize('editor.action.fontZoomIn'),
+  decreaseFontSize('editor.action.fontZoomOut'),
+  resetFontSize('editor.action.fontZoomReset');
+
+  const MonacoActions(this.command);
+
+  final String command;
+}
+
+/// Monaco editor JavaScript scripts used in the editor feature
+class MonacoScripts {
+  // Private constructor to prevent instantiation
+  MonacoScripts._();
+
+  /// Script to inject live statistics monitoring
+  static const String liveStatsMonitoring = '''
+    console.log('[Stats Script] Injecting live stats monitoring');
+    if (window.__liveStatsHooked) {
+      console.log('[Stats Script] Already hooked');
+    } else {
+      window.__liveStatsHooked = true;
+      if (window.editor) {
+        const sendStats = () => {
+          const model = window.editor.getModel();
+          const selection = window.editor.getSelection();
+          const selections = window.editor.getSelections() || [];
+          
+          if (!model || !selection) return;
+          
+          const stats = {
+            event: 'stats',
+            lineCount: model.getLineCount(),
+            charCount: model.getValueLength(),
+            selLines: selection.isEmpty() ? 0 : selection.endLineNumber - selection.startLineNumber + 1,
+            selChars: selection.isEmpty() ? 0 : model.getValueInRange(selection).length,
+            caretCount: selections.length
+          };
+          
+          if (window.flutterChannel && window.flutterChannel.postMessage) {
+            window.flutterChannel.postMessage(JSON.stringify(stats));
+          }
+        };
+        
+        window.editor.onDidChangeModelContent(sendStats);
+        window.editor.onDidChangeCursorSelection(sendStats);
+        sendStats(); // Initial call
+      }
+    }
+  ''';
+
+  /// Script to scroll to bottom of editor
+  static const String scrollToBottomScript = '''
+    if (window.editor && window.editor.getModel()) {
+      const lineCount = window.editor.getModel().getLineCount();
+      window.editor.revealLineInCenterIfOutsideViewport(lineCount);
+      window.editor.setPosition({ lineNumber: lineCount, column: 1 });
+    }
+  ''';
+
+  /// Script to scroll to top of editor
+  static const String scrollToTopScript = '''
+    if (window.editor) {
+      window.editor.setScrollPosition({ scrollTop: 0, scrollLeft: 0 });
+      window.editor.setPosition({ lineNumber: 1, column: 1 });
+      window.editor.revealLineInCenterIfOutsideViewport(1);
+    }
+  ''';
+
+  /// Script to go to a specific line
+  static String goToLineScript(int line) =>
+      'if (window.editor) { window.editor.revealLineInCenter($line); window.editor.setPosition({ lineNumber: $line, column: 1 }); }';
+
+  /// Script to create flutterChannel for Windows WebView2
+  static const String windowsFlutterChannelScript = '''
+    // Create flutterChannel immediately when document is created
+    console.log('[Windows Init] Creating flutterChannel on document creation');
+    window.flutterChannel = {
+      postMessage: function(msg) {
+        console.log('[flutterChannel] Posting message:', msg);
+        if (window.chrome && window.chrome.webview) {
+          window.chrome.webview.postMessage(msg);
+        } else {
+          console.error('[flutterChannel] WebView2 API not available!');
+        }
+      }
+    };
+    console.log('[Windows Init] flutterChannel created successfully');
+  ''';
+}
diff --git a/lib/src/features/editor/data/monaco_asset_manager.dart b/lib/src/features/editor/data/monaco_asset_manager.dart
new file mode 100644
index 0000000..69267e9
--- /dev/null
+++ b/lib/src/features/editor/data/monaco_asset_manager.dart
@@ -0,0 +1,206 @@
+import 'dart:io';
+
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:path/path.dart' as p;
+import 'package:path_provider/path_provider.dart';
+
+/// Monaco asset manager - Single source of truth for all Monaco-related assets
+class MonacoAssetManager {
+  static const String _assetBaseDir = 'assets/monaco';
+  static const String _cacheSubDir = 'monaco_editor_cache';
+  static const String _htmlFileName = 'index.html';
+  static const String _relativePath = 'monaco-editor/min/vs';
+
+  /// Get the Monaco assets directory, copying if necessary
+  static Future<String> getAssetsDirectory() async {
+    final targetDir = p.join(
+      (await getApplicationSupportDirectory()).path,
+      _cacheSubDir,
+    );
+
+    // Check if Monaco is already extracted by looking for a key file
+    final loaderFile = File(
+      p.join(targetDir, 'monaco-editor', 'min', 'vs', 'loader.js'),
+    );
+
+    if (!loaderFile.existsSync()) {
+      debugPrint('[MonacoAssetManager] Monaco not found, copying assets...');
+      await _copyAllAssets(targetDir);
+    } else {
+      debugPrint(
+        '[MonacoAssetManager] Monaco already extracted at: $targetDir',
+      );
+    }
+
+    // Ensure HTML file is always up to date
+    await _ensureHtmlFile(targetDir);
+
+    return targetDir;
+  }
+
+  /// Get the path to the HTML file
+  static Future<String> getHtmlFilePath() async {
+    final targetDir = await getAssetsDirectory();
+    return p.join(targetDir, _htmlFileName);
+  }
+
+  /// Ensure the HTML file exists and is up to date
+  static Future<void> _ensureHtmlFile(String targetDir) async {
+    final htmlFile = File(p.join(targetDir, _htmlFileName));
+
+    // Generate platform-specific HTML
+    String htmlContent;
+
+    if (Platform.isWindows) {
+      // Windows needs absolute paths since we load from file://
+      final vsPath = p.join(targetDir, 'monaco-editor', 'min', 'vs');
+      final absoluteVsPath = Uri.file(vsPath).toString();
+      htmlContent = EditorConstants.indexHtmlContent(absoluteVsPath);
+
+      // Add Windows-specific flutter channel script
+      const channelScript =
+          '''
+<script>
+${MonacoScripts.windowsFlutterChannelScript}
+</script>
+''';
+      htmlContent = htmlContent.replaceFirst(
+        '<head>',
+        '<head>\n$channelScript',
+      );
+    } else {
+      // macOS uses relative paths since HTML is in the same directory
+      htmlContent = EditorConstants.indexHtmlContent(_relativePath);
+    }
+
+    // Always write/overwrite to ensure it's current with any EditorConstants changes
+    await htmlFile.writeAsString(htmlContent);
+
+    debugPrint('[MonacoAssetManager] HTML file updated at: ${htmlFile.path}');
+  }
+
+  /// Copy all Monaco assets to the target directory
+  static Future<void> _copyAllAssets(String targetDir) async {
+    final stopwatch = Stopwatch()..start();
+
+    // Clean and create target directory
+    final directory = Directory(targetDir);
+    if (directory.existsSync()) {
+      await directory.delete(recursive: true);
+    }
+    await directory.create(recursive: true);
+
+    // Get all assets from the manifest
+    final manifest = await AssetManifest.loadFromAssetBundle(rootBundle);
+    final monacoAssets = manifest
+        .listAssets()
+        .where((key) => key.startsWith(_assetBaseDir))
+        .toList();
+
+    debugPrint(
+      '[MonacoAssetManager] Found ${monacoAssets.length} Monaco assets to copy',
+    );
+
+    // Copy each asset maintaining directory structure
+    var copiedCount = 0;
+    for (final assetKey in monacoAssets) {
+      try {
+        // Calculate relative path (skip index.html from assets if it exists)
+        final relativePath = assetKey.substring('$_assetBaseDir/'.length);
+        if (relativePath.isEmpty || relativePath == _htmlFileName) continue;
+
+        // Create target file path
+        final targetFile = File(p.join(targetDir, relativePath));
+
+        // Ensure parent directory exists
+        await targetFile.parent.create(recursive: true);
+
+        // Load and write asset
+        final bytes = await rootBundle.load(assetKey);
+        await targetFile.writeAsBytes(bytes.buffer.asUint8List());
+
+        copiedCount++;
+
+        // Log progress every 100 files
+        if (copiedCount % 100 == 0) {
+          debugPrint(
+            '[MonacoAssetManager] Progress: $copiedCount/${monacoAssets.length} files copied',
+          );
+        }
+      } catch (e) {
+        debugPrint(
+          '[MonacoAssetManager] Error copying $assetKey: $e',
+        );
+      }
+    }
+
+    stopwatch.stop();
+    debugPrint(
+      '[MonacoAssetManager] Completed: $copiedCount files copied in ${stopwatch.elapsedMilliseconds}ms',
+    );
+  }
+
+  /// Clean up all Monaco assets including HTML
+  static Future<void> cleanAssets() async {
+    final targetDir = p.join(
+      (await getApplicationSupportDirectory()).path,
+      _cacheSubDir,
+    );
+
+    final directory = Directory(targetDir);
+    if (directory.existsSync()) {
+      await directory.delete(recursive: true);
+      debugPrint('[MonacoAssetManager] Monaco assets cleaned');
+    }
+  }
+
+  /// Get information about extracted Monaco assets
+  static Future<Map<String, dynamic>> getAssetInfo() async {
+    final targetDir = p.join(
+      (await getApplicationSupportDirectory()).path,
+      _cacheSubDir,
+    );
+
+    final directory = Directory(targetDir);
+    if (!directory.existsSync()) {
+      return {
+        'exists': false,
+        'path': targetDir,
+      };
+    }
+
+    // Count files and calculate size
+    var fileCount = 0;
+    var totalSize = 0;
+    var hasHtmlFile = false;
+
+    await for (final entity in directory.list(recursive: true)) {
+      if (entity is File) {
+        fileCount++;
+        totalSize += await entity.length();
+
+        if (p.basename(entity.path) == _htmlFileName) {
+          hasHtmlFile = true;
+        }
+      }
+    }
+
+    return {
+      'exists': true,
+      'path': targetDir,
+      'fileCount': fileCount,
+      'totalSize': totalSize,
+      'totalSizeMB': (totalSize / 1024 / 1024).toStringAsFixed(2),
+      'hasHtmlFile': hasHtmlFile,
+      'htmlPath': p.join(targetDir, _htmlFileName),
+    };
+  }
+
+  /// Force refresh of HTML file (useful if EditorConstants change)
+  static Future<void> refreshHtmlFile() async {
+    final targetDir = await getAssetsDirectory();
+    await _ensureHtmlFile(targetDir);
+  }
+}
diff --git a/lib/src/features/editor/data/monaco_service.dart b/lib/src/features/editor/data/monaco_service.dart
new file mode 100644
index 0000000..5a64ecf
--- /dev/null
+++ b/lib/src/features/editor/data/monaco_service.dart
@@ -0,0 +1,304 @@
+import 'dart:async';
+import 'dart:io';
+
+import 'package:context_collector/context_collector.dart';
+import 'package:context_collector/src/features/editor/data/monaco_asset_manager.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:webview_flutter/webview_flutter.dart' as wf;
+import 'package:webview_windows/webview_windows.dart' as ww;
+
+// --- State Definitions ---
+enum EditorLifecycle {
+  initial,
+  loadingAssets,
+  loadingSettings,
+  initializingWebview,
+  ready,
+  error,
+}
+
+@immutable
+class EditorStatus {
+  const EditorStatus({
+    this.lifecycle = EditorLifecycle.initial,
+    this.message = 'Initializing...',
+    this.error,
+    this.hasContent = false,
+  });
+
+  final EditorLifecycle lifecycle;
+  final String message;
+  final String? error;
+  final bool hasContent;
+
+  EditorStatus copyWith({
+    EditorLifecycle? lifecycle,
+    String? message,
+    String? error,
+    bool? hasContent,
+  }) {
+    return EditorStatus(
+      lifecycle: lifecycle ?? this.lifecycle,
+      message: message ?? this.message,
+      error: error ?? this.error,
+      hasContent: hasContent ?? this.hasContent,
+    );
+  }
+
+  bool get isReady => lifecycle == EditorLifecycle.ready;
+
+  bool get isLoading => !isReady && lifecycle != EditorLifecycle.error;
+
+  bool get hasError => lifecycle == EditorLifecycle.error;
+}
+
+// --- THE MONACO SERVICE ---
+class MonacoService extends StateNotifier<EditorStatus> {
+  MonacoService()
+    : super(const EditorStatus(lifecycle: EditorLifecycle.initial));
+
+  final MonacoBridgePlatform bridge = MonacoBridgePlatform();
+  PlatformWebViewController? _webViewController;
+
+  String? _assetPath;
+  bool _isDisposed = false;
+  String? _queuedContent;
+
+  /// Returns the platform-specific WebView widget
+  Widget get webviewWidget {
+    if (state.isLoading || _webViewController == null) {
+      return const Center(child: CircularProgressIndicator());
+    }
+
+    if (Platform.isWindows) {
+      return ww.Webview(
+        (_webViewController! as WindowsWebViewController).windowsController,
+      );
+    } else {
+      return wf.WebViewWidget(
+        controller:
+            (_webViewController! as FlutterWebViewController).flutterController,
+      );
+    }
+  }
+
+  /// Initialize the Monaco editor
+  Future<void> initialize() async {
+    // Prevent re-initialization unless in initial or error state
+    if (state.lifecycle != EditorLifecycle.initial &&
+        state.lifecycle != EditorLifecycle.error) {
+      return;
+    }
+
+    debugPrint('[MonacoService] Full initialization sequence started...');
+
+    try {
+      // Step 1: Load Monaco assets
+      await _loadAssets();
+      if (_isDisposed) return;
+
+      // Step 2: Load editor settings
+      await _loadSettings();
+      if (_isDisposed) return;
+
+      // Step 3: Initialize WebView
+      await _initializeWebView();
+      if (_isDisposed) return;
+
+      // Step 4: Wait for editor ready signal
+      await _waitForEditorReady();
+      if (_isDisposed) return;
+
+      // Step 5: Apply initial configuration
+      await _applyInitialConfiguration();
+
+      state = state.copyWith(
+        lifecycle: EditorLifecycle.ready,
+        message: 'Editor is ready',
+      );
+      debugPrint('[MonacoService] Initialization successful.');
+    } catch (e, st) {
+      if (_isDisposed) return;
+      _handleError(e, st);
+    }
+  }
+
+  /// Update editor content
+  Future<void> updateContent(String content, {String? language}) async {
+    if (!state.isReady) {
+      debugPrint('[MonacoService] Editor not ready. Queuing content.');
+      _queuedContent = content;
+      return;
+    }
+
+    await bridge.setContent(content);
+    if (language != null) {
+      await bridge.setLanguage(language);
+    }
+
+    if (mounted) {
+      state = state.copyWith(hasContent: content.isNotEmpty);
+    }
+  }
+
+  /// Update editor settings
+  Future<void> updateSettings(EditorSettings settings) async {
+    if (!state.isReady) return;
+    await bridge.updateSettings(settings);
+  }
+
+  // --- Private Methods ---
+
+  Future<void> _loadAssets() async {
+    state = state.copyWith(
+      lifecycle: EditorLifecycle.loadingAssets,
+      message: 'Preparing assets...',
+      error: null,
+    );
+
+    // MonacoAssetManager now handles everything: copying assets AND creating HTML
+    _assetPath = await MonacoAssetManager.getAssetsDirectory();
+    debugPrint('[MonacoService] Assets ready at: $_assetPath');
+  }
+
+  Future<void> _loadSettings() async {
+    state = state.copyWith(
+      lifecycle: EditorLifecycle.loadingSettings,
+      message: 'Loading settings...',
+    );
+
+    // Settings are loaded but applied after editor is ready
+    await EditorSettingsServiceHelper.load();
+    debugPrint('[MonacoService] Settings loaded.');
+  }
+
+  Future<void> _initializeWebView() async {
+    state = state.copyWith(
+      lifecycle: EditorLifecycle.initializingWebview,
+      message: 'Starting editor...',
+    );
+
+    // Create platform-specific controller
+    _webViewController ??= PlatformWebViewFactory.createController();
+    bridge.attachWebView(_webViewController!);
+
+    // Platform-specific initialization
+    if (Platform.isWindows) {
+      await _initializeWindowsWebView();
+    } else {
+      await _initializeMacOSWebView();
+    }
+
+    debugPrint('[MonacoService] WebView initialized and content loading.');
+  }
+
+  Future<void> _initializeWindowsWebView() async {
+    final controller = _webViewController! as WindowsWebViewController;
+
+    // Initialize WebView2
+    await controller.initialize();
+
+    // Set up JavaScript channel
+    await controller.addJavaScriptChannel(
+      'flutterChannel',
+      bridge.handleJavaScriptMessage,
+    );
+
+    // FIXED: Use file-based loading for Windows too!
+    // Get HTML file path from MonacoAssetManager (same as macOS)
+    final htmlFilePath = await MonacoAssetManager.getHtmlFilePath();
+
+    debugPrint('[MonacoService] Loading HTML from file: $htmlFilePath');
+
+    // Load from file URL
+    final htmlUri = Uri.file(htmlFilePath);
+    await controller.loadUrl(htmlUri.toString());
+  }
+
+  Future<void> _initializeMacOSWebView() async {
+    final controller = _webViewController! as FlutterWebViewController;
+
+    // Configure WebView
+    await controller.setJavaScriptMode();
+    await controller.addJavaScriptChannel(
+      'flutterChannel',
+      bridge.handleJavaScriptMessage,
+    );
+
+    // Set up console logging for debugging
+    await controller.setOnConsoleMessage((message) {
+      debugPrint(
+        '[Monaco Console] ${message.level.name}: ${message.message}',
+      );
+    });
+
+    // Set navigation delegates
+    controller.setNavigationDelegate(
+      wf.NavigationDelegate(
+        onPageFinished: (url) {
+          debugPrint('[MonacoService] WebView Page Finished: $url');
+        },
+        onWebResourceError: (error) {
+          debugPrint(
+            '[MonacoService] WebView Error: ${error.description} on ${error.url}',
+          );
+        },
+      ),
+    );
+
+    // Get HTML file path from MonacoAssetManager (single source of truth)
+    final htmlFilePath = await MonacoAssetManager.getHtmlFilePath();
+
+    debugPrint('[MonacoService] Loading HTML from: $htmlFilePath');
+    await controller.flutterController.loadFile(htmlFilePath);
+  }
+
+  Future<void> _waitForEditorReady() async {
+    debugPrint('[MonacoService] Waiting for onReady event from JS...');
+
+    await bridge.onReady.future.timeout(
+      const Duration(seconds: 20),
+      onTimeout: () => throw TimeoutException(
+        'Monaco Editor did not report back as ready in 20 seconds.',
+      ),
+    );
+
+    debugPrint('[MonacoService] onReady event received!');
+  }
+
+  Future<void> _applyInitialConfiguration() async {
+    // Apply settings
+    final settings = await EditorSettingsServiceHelper.load();
+    await bridge.updateSettings(settings);
+    debugPrint('[MonacoService] Initial settings applied.');
+
+    // Apply queued content if any
+    if (_queuedContent != null) {
+      debugPrint('[MonacoService] Applying queued content...');
+      await bridge.setContent(_queuedContent!);
+      state = state.copyWith(hasContent: _queuedContent!.isNotEmpty);
+      _queuedContent = null;
+    } else {
+      await bridge.setContent('');
+    }
+  }
+
+  void _handleError(dynamic error, StackTrace stackTrace) {
+    state = state.copyWith(
+      lifecycle: EditorLifecycle.error,
+      error: error.toString(),
+    );
+    debugPrint(
+      '[MonacoService] Fatal error during initialization: $error\n$stackTrace',
+    );
+  }
+
+  @override
+  void dispose() {
+    _isDisposed = true;
+    bridge.dispose();
+    _webViewController?.dispose();
+    super.dispose();
+  }
+}
diff --git a/lib/src/features/editor/data/providers.dart b/lib/src/features/editor/data/providers.dart
new file mode 100644
index 0000000..e97fb96
--- /dev/null
+++ b/lib/src/features/editor/data/providers.dart
@@ -0,0 +1,44 @@
+// Monaco Editor Providers
+import 'package:ai_token_calculator/ai_token_calculator.dart';
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+import 'monaco_asset_manager.dart';
+
+// --- RIVERPOD PROVIDERS ---
+final monacoProvider = StateNotifierProvider<MonacoService, EditorStatus>((
+  ref,
+) {
+  final service = MonacoService();
+  ref.onDispose(service.dispose);
+  return service;
+});
+
+final monacoReadyProvider = Provider<bool>(
+  (ref) => ref.watch(monacoProvider).isReady,
+);
+final StateNotifierProvider<MonacoService, EditorStatus>
+monacoEditorStatusProvider = monacoProvider;
+final Refreshable<MonacoService> monacoEditorServiceProvider =
+    monacoProvider.notifier;
+
+/// Convenient provider for checking if editor is ready
+final monacoEditorReadyProvider = Provider<bool>((ref) {
+  final status = ref.watch(monacoEditorStatusProvider);
+  return status.isReady;
+});
+
+/// Provider for AI token calculator
+final tokenCalculatorProvider = Provider<AITokenCalculator>(
+  (ref) => AITokenCalculator(),
+);
+
+/// Provider for selected AI model (persisted in session)
+final selectedAIModelProvider = StateProvider<AIModel>((ref) {
+  return AIModel.claudeSonnet; // Default to Claude for Context Collector
+});
+
+/// Provider for Monaco asset manager info
+final monacoAssetInfoProvider = FutureProvider<Map<String, dynamic>>((ref) {
+  return MonacoAssetManager.getAssetInfo();
+});
diff --git a/lib/src/features/editor/data/settings_service.dart b/lib/src/features/editor/data/settings_service.dart
new file mode 100644
index 0000000..9163d21
--- /dev/null
+++ b/lib/src/features/editor/data/settings_service.dart
@@ -0,0 +1,41 @@
+import 'package:dart_helper_utils/dart_helper_utils.dart';
+import 'package:shared_preferences/shared_preferences.dart';
+
+import '../core/model/editor_settings.dart';
+
+/// Service responsible for persisting and loading editor settings
+class EditorSettingsServiceHelper {
+  static const String _storageKey = 'editor_settings';
+
+  /// Save settings to SharedPreferences as a single JSON string
+  static Future<void> save(EditorSettings settings) async {
+    final prefs = await SharedPreferences.getInstance();
+    final json = settings.toJson();
+    await prefs.setString(_storageKey, json.encode());
+  }
+
+  /// Load settings from SharedPreferences
+  static Future<EditorSettings> load() async {
+    final prefs = await SharedPreferences.getInstance();
+    final jsonString = prefs.getString(_storageKey);
+
+    if (jsonString == null) {
+      return const EditorSettings();
+    }
+
+    try {
+      final json = jsonString.decode();
+      final jsonMap = ConvertObject.toMap<String, dynamic>(json);
+      return EditorSettings.fromJson(jsonMap);
+    } catch (e) {
+      // If parsing fails, return default settings
+      return const EditorSettings();
+    }
+  }
+
+  /// Clear all saved settings
+  static Future<bool> clear() async {
+    final prefs = await SharedPreferences.getInstance();
+    return prefs.remove(_storageKey);
+  }
+}
diff --git a/lib/src/features/editor/domain/editor_settings.dart b/lib/src/features/editor/domain/editor_settings.dart
deleted file mode 100644
index e27c3f0..0000000
--- a/lib/src/features/editor/domain/editor_settings.dart
+++ /dev/null
@@ -1,1517 +0,0 @@
-import 'package:dart_helper_utils/dart_helper_utils.dart';
-import 'package:equatable/equatable.dart';
-import 'package:flutter/foundation.dart';
-import 'package:shared_preferences/shared_preferences.dart';
-
-/// Enums for better type safety
-enum WordWrap {
-  off,
-  on,
-  wordWrapColumn,
-  bounded;
-
-  bool get enabled => this != WordWrap.off;
-}
-
-enum LineNumbersStyle { off, on, relative, interval }
-
-enum MinimapSide { left, right }
-
-enum RenderWhitespace { none, boundary, selection, trailing, all }
-
-enum CursorBlinking { blink, smooth, phase, expand, solid }
-
-enum CursorStyle {
-  line,
-  block,
-  underline,
-  lineThin,
-  blockOutline,
-  underlineThin
-}
-
-enum MultiCursorModifier { ctrlCmd, alt }
-
-enum AcceptSuggestionOnEnter { on, off, smart }
-
-enum SnippetSuggestions { top, bottom, inline, none }
-
-enum WordBasedSuggestions {
-  off,
-  currentDocument,
-  matchingDocuments,
-  allDocuments
-}
-
-enum AccessibilitySupport { auto, off, on }
-
-enum KeybindingPresetEnum {
-  vscode,
-  intellij,
-  vim,
-  emacs,
-  custom;
-
-  // Map your enum values to Monaco keybinding presets
-  String get monacoPreset => switch (this) {
-        KeybindingPresetEnum.vscode => 'vscode',
-        KeybindingPresetEnum.intellij => 'intellij',
-        KeybindingPresetEnum.vim => 'vim',
-        KeybindingPresetEnum.emacs => 'emacs',
-        KeybindingPresetEnum.custom => 'custom',
-      };
-}
-
-/// Language-specific configuration
-class LanguageConfig {
-  const LanguageConfig({
-    this.tabSize,
-    this.insertSpaces,
-    this.wordWrap,
-    this.rulers,
-    this.formatOnSave,
-    this.formatOnPaste,
-    this.formatOnType,
-    this.autoClosingBrackets,
-    this.autoClosingQuotes,
-    this.bracketPairColorization,
-    this.customTheme,
-  });
-
-  factory LanguageConfig.fromJson(Map<String, dynamic> json) => LanguageConfig(
-        tabSize: json.tryGetInt('tabSize'),
-        insertSpaces: json.tryGetBool('insertSpaces'),
-        wordWrap: json.tryGetString('wordWrap')?.let((w) => WordWrap.values
-            .firstWhere((e) => e.name == w, orElse: () => WordWrap.off)),
-        rulers: json.tryGetList<int>('rulers'),
-        formatOnSave: json.tryGetBool('formatOnSave'),
-        formatOnPaste: json.tryGetBool('formatOnPaste'),
-        formatOnType: json.tryGetBool('formatOnType'),
-        autoClosingBrackets: json.tryGetString('autoClosingBrackets'),
-        autoClosingQuotes: json.tryGetString('autoClosingQuotes'),
-        bracketPairColorization: json.tryGetBool('bracketPairColorization'),
-        customTheme: json.tryGetMap('customTheme'),
-      );
-
-  final int? tabSize;
-  final bool? insertSpaces;
-  final WordWrap? wordWrap;
-  final List<int>? rulers;
-  final bool? formatOnSave;
-  final bool? formatOnPaste;
-  final bool? formatOnType;
-  final String?
-      autoClosingBrackets; // 'always', 'languageDefined', 'beforeWhitespace', 'never'
-  final String?
-      autoClosingQuotes; // 'always', 'languageDefined', 'beforeWhitespace', 'never'
-  final bool? bracketPairColorization;
-  final Map<String, dynamic>? customTheme;
-
-  Map<String, dynamic> toJson() => {
-        if (tabSize != null) 'tabSize': tabSize,
-        if (insertSpaces != null) 'insertSpaces': insertSpaces,
-        if (wordWrap != null) 'wordWrap': wordWrap!.name,
-        if (rulers != null) 'rulers': rulers,
-        if (formatOnSave != null) 'formatOnSave': formatOnSave,
-        if (formatOnPaste != null) 'formatOnPaste': formatOnPaste,
-        if (formatOnType != null) 'formatOnType': formatOnType,
-        if (autoClosingBrackets != null)
-          'autoClosingBrackets': autoClosingBrackets,
-        if (autoClosingQuotes != null) 'autoClosingQuotes': autoClosingQuotes,
-        if (bracketPairColorization != null)
-          'bracketPairColorization': bracketPairColorization,
-        if (customTheme != null) 'customTheme': customTheme,
-      };
-
-  LanguageConfig copyWith({
-    int? tabSize,
-    bool? insertSpaces,
-    WordWrap? wordWrap,
-    List<int>? rulers,
-    bool? formatOnSave,
-    bool? formatOnPaste,
-    bool? formatOnType,
-    String? autoClosingBrackets,
-    String? autoClosingQuotes,
-    bool? bracketPairColorization,
-    Map<String, dynamic>? customTheme,
-  }) =>
-      LanguageConfig(
-        tabSize: tabSize ?? this.tabSize,
-        insertSpaces: insertSpaces ?? this.insertSpaces,
-        wordWrap: wordWrap ?? this.wordWrap,
-        rulers: rulers ?? this.rulers,
-        formatOnSave: formatOnSave ?? this.formatOnSave,
-        formatOnPaste: formatOnPaste ?? this.formatOnPaste,
-        formatOnType: formatOnType ?? this.formatOnType,
-        autoClosingBrackets: autoClosingBrackets ?? this.autoClosingBrackets,
-        autoClosingQuotes: autoClosingQuotes ?? this.autoClosingQuotes,
-        bracketPairColorization:
-            bracketPairColorization ?? this.bracketPairColorization,
-        customTheme: customTheme ?? this.customTheme,
-      );
-}
-
-/// Enhanced Editor configuration settings with comprehensive options
-@immutable
-class EditorSettings extends Equatable {
-  const EditorSettings({
-    // General Settings
-    this.theme = defaultTheme,
-    this.fontSize = defaultFontSize,
-    this.fontFamily = defaultFontFamily,
-    this.lineHeight = defaultLineHeight,
-    this.letterSpacing = defaultLetterSpacing,
-
-    // Display Settings
-    this.showLineNumbers = defaultShowLineNumbers,
-    this.lineNumbersStyle = defaultLineNumbersStyle,
-    this.showMinimap = defaultShowMinimap,
-    this.minimapSide = defaultMinimapSide,
-    this.minimapRenderCharacters = defaultMinimapRenderCharacters,
-    this.minimapSize = defaultMinimapSize,
-    this.showIndentGuides = defaultShowIndentGuides,
-    this.renderWhitespace = defaultRenderWhitespace,
-    this.rulers = defaultRulers,
-    this.stickyScroll = defaultStickyScroll,
-    this.showFoldingControls = defaultShowFoldingControls,
-    this.glyphMargin = defaultGlyphMargin,
-    this.renderLineHighlight = defaultRenderLineHighlight,
-
-    // Editor Behavior
-    this.wordWrap = defaultWordWrap,
-    this.wordWrapColumn = defaultWordWrapColumn,
-    this.tabSize = defaultTabSize,
-    this.insertSpaces = defaultInsertSpaces,
-    this.autoIndent = defaultAutoIndent,
-    this.autoClosingBrackets = defaultAutoClosingBrackets,
-    this.autoClosingQuotes = defaultAutoClosingQuotes,
-    this.autoSurround = defaultAutoSurround,
-    this.bracketPairColorization = defaultBracketPairColorization,
-    this.codeFolding = defaultCodeFolding,
-    this.scrollBeyondLastLine = defaultScrollBeyondLastLine,
-    this.smoothScrolling = defaultSmoothScrolling,
-    this.fastScrollSensitivity = defaultFastScrollSensitivity,
-    this.scrollPredominantAxis = defaultScrollPredominantAxis,
-
-    // Cursor Settings
-    this.cursorBlinking = defaultCursorBlinking,
-    this.cursorSmoothCaretAnimation = defaultCursorSmoothCaretAnimation,
-    this.cursorStyle = defaultCursorStyle,
-    this.cursorWidth = defaultCursorWidth,
-    this.multiCursorModifier = defaultMultiCursorModifier,
-    this.multiCursorMergeOverlapping = defaultMultiCursorMergeOverlapping,
-
-    // Editing Features
-    this.formatOnSave = defaultFormatOnSave,
-    this.formatOnPaste = defaultFormatOnPaste,
-    this.formatOnType = defaultFormatOnType,
-    this.quickSuggestions = defaultQuickSuggestions,
-    this.quickSuggestionsDelay = defaultQuickSuggestionsDelay,
-    this.suggestOnTriggerCharacters = defaultSuggestOnTriggerCharacters,
-    this.acceptSuggestionOnEnter = defaultAcceptSuggestionOnEnter,
-    this.acceptSuggestionOnCommitCharacter =
-        defaultAcceptSuggestionOnCommitCharacter,
-    this.snippetSuggestions = defaultSnippetSuggestions,
-    this.wordBasedSuggestions = defaultWordBasedSuggestions,
-    this.parameterHints = defaultParameterHints,
-    this.hover = defaultHover,
-    this.contextMenu = defaultContextMenu,
-
-    // Find & Replace
-    this.find = defaultFind,
-    this.seedSearchStringFromSelection = defaultSeedSearchStringFromSelection,
-
-    // Accessibility
-    this.accessibilitySupport = defaultAccessibilitySupport,
-    this.accessibilityPageSize = defaultAccessibilityPageSize,
-
-    // Performance
-    this.renderValidationDecorations = defaultRenderValidationDecorations,
-    this.renderControlCharacters = defaultRenderControlCharacters,
-    this.disableLayerHinting = defaultDisableLayerHinting,
-    this.disableMonospaceOptimizations = defaultDisableMonospaceOptimizations,
-    this.maxTokenizationLineLength = defaultMaxTokenizationLineLength,
-
-    // Language Specific
-    this.languageConfigs = const {},
-
-    // Keybindings
-    this.keybindingPreset = defaultKeybindingPreset,
-    this.customKeybindings = const {},
-
-    // Advanced
-    this.readOnly = defaultReadOnly,
-    this.domReadOnly = defaultDomReadOnly,
-    this.dragAndDrop = defaultDragAndDrop,
-    this.links = defaultLinks,
-    this.mouseWheelZoom = defaultMouseWheelZoom,
-    this.mouseWheelScrollSensitivity = defaultMouseWheelScrollSensitivity,
-    this.automaticLayout = defaultAutomaticLayout,
-    this.padding = defaultPadding,
-    this.roundedSelection = defaultRoundedSelection,
-    this.selectionHighlight = defaultSelectionHighlight,
-    this.occurrencesHighlight = defaultOccurrencesHighlight,
-    this.overviewRulerBorder = defaultOverviewRulerBorder,
-    this.hideCursorInOverviewRuler = defaultHideCursorInOverviewRuler,
-    this.scrollbar = defaultScrollbar,
-    this.experimentalFeatures = const {},
-  });
-
-  factory EditorSettings.fromJson(Map<String, dynamic> json) {
-    T? parseEnum<T extends Enum>(String? value, List<T> values) {
-      if (value == null) return null;
-      try {
-        return values.firstWhere((e) => e.name == value);
-      } catch (e) {
-        return null; // Or throw an error, or return a default
-      }
-    }
-
-    final parsedLanguageConfigs = <String, LanguageConfig>{};
-    final langConfigsDynamic = json[keyLanguageConfigs];
-    if (langConfigsDynamic != null) {
-      try {
-        // If it's a string, decode it first (like from SharedPreferences)
-        // If it's already a map (like from direct JSON parsing), use it
-        var langConfigsJson = <String, dynamic>{};
-        if (langConfigsDynamic is String) {
-          langConfigsJson =
-              langConfigsDynamic.decode() as Map<String, dynamic>? ?? {};
-        } else if (langConfigsDynamic is Map) {
-          langConfigsJson = Map<String, dynamic>.from(langConfigsDynamic);
-        }
-
-        for (final entry in langConfigsJson.entries) {
-          if (entry.value is Map<String, dynamic>) {
-            parsedLanguageConfigs[entry.key] =
-                LanguageConfig.fromJson(entry.value as Map<String, dynamic>);
-          }
-        }
-      } catch (e) {
-        // Log error or handle as needed
-        if (kDebugMode) {
-          print('Error parsing language configs from JSON: $e');
-        }
-      }
-    }
-
-    return EditorSettings(
-      theme: json.tryGetString(keyTheme) ?? defaultTheme,
-      fontSize: json.tryGetDouble(keyFontSize) ?? defaultFontSize,
-      fontFamily: json.tryGetString(keyFontFamily) ?? defaultFontFamily,
-      lineHeight: json.tryGetDouble(keyLineHeight) ?? defaultLineHeight,
-      letterSpacing:
-          json.tryGetDouble(keyLetterSpacing) ?? defaultLetterSpacing,
-      showLineNumbers:
-          json.tryGetBool(keyShowLineNumbers) ?? defaultShowLineNumbers,
-      lineNumbersStyle: parseEnum(json.tryGetString(keyLineNumbersStyle),
-              LineNumbersStyle.values) ??
-          defaultLineNumbersStyle,
-      showMinimap: json.tryGetBool(keyShowMinimap) ?? defaultShowMinimap,
-      minimapSide:
-          parseEnum(json.tryGetString(keyMinimapSide), MinimapSide.values) ??
-              defaultMinimapSide,
-      minimapRenderCharacters: json.tryGetBool(keyMinimapRenderCharacters) ??
-          defaultMinimapRenderCharacters,
-      minimapSize: json.tryGetInt(keyMinimapSize) ?? defaultMinimapSize,
-      showIndentGuides:
-          json.tryGetBool(keyShowIndentGuides) ?? defaultShowIndentGuides,
-      renderWhitespace: parseEnum(json.tryGetString(keyRenderWhitespace),
-              RenderWhitespace.values) ??
-          defaultRenderWhitespace,
-      rulers: json
-              .tryGetList<String>(keyRulers)
-              ?.map((s) => int.tryParse(s) ?? 0)
-              .where((i) => i > 0)
-              .toList() ??
-          defaultRulers,
-      stickyScroll: json.tryGetBool(keyStickyScroll) ?? defaultStickyScroll,
-      showFoldingControls: json.tryGetString(keyShowFoldingControls) ??
-          defaultShowFoldingControls,
-      glyphMargin: json.tryGetBool(keyGlyphMargin) ?? defaultGlyphMargin,
-      renderLineHighlight: json.tryGetString(keyRenderLineHighlight) ??
-          defaultRenderLineHighlight,
-      wordWrap: parseEnum(json.tryGetString(keyWordWrap), WordWrap.values) ??
-          defaultWordWrap,
-      wordWrapColumn:
-          json.tryGetInt(keyWordWrapColumn) ?? defaultWordWrapColumn,
-      tabSize: json.tryGetInt(keyTabSize) ?? defaultTabSize,
-      insertSpaces: json.tryGetBool(keyInsertSpaces) ?? defaultInsertSpaces,
-      autoIndent: json.tryGetString(keyAutoIndent) ?? defaultAutoIndent,
-      autoClosingBrackets: json.tryGetString(keyAutoClosingBrackets) ??
-          defaultAutoClosingBrackets,
-      autoClosingQuotes:
-          json.tryGetString(keyAutoClosingQuotes) ?? defaultAutoClosingQuotes,
-      autoSurround: json.tryGetString(keyAutoSurround) ?? defaultAutoSurround,
-      bracketPairColorization: json.tryGetBool(keyBracketPairColorization) ??
-          defaultBracketPairColorization,
-      codeFolding: json.tryGetBool(keyCodeFolding) ?? defaultCodeFolding,
-      scrollBeyondLastLine: json.tryGetBool(keyScrollBeyondLastLine) ??
-          defaultScrollBeyondLastLine,
-      smoothScrolling:
-          json.tryGetBool(keySmoothScrolling) ?? defaultSmoothScrolling,
-      fastScrollSensitivity: json.tryGetDouble(keyFastScrollSensitivity) ??
-          defaultFastScrollSensitivity,
-      scrollPredominantAxis: json.tryGetBool(keyScrollPredominantAxis) ??
-          defaultScrollPredominantAxis,
-      cursorBlinking: parseEnum(
-              json.tryGetString(keyCursorBlinking), CursorBlinking.values) ??
-          defaultCursorBlinking,
-      cursorSmoothCaretAnimation:
-          json.tryGetString(keyCursorSmoothCaretAnimation) ??
-              defaultCursorSmoothCaretAnimation,
-      cursorStyle:
-          parseEnum(json.tryGetString(keyCursorStyle), CursorStyle.values) ??
-              defaultCursorStyle,
-      cursorWidth: json.tryGetInt(keyCursorWidth) ?? defaultCursorWidth,
-      multiCursorModifier: parseEnum(json.tryGetString(keyMultiCursorModifier),
-              MultiCursorModifier.values) ??
-          defaultMultiCursorModifier,
-      multiCursorMergeOverlapping:
-          json.tryGetBool(keyMultiCursorMergeOverlapping) ??
-              defaultMultiCursorMergeOverlapping,
-      formatOnSave: json.tryGetBool(keyFormatOnSave) ?? defaultFormatOnSave,
-      formatOnPaste: json.tryGetBool(keyFormatOnPaste) ?? defaultFormatOnPaste,
-      formatOnType: json.tryGetBool(keyFormatOnType) ?? defaultFormatOnType,
-      quickSuggestions:
-          json.tryGetBool(keyQuickSuggestions) ?? defaultQuickSuggestions,
-      quickSuggestionsDelay: json.tryGetInt(keyQuickSuggestionsDelay) ??
-          defaultQuickSuggestionsDelay,
-      suggestOnTriggerCharacters:
-          json.tryGetBool(keySuggestOnTriggerCharacters) ??
-              defaultSuggestOnTriggerCharacters,
-      acceptSuggestionOnEnter: parseEnum(
-              json.tryGetString(keyAcceptSuggestionOnEnter),
-              AcceptSuggestionOnEnter.values) ??
-          defaultAcceptSuggestionOnEnter,
-      acceptSuggestionOnCommitCharacter:
-          json.tryGetBool(keyAcceptSuggestionOnCommitCharacter) ??
-              defaultAcceptSuggestionOnCommitCharacter,
-      snippetSuggestions: parseEnum(json.tryGetString(keySnippetSuggestions),
-              SnippetSuggestions.values) ??
-          defaultSnippetSuggestions,
-      wordBasedSuggestions: parseEnum(
-              json.tryGetString(keyWordBasedSuggestions),
-              WordBasedSuggestions.values) ??
-          defaultWordBasedSuggestions,
-      parameterHints:
-          json.tryGetBool(keyParameterHints) ?? defaultParameterHints,
-      hover: json.tryGetBool(keyHover) ?? defaultHover,
-      contextMenu: json.tryGetBool(keyContextMenu) ?? defaultContextMenu,
-      find: json.tryGetBool(keyFind) ?? defaultFind,
-      seedSearchStringFromSelection:
-          json.tryGetString(keySeedSearchStringFromSelection) ??
-              defaultSeedSearchStringFromSelection,
-      accessibilitySupport: parseEnum(
-              json.tryGetString(keyAccessibilitySupport),
-              AccessibilitySupport.values) ??
-          defaultAccessibilitySupport,
-      accessibilityPageSize: json.tryGetInt(keyAccessibilityPageSize) ??
-          defaultAccessibilityPageSize,
-      renderValidationDecorations:
-          json.tryGetString(keyRenderValidationDecorations) ??
-              defaultRenderValidationDecorations,
-      renderControlCharacters: json.tryGetBool(keyRenderControlCharacters) ??
-          defaultRenderControlCharacters,
-      disableLayerHinting:
-          json.tryGetBool(keyDisableLayerHinting) ?? defaultDisableLayerHinting,
-      disableMonospaceOptimizations:
-          json.tryGetBool(keyDisableMonospaceOptimizations) ??
-              defaultDisableMonospaceOptimizations,
-      maxTokenizationLineLength: json.tryGetInt(keyMaxTokenizationLineLength) ??
-          defaultMaxTokenizationLineLength,
-      languageConfigs: parsedLanguageConfigs,
-      keybindingPreset: parseEnum(json.tryGetString(keyKeybindingPreset),
-              KeybindingPresetEnum.values) ??
-          defaultKeybindingPreset,
-      customKeybindings: (json[keyCustomKeybindings] is String
-              ? (json.tryGetString(keyCustomKeybindings)?.decode()
-                      as Map<String, dynamic>?)
-                  ?.map((key, value) => MapEntry(key, value.toString()))
-              : Map<String, String>.from(
-                  json[keyCustomKeybindings] as Map? ?? {})) ??
-          {},
-      readOnly: json.tryGetBool(keyReadOnly) ?? defaultReadOnly,
-      domReadOnly: json.tryGetBool(keyDomReadOnly) ?? defaultDomReadOnly,
-      dragAndDrop: json.tryGetBool(keyDragAndDrop) ?? defaultDragAndDrop,
-      links: json.tryGetBool(keyLinks) ?? defaultLinks,
-      mouseWheelZoom:
-          json.tryGetBool(keyMouseWheelZoom) ?? defaultMouseWheelZoom,
-      mouseWheelScrollSensitivity:
-          json.tryGetDouble(keyMouseWheelScrollSensitivity) ??
-              defaultMouseWheelScrollSensitivity,
-      automaticLayout:
-          json.tryGetBool(keyAutomaticLayout) ?? defaultAutomaticLayout,
-      padding: (json[keyPadding] is String
-              ? (json.tryGetString(keyPadding)?.decode()
-                      as Map<String, dynamic>?)
-                  ?.cast<String, int>()
-              : Map<String, int>.from(json[keyPadding] as Map? ?? {})) ??
-          defaultPadding,
-      roundedSelection:
-          json.tryGetBool(keyRoundedSelection) ?? defaultRoundedSelection,
-      selectionHighlight:
-          json.tryGetBool(keySelectionHighlight) ?? defaultSelectionHighlight,
-      occurrencesHighlight: json.tryGetString(keyOccurrencesHighlight) ??
-          defaultOccurrencesHighlight,
-      overviewRulerBorder:
-          json.tryGetBool(keyOverviewRulerBorder) ?? defaultOverviewRulerBorder,
-      hideCursorInOverviewRuler:
-          json.tryGetBool(keyHideCursorInOverviewRuler) ??
-              defaultHideCursorInOverviewRuler,
-      scrollbar: (json[keyScrollbar] is String
-              ? json.tryGetString(keyScrollbar)?.decode()
-                  as Map<String, dynamic>?
-              : Map<String, dynamic>.from(json[keyScrollbar] as Map? ?? {})) ??
-          defaultScrollbar,
-      experimentalFeatures: (json[keyExperimentalFeatures] is String
-              ? json.tryGetString(keyExperimentalFeatures)?.decode()
-                  as Map<String, dynamic>?
-              : Map<String, dynamic>.from(
-                  json[keyExperimentalFeatures] as Map? ?? {})) ??
-          {},
-    );
-  }
-
-  /// Create preset configurations
-  factory EditorSettings.createPreset(String presetName) {
-    switch (presetName.toLowerCase()) {
-      case 'beginner':
-        return const EditorSettings(
-          showMinimap: false,
-          fontSize: 16,
-          formatOnSave: true,
-          formatOnPaste: true,
-          autoClosingBrackets: 'always',
-          autoClosingQuotes: 'always',
-        );
-
-      case 'developer':
-        return const EditorSettings(
-          showMinimap: true,
-          wordWrap: WordWrap.off,
-          rulers: [80, 120],
-          formatOnSave: true,
-          renderWhitespace: RenderWhitespace.boundary,
-        );
-
-      case 'poweruser':
-        return const EditorSettings(
-          lineNumbersStyle: LineNumbersStyle.relative,
-          showMinimap: true,
-          fontSize: 13,
-          wordWrap: WordWrap.off,
-          rulers: [80, 100, 120],
-          formatOnSave: true,
-          formatOnType: true,
-          stickyScroll: true,
-          renderWhitespace: RenderWhitespace.all,
-          cursorBlinking: CursorBlinking.smooth,
-          multiCursorModifier: MultiCursorModifier.alt,
-        );
-
-      case 'accessibility':
-        return const EditorSettings(
-          fontSize: 18,
-          lineHeight: 1.6,
-          accessibilitySupport: AccessibilitySupport.on,
-          renderWhitespace: RenderWhitespace.all,
-          renderControlCharacters: true,
-          cursorBlinking: CursorBlinking.solid,
-          cursorStyle: CursorStyle.block,
-          cursorWidth: 3,
-        );
-
-      default:
-        return const EditorSettings();
-    }
-  }
-
-  // === CONSTANTS & DEFAULTS ===
-
-  // General
-  static const String defaultTheme = 'vs-dark';
-  static const double defaultFontSize = 14;
-  static const String defaultFontFamily =
-      'JetBrains Mono, SF Mono, Menlo, Consolas, "Courier New", monospace';
-  static const double defaultLineHeight = 1.4;
-  static const double defaultLetterSpacing = 0;
-
-  // Display
-  static const bool defaultShowLineNumbers = true;
-  static const LineNumbersStyle defaultLineNumbersStyle = LineNumbersStyle.on;
-  static const bool defaultShowMinimap = false;
-  static const MinimapSide defaultMinimapSide = MinimapSide.right;
-  static const bool defaultMinimapRenderCharacters = false;
-  static const int defaultMinimapSize = 1;
-  static const bool defaultShowIndentGuides = true;
-  static const RenderWhitespace defaultRenderWhitespace =
-      RenderWhitespace.selection;
-  static const List<int> defaultRulers = [];
-  static const bool defaultStickyScroll = false;
-  static const String defaultShowFoldingControls = 'mouseover';
-  static const bool defaultGlyphMargin = true;
-  static const String defaultRenderLineHighlight = 'line';
-
-  // Editor Behavior
-  static const WordWrap defaultWordWrap = WordWrap.on;
-  static const int defaultWordWrapColumn = 80;
-  static const int defaultTabSize = 4;
-  static const bool defaultInsertSpaces = true;
-  static const String defaultAutoIndent = 'advanced';
-  static const String defaultAutoClosingBrackets = 'languageDefined';
-  static const String defaultAutoClosingQuotes = 'languageDefined';
-  static const String defaultAutoSurround = 'languageDefined';
-  static const bool defaultBracketPairColorization = true;
-  static const bool defaultCodeFolding = true;
-  static const bool defaultScrollBeyondLastLine = true;
-  static const bool defaultSmoothScrolling = false;
-  static const double defaultFastScrollSensitivity = 5;
-  static const bool defaultScrollPredominantAxis = true;
-
-  // Cursor
-  static const CursorBlinking defaultCursorBlinking = CursorBlinking.blink;
-  static const String defaultCursorSmoothCaretAnimation = 'off';
-  static const CursorStyle defaultCursorStyle = CursorStyle.line;
-  static const int defaultCursorWidth = 0;
-  static const MultiCursorModifier defaultMultiCursorModifier =
-      MultiCursorModifier.ctrlCmd;
-  static const bool defaultMultiCursorMergeOverlapping = true;
-
-  // Editing Features
-  static const bool defaultFormatOnSave = false;
-  static const bool defaultFormatOnPaste = false;
-  static const bool defaultFormatOnType = false;
-  static const bool defaultQuickSuggestions = true;
-  static const int defaultQuickSuggestionsDelay = 10;
-  static const bool defaultSuggestOnTriggerCharacters = true;
-  static const AcceptSuggestionOnEnter defaultAcceptSuggestionOnEnter =
-      AcceptSuggestionOnEnter.on;
-  static const bool defaultAcceptSuggestionOnCommitCharacter = true;
-  static const SnippetSuggestions defaultSnippetSuggestions =
-      SnippetSuggestions.inline;
-  static const WordBasedSuggestions defaultWordBasedSuggestions =
-      WordBasedSuggestions.currentDocument;
-  static const bool defaultParameterHints = true;
-  static const bool defaultHover = true;
-  static const bool defaultContextMenu = true;
-
-  // Find & Replace
-  static const bool defaultFind = true;
-  static const String defaultSeedSearchStringFromSelection = 'selection';
-
-  // Accessibility
-  static const AccessibilitySupport defaultAccessibilitySupport =
-      AccessibilitySupport.auto;
-  static const int defaultAccessibilityPageSize = 10;
-
-  // Performance
-  static const String defaultRenderValidationDecorations = 'editable';
-  static const bool defaultRenderControlCharacters = false;
-  static const bool defaultDisableLayerHinting = false;
-  static const bool defaultDisableMonospaceOptimizations = false;
-  static const int defaultMaxTokenizationLineLength = 20000;
-
-  // Keybindings
-  static const KeybindingPresetEnum defaultKeybindingPreset =
-      KeybindingPresetEnum.vscode;
-
-  // Advanced
-  static const bool defaultReadOnly = false;
-  static const bool defaultDomReadOnly = false;
-  static const bool defaultDragAndDrop = true;
-  static const bool defaultLinks = true;
-  static const bool defaultMouseWheelZoom = false;
-  static const double defaultMouseWheelScrollSensitivity = 1;
-  static const bool defaultAutomaticLayout = true;
-  static const Map<String, int> defaultPadding = {
-    'top': 10,
-    'bottom': 10,
-    'start': 10,
-    'end': 10
-  };
-  static const bool defaultRoundedSelection = true;
-  static const bool defaultSelectionHighlight = true;
-  static const String defaultOccurrencesHighlight = 'singleFile';
-  static const bool defaultOverviewRulerBorder = true;
-  static const bool defaultHideCursorInOverviewRuler = false;
-  static const Map<String, dynamic> defaultScrollbar = {
-    'vertical': 'auto',
-    'horizontal': 'auto',
-    'arrowSize': 11,
-    'useShadows': true,
-    'verticalScrollbarSize': 14,
-    'horizontalScrollbarSize': 10,
-    'scrollByPage': false,
-  };
-
-  // === STORAGE KEYS ===
-  static const String keyTheme = 'editor_theme';
-  static const String keyFontSize = 'editor_font_size';
-  static const String keyFontFamily = 'editor_font_family';
-  static const String keyLineHeight = 'editor_line_height';
-  static const String keyLetterSpacing = 'editor_letter_spacing';
-  static const String keyShowLineNumbers = 'editor_show_line_numbers';
-  static const String keyLineNumbersStyle = 'editor_line_numbers_style';
-  static const String keyShowMinimap = 'editor_show_minimap';
-  static const String keyMinimapSide = 'editor_minimap_side';
-  static const String keyMinimapRenderCharacters =
-      'editor_minimap_render_characters';
-  static const String keyMinimapSize = 'editor_minimap_size';
-  static const String keyShowIndentGuides = 'editor_show_indent_guides';
-  static const String keyRenderWhitespace = 'editor_render_whitespace';
-  static const String keyRulers = 'editor_rulers';
-  static const String keyStickyScroll = 'editor_sticky_scroll';
-  static const String keyShowFoldingControls = 'editor_show_folding_controls';
-  static const String keyGlyphMargin = 'editor_glyph_margin';
-  static const String keyRenderLineHighlight = 'editor_render_line_highlight';
-  static const String keyWordWrap = 'editor_word_wrap';
-  static const String keyWordWrapColumn = 'editor_word_wrap_column';
-  static const String keyTabSize = 'editor_tab_size';
-  static const String keyInsertSpaces = 'editor_insert_spaces';
-  static const String keyAutoIndent = 'editor_auto_indent';
-  static const String keyAutoClosingBrackets = 'editor_auto_closing_brackets';
-  static const String keyAutoClosingQuotes = 'editor_auto_closing_quotes';
-  static const String keyAutoSurround = 'editor_auto_surround';
-  static const String keyBracketPairColorization =
-      'editor_bracket_pair_colorization';
-  static const String keyCodeFolding = 'editor_code_folding';
-  static const String keyScrollBeyondLastLine =
-      'editor_scroll_beyond_last_line';
-  static const String keySmoothScrolling = 'editor_smooth_scrolling';
-  static const String keyFastScrollSensitivity =
-      'editor_fast_scroll_sensitivity';
-  static const String keyScrollPredominantAxis =
-      'editor_scroll_predominant_axis';
-  static const String keyCursorBlinking = 'editor_cursor_blinking';
-  static const String keyCursorSmoothCaretAnimation =
-      'editor_cursor_smooth_caret_animation';
-  static const String keyCursorStyle = 'editor_cursor_style';
-  static const String keyCursorWidth = 'editor_cursor_width';
-  static const String keyMultiCursorModifier = 'editor_multi_cursor_modifier';
-  static const String keyMultiCursorMergeOverlapping =
-      'editor_multi_cursor_merge_overlapping';
-  static const String keyFormatOnSave = 'editor_format_on_save';
-  static const String keyFormatOnPaste = 'editor_format_on_paste';
-  static const String keyFormatOnType = 'editor_format_on_type';
-  static const String keyQuickSuggestions = 'editor_quick_suggestions';
-  static const String keyQuickSuggestionsDelay =
-      'editor_quick_suggestions_delay';
-  static const String keySuggestOnTriggerCharacters =
-      'editor_suggest_on_trigger_characters';
-  static const String keyAcceptSuggestionOnEnter =
-      'editor_accept_suggestion_on_enter';
-  static const String keyAcceptSuggestionOnCommitCharacter =
-      'editor_accept_suggestion_on_commit_character';
-  static const String keySnippetSuggestions = 'editor_snippet_suggestions';
-  static const String keyWordBasedSuggestions = 'editor_word_based_suggestions';
-  static const String keyParameterHints = 'editor_parameter_hints';
-  static const String keyHover = 'editor_hover';
-  static const String keyContextMenu = 'editor_context_menu';
-  static const String keyFind = 'editor_find';
-  static const String keySeedSearchStringFromSelection =
-      'editor_seed_search_string_from_selection';
-  static const String keyAccessibilitySupport = 'editor_accessibility_support';
-  static const String keyAccessibilityPageSize =
-      'editor_accessibility_page_size';
-  static const String keyRenderValidationDecorations =
-      'editor_render_validation_decorations';
-  static const String keyRenderControlCharacters =
-      'editor_render_control_characters';
-  static const String keyDisableLayerHinting = 'editor_disable_layer_hinting';
-  static const String keyDisableMonospaceOptimizations =
-      'editor_disable_monospace_optimizations';
-  static const String keyMaxTokenizationLineLength =
-      'editor_max_tokenization_line_length';
-  static const String keyLanguageConfigs = 'editor_language_configs';
-  static const String keyKeybindingPreset = 'editor_keybinding_preset';
-  static const String keyCustomKeybindings = 'editor_custom_keybindings';
-  static const String keyReadOnly = 'editor_read_only';
-  static const String keyDomReadOnly = 'editor_dom_read_only';
-  static const String keyDragAndDrop = 'editor_drag_and_drop';
-  static const String keyLinks = 'editor_links';
-  static const String keyMouseWheelZoom = 'editor_mouse_wheel_zoom';
-  static const String keyMouseWheelScrollSensitivity =
-      'editor_mouse_wheel_scroll_sensitivity';
-  static const String keyAutomaticLayout = 'editor_automatic_layout';
-  static const String keyPadding = 'editor_padding';
-  static const String keyRoundedSelection = 'editor_rounded_selection';
-  static const String keySelectionHighlight = 'editor_selection_highlight';
-  static const String keyOccurrencesHighlight = 'editor_occurrences_highlight';
-  static const String keyOverviewRulerBorder = 'editor_overview_ruler_border';
-  static const String keyHideCursorInOverviewRuler =
-      'editor_hide_cursor_in_overview_ruler';
-  static const String keyScrollbar = 'editor_scrollbar';
-  static const String keyExperimentalFeatures = 'editor_experimental_features';
-
-  // === PROPERTIES ===
-
-  // General Settings
-  final String theme;
-  final double fontSize;
-  final String fontFamily;
-  final double lineHeight;
-  final double letterSpacing;
-
-  // Display Settings
-  final bool showLineNumbers;
-  final LineNumbersStyle lineNumbersStyle;
-  final bool showMinimap;
-  final MinimapSide minimapSide;
-  final bool minimapRenderCharacters;
-  final int minimapSize;
-  final bool showIndentGuides;
-  final RenderWhitespace renderWhitespace;
-  final List<int> rulers;
-  final bool stickyScroll;
-  final String showFoldingControls;
-  final bool glyphMargin;
-  final String renderLineHighlight;
-
-  // Editor Behavior
-  final WordWrap wordWrap;
-  final int wordWrapColumn;
-  final int tabSize;
-  final bool insertSpaces;
-  final String autoIndent;
-  final String autoClosingBrackets;
-  final String autoClosingQuotes;
-  final String autoSurround;
-  final bool bracketPairColorization;
-  final bool codeFolding;
-  final bool scrollBeyondLastLine;
-  final bool smoothScrolling;
-  final double fastScrollSensitivity;
-  final bool scrollPredominantAxis;
-
-  // Cursor Settings
-  final CursorBlinking cursorBlinking;
-  final String cursorSmoothCaretAnimation;
-  final CursorStyle cursorStyle;
-  final int cursorWidth;
-  final MultiCursorModifier multiCursorModifier;
-  final bool multiCursorMergeOverlapping;
-
-  // Editing Features
-  final bool formatOnSave;
-  final bool formatOnPaste;
-  final bool formatOnType;
-  final bool quickSuggestions;
-  final int quickSuggestionsDelay;
-  final bool suggestOnTriggerCharacters;
-  final AcceptSuggestionOnEnter acceptSuggestionOnEnter;
-  final bool acceptSuggestionOnCommitCharacter;
-  final SnippetSuggestions snippetSuggestions;
-  final WordBasedSuggestions wordBasedSuggestions;
-  final bool parameterHints;
-  final bool hover;
-  final bool contextMenu;
-
-  // Find & Replace
-  final bool find;
-  final String seedSearchStringFromSelection;
-
-  // Accessibility
-  final AccessibilitySupport accessibilitySupport;
-  final int accessibilityPageSize;
-
-  // Performance
-  final String renderValidationDecorations;
-  final bool renderControlCharacters;
-  final bool disableLayerHinting;
-  final bool disableMonospaceOptimizations;
-  final int maxTokenizationLineLength;
-
-  // Language Specific
-  final Map<String, LanguageConfig> languageConfigs;
-
-  // Keybindings
-  final KeybindingPresetEnum keybindingPreset;
-  final Map<String, String> customKeybindings;
-
-  // Advanced
-  final bool readOnly;
-  final bool domReadOnly;
-  final bool dragAndDrop;
-  final bool links;
-  final bool mouseWheelZoom;
-  final double mouseWheelScrollSensitivity;
-  final bool automaticLayout;
-  final Map<String, int> padding;
-  final bool roundedSelection;
-  final bool selectionHighlight;
-  final String occurrencesHighlight;
-  final bool overviewRulerBorder;
-  final bool hideCursorInOverviewRuler;
-  final Map<String, dynamic> scrollbar;
-  final Map<String, dynamic> experimentalFeatures;
-
-  // === METHODS ===
-
-  EditorSettings copyWith({
-    String? theme,
-    double? fontSize,
-    String? fontFamily,
-    double? lineHeight,
-    double? letterSpacing,
-    bool? showLineNumbers,
-    LineNumbersStyle? lineNumbersStyle,
-    bool? showMinimap,
-    MinimapSide? minimapSide,
-    bool? minimapRenderCharacters,
-    int? minimapSize,
-    bool? showIndentGuides,
-    RenderWhitespace? renderWhitespace,
-    List<int>? rulers,
-    bool? stickyScroll,
-    String? showFoldingControls,
-    bool? glyphMargin,
-    String? renderLineHighlight,
-    WordWrap? wordWrap,
-    int? wordWrapColumn,
-    int? tabSize,
-    bool? insertSpaces,
-    String? autoIndent,
-    String? autoClosingBrackets,
-    String? autoClosingQuotes,
-    String? autoSurround,
-    bool? bracketPairColorization,
-    bool? codeFolding,
-    bool? scrollBeyondLastLine,
-    bool? smoothScrolling,
-    double? fastScrollSensitivity,
-    bool? scrollPredominantAxis,
-    CursorBlinking? cursorBlinking,
-    String? cursorSmoothCaretAnimation,
-    CursorStyle? cursorStyle,
-    int? cursorWidth,
-    MultiCursorModifier? multiCursorModifier,
-    bool? multiCursorMergeOverlapping,
-    bool? formatOnSave,
-    bool? formatOnPaste,
-    bool? formatOnType,
-    bool? quickSuggestions,
-    int? quickSuggestionsDelay,
-    bool? suggestOnTriggerCharacters,
-    AcceptSuggestionOnEnter? acceptSuggestionOnEnter,
-    bool? acceptSuggestionOnCommitCharacter,
-    SnippetSuggestions? snippetSuggestions,
-    WordBasedSuggestions? wordBasedSuggestions,
-    bool? parameterHints,
-    bool? hover,
-    bool? contextMenu,
-    bool? find,
-    String? seedSearchStringFromSelection,
-    AccessibilitySupport? accessibilitySupport,
-    int? accessibilityPageSize,
-    String? renderValidationDecorations,
-    bool? renderControlCharacters,
-    bool? disableLayerHinting,
-    bool? disableMonospaceOptimizations,
-    int? maxTokenizationLineLength,
-    Map<String, LanguageConfig>? languageConfigs,
-    KeybindingPresetEnum? keybindingPreset,
-    Map<String, String>? customKeybindings,
-    bool? readOnly,
-    bool? domReadOnly,
-    bool? dragAndDrop,
-    bool? links,
-    bool? mouseWheelZoom,
-    double? mouseWheelScrollSensitivity,
-    bool? automaticLayout,
-    Map<String, int>? padding,
-    bool? roundedSelection,
-    bool? selectionHighlight,
-    String? occurrencesHighlight,
-    bool? overviewRulerBorder,
-    bool? hideCursorInOverviewRuler,
-    Map<String, dynamic>? scrollbar,
-    Map<String, dynamic>? experimentalFeatures,
-  }) {
-    return EditorSettings(
-      theme: theme ?? this.theme,
-      fontSize: fontSize ?? this.fontSize,
-      fontFamily: fontFamily ?? this.fontFamily,
-      lineHeight: lineHeight ?? this.lineHeight,
-      letterSpacing: letterSpacing ?? this.letterSpacing,
-      showLineNumbers: showLineNumbers ?? this.showLineNumbers,
-      lineNumbersStyle: lineNumbersStyle ?? this.lineNumbersStyle,
-      showMinimap: showMinimap ?? this.showMinimap,
-      minimapSide: minimapSide ?? this.minimapSide,
-      minimapRenderCharacters:
-          minimapRenderCharacters ?? this.minimapRenderCharacters,
-      minimapSize: minimapSize ?? this.minimapSize,
-      showIndentGuides: showIndentGuides ?? this.showIndentGuides,
-      renderWhitespace: renderWhitespace ?? this.renderWhitespace,
-      rulers: rulers ?? this.rulers,
-      stickyScroll: stickyScroll ?? this.stickyScroll,
-      showFoldingControls: showFoldingControls ?? this.showFoldingControls,
-      glyphMargin: glyphMargin ?? this.glyphMargin,
-      renderLineHighlight: renderLineHighlight ?? this.renderLineHighlight,
-      wordWrap: wordWrap ?? this.wordWrap,
-      wordWrapColumn: wordWrapColumn ?? this.wordWrapColumn,
-      tabSize: tabSize ?? this.tabSize,
-      insertSpaces: insertSpaces ?? this.insertSpaces,
-      autoIndent: autoIndent ?? this.autoIndent,
-      autoClosingBrackets: autoClosingBrackets ?? this.autoClosingBrackets,
-      autoClosingQuotes: autoClosingQuotes ?? this.autoClosingQuotes,
-      autoSurround: autoSurround ?? this.autoSurround,
-      bracketPairColorization:
-          bracketPairColorization ?? this.bracketPairColorization,
-      codeFolding: codeFolding ?? this.codeFolding,
-      scrollBeyondLastLine: scrollBeyondLastLine ?? this.scrollBeyondLastLine,
-      smoothScrolling: smoothScrolling ?? this.smoothScrolling,
-      fastScrollSensitivity:
-          fastScrollSensitivity ?? this.fastScrollSensitivity,
-      scrollPredominantAxis:
-          scrollPredominantAxis ?? this.scrollPredominantAxis,
-      cursorBlinking: cursorBlinking ?? this.cursorBlinking,
-      cursorSmoothCaretAnimation:
-          cursorSmoothCaretAnimation ?? this.cursorSmoothCaretAnimation,
-      cursorStyle: cursorStyle ?? this.cursorStyle,
-      cursorWidth: cursorWidth ?? this.cursorWidth,
-      multiCursorModifier: multiCursorModifier ?? this.multiCursorModifier,
-      multiCursorMergeOverlapping:
-          multiCursorMergeOverlapping ?? this.multiCursorMergeOverlapping,
-      formatOnSave: formatOnSave ?? this.formatOnSave,
-      formatOnPaste: formatOnPaste ?? this.formatOnPaste,
-      formatOnType: formatOnType ?? this.formatOnType,
-      quickSuggestions: quickSuggestions ?? this.quickSuggestions,
-      quickSuggestionsDelay:
-          quickSuggestionsDelay ?? this.quickSuggestionsDelay,
-      suggestOnTriggerCharacters:
-          suggestOnTriggerCharacters ?? this.suggestOnTriggerCharacters,
-      acceptSuggestionOnEnter:
-          acceptSuggestionOnEnter ?? this.acceptSuggestionOnEnter,
-      acceptSuggestionOnCommitCharacter: acceptSuggestionOnCommitCharacter ??
-          this.acceptSuggestionOnCommitCharacter,
-      snippetSuggestions: snippetSuggestions ?? this.snippetSuggestions,
-      wordBasedSuggestions: wordBasedSuggestions ?? this.wordBasedSuggestions,
-      parameterHints: parameterHints ?? this.parameterHints,
-      hover: hover ?? this.hover,
-      contextMenu: contextMenu ?? this.contextMenu,
-      find: find ?? this.find,
-      seedSearchStringFromSelection:
-          seedSearchStringFromSelection ?? this.seedSearchStringFromSelection,
-      accessibilitySupport: accessibilitySupport ?? this.accessibilitySupport,
-      accessibilityPageSize:
-          accessibilityPageSize ?? this.accessibilityPageSize,
-      renderValidationDecorations:
-          renderValidationDecorations ?? this.renderValidationDecorations,
-      renderControlCharacters:
-          renderControlCharacters ?? this.renderControlCharacters,
-      disableLayerHinting: disableLayerHinting ?? this.disableLayerHinting,
-      disableMonospaceOptimizations:
-          disableMonospaceOptimizations ?? this.disableMonospaceOptimizations,
-      maxTokenizationLineLength:
-          maxTokenizationLineLength ?? this.maxTokenizationLineLength,
-      languageConfigs: languageConfigs ?? this.languageConfigs,
-      keybindingPreset: keybindingPreset ?? this.keybindingPreset,
-      customKeybindings: customKeybindings ?? this.customKeybindings,
-      readOnly: readOnly ?? this.readOnly,
-      domReadOnly: domReadOnly ?? this.domReadOnly,
-      dragAndDrop: dragAndDrop ?? this.dragAndDrop,
-      links: links ?? this.links,
-      mouseWheelZoom: mouseWheelZoom ?? this.mouseWheelZoom,
-      mouseWheelScrollSensitivity:
-          mouseWheelScrollSensitivity ?? this.mouseWheelScrollSensitivity,
-      automaticLayout: automaticLayout ?? this.automaticLayout,
-      padding: padding ?? this.padding,
-      roundedSelection: roundedSelection ?? this.roundedSelection,
-      selectionHighlight: selectionHighlight ?? this.selectionHighlight,
-      occurrencesHighlight: occurrencesHighlight ?? this.occurrencesHighlight,
-      overviewRulerBorder: overviewRulerBorder ?? this.overviewRulerBorder,
-      hideCursorInOverviewRuler:
-          hideCursorInOverviewRuler ?? this.hideCursorInOverviewRuler,
-      scrollbar: scrollbar ?? this.scrollbar,
-      experimentalFeatures: experimentalFeatures ?? this.experimentalFeatures,
-    );
-  }
-
-  /// Get settings for a specific language, merging global and language-specific settings
-  EditorSettings getLanguageSettings(String language) {
-    final langConfig = languageConfigs[language];
-    if (langConfig == null) return this;
-
-    return copyWith(
-      tabSize: langConfig.tabSize ?? tabSize,
-      insertSpaces: langConfig.insertSpaces ?? insertSpaces,
-      wordWrap: langConfig.wordWrap ?? wordWrap,
-      rulers: langConfig.rulers ?? rulers,
-      formatOnSave: langConfig.formatOnSave ?? formatOnSave,
-      formatOnPaste: langConfig.formatOnPaste ?? formatOnPaste,
-      formatOnType: langConfig.formatOnType ?? formatOnType,
-      autoClosingBrackets:
-          langConfig.autoClosingBrackets ?? autoClosingBrackets,
-      autoClosingQuotes: langConfig.autoClosingQuotes ?? autoClosingQuotes,
-      bracketPairColorization:
-          langConfig.bracketPairColorization ?? bracketPairColorization,
-    );
-  }
-
-  /// Convert to Monaco editor options JSON
-  Map<String, dynamic> toMonacoOptions() {
-    return {
-      'theme': theme,
-      'fontSize': fontSize,
-      'fontFamily': fontFamily,
-      'lineHeight': lineHeight,
-      'letterSpacing': letterSpacing,
-      'lineNumbers': showLineNumbers ? 'on' : 'off',
-      'minimap': {
-        'enabled': showMinimap,
-        'side': minimapSide.name,
-        'renderCharacters': minimapRenderCharacters,
-        'size': minimapSize,
-      },
-      'renderIndentGuides': showIndentGuides,
-      'renderWhitespace': renderWhitespace.name,
-      'rulers': rulers,
-      'stickyScroll': {'enabled': stickyScroll},
-      'showFoldingControls': showFoldingControls,
-      'glyphMargin': glyphMargin,
-      'renderLineHighlight': renderLineHighlight,
-      'wordWrap': wordWrap.name,
-      'wordWrapColumn': wordWrapColumn,
-      'tabSize': tabSize,
-      'insertSpaces': insertSpaces,
-      'autoIndent': autoIndent,
-      'autoClosingBrackets': autoClosingBrackets,
-      'autoClosingQuotes': autoClosingQuotes,
-      'autoSurround': autoSurround,
-      'bracketPairColorization': {'enabled': bracketPairColorization},
-      'folding': codeFolding,
-      'scrollBeyondLastLine': scrollBeyondLastLine,
-      'smoothScrolling': smoothScrolling,
-      'fastScrollSensitivity': fastScrollSensitivity,
-      'scrollPredominantAxis': scrollPredominantAxis,
-      'cursorBlinking': cursorBlinking.name,
-      'cursorSmoothCaretAnimation': cursorSmoothCaretAnimation,
-      'cursorStyle': cursorStyle.name,
-      'cursorWidth': cursorWidth,
-      'multiCursorModifier': multiCursorModifier.name,
-      'multiCursorMergeOverlapping': multiCursorMergeOverlapping,
-      'formatOnPaste': formatOnPaste,
-      'formatOnType': formatOnType,
-      'quickSuggestions': quickSuggestions,
-      'quickSuggestionsDelay': quickSuggestionsDelay,
-      'suggestOnTriggerCharacters': suggestOnTriggerCharacters,
-      'acceptSuggestionOnEnter': acceptSuggestionOnEnter.name,
-      'acceptSuggestionOnCommitCharacter': acceptSuggestionOnCommitCharacter,
-      'snippetSuggestions': snippetSuggestions.name,
-      'wordBasedSuggestions': wordBasedSuggestions.name,
-      'parameterHints': {'enabled': parameterHints},
-      'hover': {'enabled': hover},
-      'contextmenu': contextMenu,
-      'find': {
-        'seedSearchStringFromSelection': seedSearchStringFromSelection,
-      },
-      'accessibilitySupport': accessibilitySupport.name,
-      'accessibilityPageSize': accessibilityPageSize,
-      'renderValidationDecorations': renderValidationDecorations,
-      'renderControlCharacters': renderControlCharacters,
-      'disableLayerHinting': disableLayerHinting,
-      'disableMonospaceOptimizations': disableMonospaceOptimizations,
-      'maxTokenizationLineLength': maxTokenizationLineLength,
-      'readOnly': readOnly,
-      'domReadOnly': domReadOnly,
-      'dragAndDrop': dragAndDrop,
-      'links': links,
-      'mouseWheelZoom': mouseWheelZoom,
-      'mouseWheelScrollSensitivity': mouseWheelScrollSensitivity,
-      'automaticLayout': automaticLayout,
-      'padding': padding,
-      'roundedSelection': roundedSelection,
-      'selectionHighlight': selectionHighlight,
-      'occurrencesHighlight': occurrencesHighlight,
-      'overviewRulerBorder': overviewRulerBorder,
-      'hideCursorInOverviewRuler': hideCursorInOverviewRuler,
-      'scrollbar': scrollbar,
-    };
-  }
-
-  /// Save all settings to SharedPreferences
-  Future<void> save() async {
-    final prefs = await SharedPreferences.getInstance();
-
-    // General
-    await prefs.setString(keyTheme, theme);
-    await prefs.setDouble(keyFontSize, fontSize);
-    await prefs.setString(keyFontFamily, fontFamily);
-    await prefs.setDouble(keyLineHeight, lineHeight);
-    await prefs.setDouble(keyLetterSpacing, letterSpacing);
-
-    // Display
-    await prefs.setBool(keyShowLineNumbers, showLineNumbers);
-    await prefs.setString(keyLineNumbersStyle, lineNumbersStyle.name);
-    await prefs.setBool(keyShowMinimap, showMinimap);
-    await prefs.setString(keyMinimapSide, minimapSide.name);
-    await prefs.setBool(keyMinimapRenderCharacters, minimapRenderCharacters);
-    await prefs.setInt(keyMinimapSize, minimapSize);
-    await prefs.setBool(keyShowIndentGuides, showIndentGuides);
-    await prefs.setString(keyRenderWhitespace, renderWhitespace.name);
-    await prefs.setStringList(
-        keyRulers, rulers.map((r) => r.toString()).toList());
-    await prefs.setBool(keyStickyScroll, stickyScroll);
-    await prefs.setString(keyShowFoldingControls, showFoldingControls);
-    await prefs.setBool(keyGlyphMargin, glyphMargin);
-    await prefs.setString(keyRenderLineHighlight, renderLineHighlight);
-
-    // Editor Behavior
-    await prefs.setString(keyWordWrap, wordWrap.name);
-    await prefs.setInt(keyWordWrapColumn, wordWrapColumn);
-    await prefs.setInt(keyTabSize, tabSize);
-    await prefs.setBool(keyInsertSpaces, insertSpaces);
-    await prefs.setString(keyAutoIndent, autoIndent);
-    await prefs.setString(keyAutoClosingBrackets, autoClosingBrackets);
-    await prefs.setString(keyAutoClosingQuotes, autoClosingQuotes);
-    await prefs.setString(keyAutoSurround, autoSurround);
-    await prefs.setBool(keyBracketPairColorization, bracketPairColorization);
-    await prefs.setBool(keyCodeFolding, codeFolding);
-    await prefs.setBool(keyScrollBeyondLastLine, scrollBeyondLastLine);
-    await prefs.setBool(keySmoothScrolling, smoothScrolling);
-    await prefs.setDouble(keyFastScrollSensitivity, fastScrollSensitivity);
-    await prefs.setBool(keyScrollPredominantAxis, scrollPredominantAxis);
-
-    // Cursor
-    await prefs.setString(keyCursorBlinking, cursorBlinking.name);
-    await prefs.setString(
-        keyCursorSmoothCaretAnimation, cursorSmoothCaretAnimation);
-    await prefs.setString(keyCursorStyle, cursorStyle.name);
-    await prefs.setInt(keyCursorWidth, cursorWidth);
-    await prefs.setString(keyMultiCursorModifier, multiCursorModifier.name);
-    await prefs.setBool(
-        keyMultiCursorMergeOverlapping, multiCursorMergeOverlapping);
-
-    // Editing Features
-    await prefs.setBool(keyFormatOnSave, formatOnSave);
-    await prefs.setBool(keyFormatOnPaste, formatOnPaste);
-    await prefs.setBool(keyFormatOnType, formatOnType);
-    await prefs.setBool(keyQuickSuggestions, quickSuggestions);
-    await prefs.setInt(keyQuickSuggestionsDelay, quickSuggestionsDelay);
-    await prefs.setBool(
-        keySuggestOnTriggerCharacters, suggestOnTriggerCharacters);
-    await prefs.setString(
-        keyAcceptSuggestionOnEnter, acceptSuggestionOnEnter.name);
-    await prefs.setBool(keyAcceptSuggestionOnCommitCharacter,
-        acceptSuggestionOnCommitCharacter);
-    await prefs.setString(keySnippetSuggestions, snippetSuggestions.name);
-    await prefs.setString(keyWordBasedSuggestions, wordBasedSuggestions.name);
-    await prefs.setBool(keyParameterHints, parameterHints);
-    await prefs.setBool(keyHover, hover);
-    await prefs.setBool(keyContextMenu, contextMenu);
-
-    // Find & Replace
-    await prefs.setBool(keyFind, find);
-    await prefs.setString(
-        keySeedSearchStringFromSelection, seedSearchStringFromSelection);
-
-    // Accessibility
-    await prefs.setString(keyAccessibilitySupport, accessibilitySupport.name);
-    await prefs.setInt(keyAccessibilityPageSize, accessibilityPageSize);
-
-    // Performance
-    await prefs.setString(
-        keyRenderValidationDecorations, renderValidationDecorations);
-    await prefs.setBool(keyRenderControlCharacters, renderControlCharacters);
-    await prefs.setBool(keyDisableLayerHinting, disableLayerHinting);
-    await prefs.setBool(
-        keyDisableMonospaceOptimizations, disableMonospaceOptimizations);
-    await prefs.setInt(keyMaxTokenizationLineLength, maxTokenizationLineLength);
-
-    // Language Configs (as JSON)
-    final langConfigsJson = <String, Map<String, dynamic>>{};
-    for (final entry in languageConfigs.entries) {
-      langConfigsJson[entry.key] = entry.value.toJson();
-    }
-    await prefs.setString(keyLanguageConfigs, langConfigsJson.encode());
-
-    // Keybindings
-    await prefs.setString(keyKeybindingPreset, keybindingPreset.name);
-    await prefs.setString(keyCustomKeybindings, customKeybindings.encode());
-
-    // Advanced
-    await prefs.setBool(keyReadOnly, readOnly);
-    await prefs.setBool(keyDomReadOnly, domReadOnly);
-    await prefs.setBool(keyDragAndDrop, dragAndDrop);
-    await prefs.setBool(keyLinks, links);
-    await prefs.setBool(keyMouseWheelZoom, mouseWheelZoom);
-    await prefs.setDouble(
-        keyMouseWheelScrollSensitivity, mouseWheelScrollSensitivity);
-    await prefs.setBool(keyAutomaticLayout, automaticLayout);
-    await prefs.setString(keyPadding, padding.encode());
-    await prefs.setBool(keyRoundedSelection, roundedSelection);
-    await prefs.setBool(keySelectionHighlight, selectionHighlight);
-    await prefs.setString(keyOccurrencesHighlight, occurrencesHighlight);
-    await prefs.setBool(keyOverviewRulerBorder, overviewRulerBorder);
-    await prefs.setBool(
-        keyHideCursorInOverviewRuler, hideCursorInOverviewRuler);
-    await prefs.setString(keyScrollbar, scrollbar.encode());
-    await prefs.setString(
-        keyExperimentalFeatures, experimentalFeatures.encode());
-  }
-
-  /// Load all settings from SharedPreferences
-  static Future<EditorSettings> load() async {
-    final prefs = await SharedPreferences.getInstance();
-
-    // Helper functions for enum parsing
-    T? parseEnum<T extends Enum>(String? value, List<T> values) {
-      if (value == null) return null;
-      try {
-        return values.firstWhere((e) => e.name == value);
-      } catch (e) {
-        return null;
-      }
-    }
-
-    // Parse language configs
-    final parsedLanguageConfigs = <String, LanguageConfig>{};
-    final langConfigsString = prefs.getString(keyLanguageConfigs);
-    if (langConfigsString != null) {
-      try {
-        final langConfigsJson =
-            langConfigsString.decode() as Map<String, dynamic>? ?? {};
-        for (final entry in langConfigsJson.entries) {
-          if (entry.value is Map<String, dynamic>) {
-            parsedLanguageConfigs[entry.key] =
-                LanguageConfig.fromJson(entry.value as Map<String, dynamic>);
-          }
-        }
-      } catch (e) {
-        // Ignore parsing errors, use empty map
-        if (kDebugMode) {
-          print('Error parsing language configs from SharedPreferences: $e');
-        }
-      }
-    }
-
-    return EditorSettings(
-      // General
-      theme: prefs.getString(keyTheme) ?? defaultTheme,
-      fontSize: prefs.getDouble(keyFontSize) ?? defaultFontSize,
-      fontFamily: prefs.getString(keyFontFamily) ?? defaultFontFamily,
-      lineHeight: prefs.getDouble(keyLineHeight) ?? defaultLineHeight,
-      letterSpacing: prefs.getDouble(keyLetterSpacing) ?? defaultLetterSpacing,
-
-      // Display
-      showLineNumbers:
-          prefs.getBool(keyShowLineNumbers) ?? defaultShowLineNumbers,
-      lineNumbersStyle: parseEnum(
-              prefs.getString(keyLineNumbersStyle), LineNumbersStyle.values) ??
-          defaultLineNumbersStyle,
-      showMinimap: prefs.getBool(keyShowMinimap) ?? defaultShowMinimap,
-      minimapSide:
-          parseEnum(prefs.getString(keyMinimapSide), MinimapSide.values) ??
-              defaultMinimapSide,
-      minimapRenderCharacters: prefs.getBool(keyMinimapRenderCharacters) ??
-          defaultMinimapRenderCharacters,
-      minimapSize: prefs.getInt(keyMinimapSize) ?? defaultMinimapSize,
-      showIndentGuides:
-          prefs.getBool(keyShowIndentGuides) ?? defaultShowIndentGuides,
-      renderWhitespace: parseEnum(
-              prefs.getString(keyRenderWhitespace), RenderWhitespace.values) ??
-          defaultRenderWhitespace,
-      rulers: prefs
-              .getStringList(keyRulers)
-              ?.map((s) => int.tryParse(s) ?? 0)
-              .where((i) => i > 0)
-              .toList() ??
-          defaultRulers,
-      stickyScroll: prefs.getBool(keyStickyScroll) ?? defaultStickyScroll,
-      showFoldingControls:
-          prefs.getString(keyShowFoldingControls) ?? defaultShowFoldingControls,
-      glyphMargin: prefs.getBool(keyGlyphMargin) ?? defaultGlyphMargin,
-      renderLineHighlight:
-          prefs.getString(keyRenderLineHighlight) ?? defaultRenderLineHighlight,
-
-      // Editor Behavior
-      wordWrap: parseEnum(prefs.getString(keyWordWrap), WordWrap.values) ??
-          defaultWordWrap,
-      wordWrapColumn: prefs.getInt(keyWordWrapColumn) ?? defaultWordWrapColumn,
-      tabSize: prefs.getInt(keyTabSize) ?? defaultTabSize,
-      insertSpaces: prefs.getBool(keyInsertSpaces) ?? defaultInsertSpaces,
-      autoIndent: prefs.getString(keyAutoIndent) ?? defaultAutoIndent,
-      autoClosingBrackets:
-          prefs.getString(keyAutoClosingBrackets) ?? defaultAutoClosingBrackets,
-      autoClosingQuotes:
-          prefs.getString(keyAutoClosingQuotes) ?? defaultAutoClosingQuotes,
-      autoSurround: prefs.getString(keyAutoSurround) ?? defaultAutoSurround,
-      bracketPairColorization: prefs.getBool(keyBracketPairColorization) ??
-          defaultBracketPairColorization,
-      codeFolding: prefs.getBool(keyCodeFolding) ?? defaultCodeFolding,
-      scrollBeyondLastLine:
-          prefs.getBool(keyScrollBeyondLastLine) ?? defaultScrollBeyondLastLine,
-      smoothScrolling:
-          prefs.getBool(keySmoothScrolling) ?? defaultSmoothScrolling,
-      fastScrollSensitivity: prefs.getDouble(keyFastScrollSensitivity) ??
-          defaultFastScrollSensitivity,
-      scrollPredominantAxis: prefs.getBool(keyScrollPredominantAxis) ??
-          defaultScrollPredominantAxis,
-
-      // Cursor
-      cursorBlinking: parseEnum(
-              prefs.getString(keyCursorBlinking), CursorBlinking.values) ??
-          defaultCursorBlinking,
-      cursorSmoothCaretAnimation:
-          prefs.getString(keyCursorSmoothCaretAnimation) ??
-              defaultCursorSmoothCaretAnimation,
-      cursorStyle:
-          parseEnum(prefs.getString(keyCursorStyle), CursorStyle.values) ??
-              defaultCursorStyle,
-      cursorWidth: prefs.getInt(keyCursorWidth) ?? defaultCursorWidth,
-      multiCursorModifier: parseEnum(prefs.getString(keyMultiCursorModifier),
-              MultiCursorModifier.values) ??
-          defaultMultiCursorModifier,
-      multiCursorMergeOverlapping:
-          prefs.getBool(keyMultiCursorMergeOverlapping) ??
-              defaultMultiCursorMergeOverlapping,
-
-      // Editing Features
-      formatOnSave: prefs.getBool(keyFormatOnSave) ?? defaultFormatOnSave,
-      formatOnPaste: prefs.getBool(keyFormatOnPaste) ?? defaultFormatOnPaste,
-      formatOnType: prefs.getBool(keyFormatOnType) ?? defaultFormatOnType,
-      quickSuggestions:
-          prefs.getBool(keyQuickSuggestions) ?? defaultQuickSuggestions,
-      quickSuggestionsDelay: prefs.getInt(keyQuickSuggestionsDelay) ??
-          defaultQuickSuggestionsDelay,
-      suggestOnTriggerCharacters:
-          prefs.getBool(keySuggestOnTriggerCharacters) ??
-              defaultSuggestOnTriggerCharacters,
-      acceptSuggestionOnEnter: parseEnum(
-              prefs.getString(keyAcceptSuggestionOnEnter),
-              AcceptSuggestionOnEnter.values) ??
-          defaultAcceptSuggestionOnEnter,
-      acceptSuggestionOnCommitCharacter:
-          prefs.getBool(keyAcceptSuggestionOnCommitCharacter) ??
-              defaultAcceptSuggestionOnCommitCharacter,
-      snippetSuggestions: parseEnum(prefs.getString(keySnippetSuggestions),
-              SnippetSuggestions.values) ??
-          defaultSnippetSuggestions,
-      wordBasedSuggestions: parseEnum(prefs.getString(keyWordBasedSuggestions),
-              WordBasedSuggestions.values) ??
-          defaultWordBasedSuggestions,
-      parameterHints: prefs.getBool(keyParameterHints) ?? defaultParameterHints,
-      hover: prefs.getBool(keyHover) ?? defaultHover,
-      contextMenu: prefs.getBool(keyContextMenu) ?? defaultContextMenu,
-
-      // Find & Replace
-      find: prefs.getBool(keyFind) ?? defaultFind,
-      seedSearchStringFromSelection:
-          prefs.getString(keySeedSearchStringFromSelection) ??
-              defaultSeedSearchStringFromSelection,
-
-      // Accessibility
-      accessibilitySupport: parseEnum(prefs.getString(keyAccessibilitySupport),
-              AccessibilitySupport.values) ??
-          defaultAccessibilitySupport,
-      accessibilityPageSize: prefs.getInt(keyAccessibilityPageSize) ??
-          defaultAccessibilityPageSize,
-
-      // Performance
-      renderValidationDecorations:
-          prefs.getString(keyRenderValidationDecorations) ??
-              defaultRenderValidationDecorations,
-      renderControlCharacters: prefs.getBool(keyRenderControlCharacters) ??
-          defaultRenderControlCharacters,
-      disableLayerHinting:
-          prefs.getBool(keyDisableLayerHinting) ?? defaultDisableLayerHinting,
-      disableMonospaceOptimizations:
-          prefs.getBool(keyDisableMonospaceOptimizations) ??
-              defaultDisableMonospaceOptimizations,
-      maxTokenizationLineLength: prefs.getInt(keyMaxTokenizationLineLength) ??
-          defaultMaxTokenizationLineLength,
-
-      // Language Configs
-      languageConfigs: parsedLanguageConfigs,
-
-      // Keybindings
-      keybindingPreset: parseEnum(prefs.getString(keyKeybindingPreset),
-              KeybindingPresetEnum.values) ??
-          defaultKeybindingPreset,
-      customKeybindings: ConvertObject.toMap(
-          prefs.getString(keyCustomKeybindings),
-          defaultValue: {}),
-
-      // Advanced
-      readOnly: prefs.getBool(keyReadOnly) ?? defaultReadOnly,
-      domReadOnly: prefs.getBool(keyDomReadOnly) ?? defaultDomReadOnly,
-      dragAndDrop: prefs.getBool(keyDragAndDrop) ?? defaultDragAndDrop,
-      links: prefs.getBool(keyLinks) ?? defaultLinks,
-      mouseWheelZoom: prefs.getBool(keyMouseWheelZoom) ?? defaultMouseWheelZoom,
-      mouseWheelScrollSensitivity:
-          prefs.getDouble(keyMouseWheelScrollSensitivity) ??
-              defaultMouseWheelScrollSensitivity,
-      automaticLayout:
-          prefs.getBool(keyAutomaticLayout) ?? defaultAutomaticLayout,
-      padding: (prefs.getString(keyPadding)?.decode() as Map<String, dynamic>?)
-              ?.map(
-                  (key, value) => MapEntry(key, ConvertObject.toInt(value))) ??
-          defaultPadding,
-      roundedSelection:
-          prefs.getBool(keyRoundedSelection) ?? defaultRoundedSelection,
-      selectionHighlight:
-          prefs.getBool(keySelectionHighlight) ?? defaultSelectionHighlight,
-      occurrencesHighlight: prefs.getString(keyOccurrencesHighlight) ??
-          defaultOccurrencesHighlight,
-      overviewRulerBorder:
-          prefs.getBool(keyOverviewRulerBorder) ?? defaultOverviewRulerBorder,
-      hideCursorInOverviewRuler: prefs.getBool(keyHideCursorInOverviewRuler) ??
-          defaultHideCursorInOverviewRuler,
-      scrollbar: prefs.getString(keyScrollbar)?.decode()
-              as Map<String, dynamic>? ?? // Cast to Map<String, dynamic>
-          defaultScrollbar,
-      experimentalFeatures: prefs.getString(keyExperimentalFeatures)?.decode()
-              as Map<String, dynamic>? ?? // Cast to Map<String, dynamic>
-          {},
-    );
-  }
-
-  @override
-  String toString() => 'EditorSettings('
-      'theme: $theme, '
-      'fontSize: $fontSize, '
-      'fontFamily: $fontFamily, '
-      'showLineNumbers: $showLineNumbers, '
-      'showMinimap: $showMinimap, '
-      'wordWrap: $wordWrap, '
-      'tabSize: $tabSize, '
-      'readOnly: $readOnly'
-      ')';
-
-  @override
-  List<Object?> get props => [
-        theme,
-        fontSize,
-        fontFamily,
-        lineHeight,
-        letterSpacing,
-        showLineNumbers,
-        lineNumbersStyle,
-        showMinimap,
-        minimapSide,
-        minimapRenderCharacters,
-        minimapSize,
-        showIndentGuides,
-        renderWhitespace,
-        rulers,
-        stickyScroll,
-        showFoldingControls,
-        glyphMargin,
-        renderLineHighlight,
-        wordWrap,
-        wordWrapColumn,
-        tabSize,
-        insertSpaces,
-        autoIndent,
-        autoClosingBrackets,
-        autoClosingQuotes,
-        autoSurround,
-        bracketPairColorization,
-        codeFolding,
-        scrollBeyondLastLine,
-        smoothScrolling,
-        readOnly,
-      ];
-}
diff --git a/lib/src/features/editor/domain/monaco_data.dart b/lib/src/features/editor/domain/monaco_data.dart
deleted file mode 100644
index 11f62a3..0000000
--- a/lib/src/features/editor/domain/monaco_data.dart
+++ /dev/null
@@ -1,99 +0,0 @@
-abstract class MonacoData {
-// Available themes
-  static const List<String> availableThemes = [
-    'vs',
-    'vs-dark',
-    'hc-black',
-    'one-dark-pro',
-    'one-dark-pro-transparent',
-  ];
-
-  // Available languages from your languages.js file
-  static const List<Map<String, String>> availableLanguages = [
-    {'value': 'plaintext', 'text': 'Plain Text'},
-    {'value': 'abap', 'text': 'ABAP'},
-    {'value': 'apex', 'text': 'Apex'},
-    {'value': 'azcli', 'text': 'Azure CLI'},
-    {'value': 'bat', 'text': 'Batch'},
-    {'value': 'bicep', 'text': 'Bicep'},
-    {'value': 'cameligo', 'text': 'Cameligo'},
-    {'value': 'clojure', 'text': 'Clojure'},
-    {'value': 'coffeescript', 'text': 'CoffeeScript'},
-    {'value': 'c', 'text': 'C'},
-    {'value': 'cpp', 'text': 'C++'},
-    {'value': 'csharp', 'text': 'C#'},
-    {'value': 'csp', 'text': 'CSP'},
-    {'value': 'css', 'text': 'CSS'},
-    {'value': 'cypher', 'text': 'Cypher'},
-    {'value': 'dart', 'text': 'Dart'},
-    {'value': 'dockerfile', 'text': 'Dockerfile'},
-    {'value': 'ecl', 'text': 'ECL'},
-    {'value': 'elixir', 'text': 'Elixir'},
-    {'value': 'flow9', 'text': 'Flow9'},
-    {'value': 'fsharp', 'text': 'F#'},
-    {'value': 'freemarker2', 'text': 'Freemarker2'},
-    {'value': 'go', 'text': 'Go'},
-    {'value': 'graphql', 'text': 'GraphQL'},
-    {'value': 'handlebars', 'text': 'Handlebars'},
-    {'value': 'hcl', 'text': 'HCL'},
-    {'value': 'html', 'text': 'HTML'},
-    {'value': 'ini', 'text': 'INI'},
-    {'value': 'java', 'text': 'Java'},
-    {'value': 'javascript', 'text': 'JavaScript'},
-    {'value': 'julia', 'text': 'Julia'},
-    {'value': 'kotlin', 'text': 'Kotlin'},
-    {'value': 'less', 'text': 'Less'},
-    {'value': 'lexon', 'text': 'Lexon'},
-    {'value': 'lua', 'text': 'Lua'},
-    {'value': 'liquid', 'text': 'Liquid'},
-    {'value': 'm3', 'text': 'M3'},
-    {'value': 'markdown', 'text': 'Markdown'},
-    {'value': 'mdx', 'text': 'MDX'},
-    {'value': 'mips', 'text': 'MIPS'},
-    {'value': 'msdax', 'text': 'MSDAX'},
-    {'value': 'mysql', 'text': 'MySQL'},
-    {'value': 'objective-c', 'text': 'Objective-C'},
-    {'value': 'pascal', 'text': 'Pascal'},
-    {'value': 'pascaligo', 'text': 'Pascaligo'},
-    {'value': 'perl', 'text': 'Perl'},
-    {'value': 'pgsql', 'text': 'PostgreSQL'},
-    {'value': 'php', 'text': 'PHP'},
-    {'value': 'pla', 'text': 'PLA'},
-    {'value': 'postiats', 'text': 'Postiats'},
-    {'value': 'powerquery', 'text': 'Power Query'},
-    {'value': 'powershell', 'text': 'PowerShell'},
-    {'value': 'proto', 'text': 'Protocol Buffers'},
-    {'value': 'pug', 'text': 'Pug'},
-    {'value': 'python', 'text': 'Python'},
-    {'value': 'qsharp', 'text': 'Q#'},
-    {'value': 'r', 'text': 'R'},
-    {'value': 'razor', 'text': 'Razor'},
-    {'value': 'redis', 'text': 'Redis'},
-    {'value': 'redshift', 'text': 'Redshift'},
-    {'value': 'restructuredtext', 'text': 'reStructuredText'},
-    {'value': 'ruby', 'text': 'Ruby'},
-    {'value': 'rust', 'text': 'Rust'},
-    {'value': 'sb', 'text': 'Small Basic'},
-    {'value': 'scala', 'text': 'Scala'},
-    {'value': 'scheme', 'text': 'Scheme'},
-    {'value': 'scss', 'text': 'SCSS'},
-    {'value': 'shell', 'text': 'Shell Script'},
-    {'value': 'sol', 'text': 'Solidity'},
-    {'value': 'aes', 'text': 'AES'},
-    {'value': 'sparql', 'text': 'SPARQL'},
-    {'value': 'sql', 'text': 'SQL'},
-    {'value': 'st', 'text': 'Structured Text'},
-    {'value': 'swift', 'text': 'Swift'},
-    {'value': 'systemverilog', 'text': 'SystemVerilog'},
-    {'value': 'verilog', 'text': 'Verilog'},
-    {'value': 'tcl', 'text': 'Tcl'},
-    {'value': 'twig', 'text': 'Twig'},
-    {'value': 'typescript', 'text': 'TypeScript'},
-    {'value': 'typespec', 'text': 'TypeSpec'},
-    {'value': 'vb', 'text': 'Visual Basic'},
-    {'value': 'wgsl', 'text': 'WGSL'},
-    {'value': 'xml', 'text': 'XML'},
-    {'value': 'yaml', 'text': 'YAML'},
-    {'value': 'json', 'text': 'JSON'},
-  ];
-}
diff --git a/lib/src/features/editor/domain/monaco_scripts.dart b/lib/src/features/editor/domain/monaco_scripts.dart
deleted file mode 100644
index 6bc96c3..0000000
--- a/lib/src/features/editor/domain/monaco_scripts.dart
+++ /dev/null
@@ -1,2 +0,0 @@
-/// this files will contain the monaco editor scripts used in the editor feature
-class MonacoScripts {}
diff --git a/lib/src/features/editor/editor.dart b/lib/src/features/editor/editor.dart
index 3989763..8217d76 100644
--- a/lib/src/features/editor/editor.dart
+++ b/lib/src/features/editor/editor.dart
@@ -1,13 +1,34 @@
-// Enhanced Editor Feature Exports
+// Editor Feature Exports
 // This file provides a clean interface to all editor functionality
 
-export 'bridge/monaco_bridge_platform.dart';
-export 'domain/editor_settings.dart';
-export 'domain/keybinding_manager.dart';
-export 'domain/theme_manager.dart';
-export 'presentation/ui/editor_screen.dart';
-export 'presentation/ui/enhanced_editor_settings_dialog.dart';
-export 'presentation/ui/global_monaco_container.dart';
-export 'presentation/ui/monaco_editor_container.dart';
-export 'presentation/ui/monaco_editor_info_bar.dart';
-export 'presentation/ui/monaco_editor_integrated.dart';
+export '../../shared/widgets/resizable_splitter.dart';
+// Bridge
+export 'bridge/bridge.dart';
+export 'bridge/webview_controller.dart';
+// Core
+export 'core/actions/monaco_editor_actions.dart';
+export 'core/model/editor_constants.dart';
+export 'core/model/editor_settings.dart';
+export 'core/model/keybinding_manager.dart';
+export 'core/model/theme_manager.dart';
+export 'core/scripts/monaco_scripts.dart';
+// Data
+export 'data/monaco_service.dart';
+export 'data/providers.dart';
+export 'data/settings_service.dart';
+// Platform
+export 'platform/webview_platform_utils.dart';
+// UI - Dialogs
+export 'ui/dialogs/language_settings_dialog.dart';
+export 'ui/dialogs/settings_dialog.dart';
+export 'ui/dialogs/tabs/tabs.dart';
+// UI - Screens
+export 'ui/screens/editor_screen.dart';
+// UI - Widgets
+export 'ui/widgets/info_bar/info_bar_widgets.dart';
+export 'ui/widgets/monaco_container.dart';
+export 'ui/widgets/monaco_editor_container.dart';
+export 'ui/widgets/monaco_editor_integrated.dart';
+export 'ui/widgets/quick_sidebar/quick_sidebar_widgets.dart';
+export 'ui/widgets/settings/form_fields.dart';
+export 'ui/widgets/settings/settings_widgets.dart';
diff --git a/lib/src/features/editor/utils/webview_platform_utils.dart b/lib/src/features/editor/platform/webview_platform_utils.dart
similarity index 83%
rename from lib/src/features/editor/utils/webview_platform_utils.dart
rename to lib/src/features/editor/platform/webview_platform_utils.dart
index 9964b9e..c765d15 100644
--- a/lib/src/features/editor/utils/webview_platform_utils.dart
+++ b/lib/src/features/editor/platform/webview_platform_utils.dart
@@ -1,7 +1,6 @@
 // lib/src/features/editor/utils/webview_platform_utils.dart
 import 'dart:io';
 
-import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
 import 'package:url_launcher/url_launcher.dart';
 import 'package:webview_windows/webview_windows.dart' as ww;
@@ -134,7 +133,8 @@ class WebViewPlatformUtils {
       }
     } catch (e) {
       debugPrint(
-          '[WebViewPlatformUtils] Error launching WebView2 download: $e');
+        '[WebViewPlatformUtils] Error launching WebView2 download: $e',
+      );
     }
   }
 
@@ -164,12 +164,75 @@ class WebViewPlatformUtils {
         if (info?.isSupported ?? false) {
           return child;
         } else {
+          // For Windows with missing WebView2, show special handling
+          if (Platform.isWindows && !(info?.isSupported ?? false)) {
+            return _buildWebView2MissingScreen(context, info);
+          }
           return _buildUnsupportedPlatform(info);
         }
       },
     );
   }
 
+  static Widget _buildWebView2MissingScreen(
+    BuildContext context,
+    WebViewPlatformInfo? info,
+  ) {
+    final theme = Theme.of(context);
+
+    return Scaffold(
+      body: Center(
+        child: Padding(
+          padding: const EdgeInsets.all(32),
+          child: Column(
+            mainAxisAlignment: MainAxisAlignment.center,
+            children: [
+              const Icon(
+                Icons.warning_amber_rounded,
+                size: 64,
+                color: Colors.orange,
+              ),
+              const SizedBox(height: 16),
+              Text(
+                'WebView2 Runtime Required',
+                style: theme.textTheme.headlineMedium?.copyWith(
+                  fontWeight: FontWeight.bold,
+                ),
+              ),
+              const SizedBox(height: 8),
+              const Text(
+                'Context Collector requires Microsoft Edge WebView2 Runtime to function on Windows.',
+                textAlign: TextAlign.center,
+              ),
+              const SizedBox(height: 24),
+              FilledButton.icon(
+                onPressed: () => showWebView2InstallDialog(context),
+                icon: const Icon(Icons.download),
+                label: const Text('Install WebView2 Runtime'),
+              ),
+              const SizedBox(height: 8),
+              TextButton.icon(
+                onPressed: () async {
+                  // Restart the app check
+                  final newInfo = await getPlatformInfo();
+                  if (newInfo.isSupported && context.mounted) {
+                    // Trigger app restart
+                    await Navigator.of(context).pushNamedAndRemoveUntil(
+                      '/',
+                      (route) => false,
+                    );
+                  }
+                },
+                icon: const Icon(Icons.refresh),
+                label: const Text('Recheck After Installation'),
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+
   static Widget _buildUnsupportedPlatform(WebViewPlatformInfo? info) {
     return Builder(
       builder: (context) {
@@ -290,28 +353,6 @@ class WebViewPlatformUtils {
       },
     );
   }
-
-  /// Check if running in development/debug mode
-  static bool get isDebugMode => kDebugMode;
-
-  /// Get platform-specific debugging information
-  static Future<Map<String, dynamic>> getDebugInfo() async {
-    final info = await getPlatformInfo();
-
-    return {
-      'platform': info.platform,
-      'isSupported': info.isSupported,
-      'engine': info.engine,
-      'version': info.version,
-      'error': info.error,
-      'requirements': info.requirements,
-      'isDarkMode':
-          WidgetsBinding.instance.platformDispatcher.platformBrightness ==
-              Brightness.dark,
-      'isDebugMode': isDebugMode,
-      'dartVersion': Platform.version,
-    };
-  }
 }
 
 /// Information about WebView platform support
diff --git a/lib/src/features/editor/presentation/ui/editor_screen.dart b/lib/src/features/editor/presentation/ui/editor_screen.dart
deleted file mode 100644
index e4df11f..0000000
--- a/lib/src/features/editor/presentation/ui/editor_screen.dart
+++ /dev/null
@@ -1,801 +0,0 @@
-// lib/src/features/editor/presentation/ui/editor_screen.dart
-import 'dart:io';
-
-import 'package:context_collector/src/features/editor/domain/editor_settings.dart';
-import 'package:context_collector/src/features/editor/presentation/ui/enhanced_editor_settings_dialog.dart';
-import 'package:context_collector/src/features/editor/presentation/ui/monaco_editor_container.dart';
-import 'package:context_collector/src/features/editor/presentation/ui/monaco_editor_info_bar.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_providers.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_state.dart';
-import 'package:context_collector/src/features/scan/presentation/state/selection_notifier.dart';
-import 'package:context_collector/src/features/scan/presentation/ui/action_buttons_widget.dart';
-import 'package:context_collector/src/features/scan/presentation/ui/file_list_widget.dart';
-import 'package:context_collector/src/features/settings/presentation/ui/settings_screen.dart';
-import 'package:context_collector/src/shared/shared.dart';
-import 'package:context_collector/src/shared/utils/drop_file_resolver.dart';
-import 'package:context_collector/src/shared/utils/vscode_drop_detector.dart';
-import 'package:desktop_drop/desktop_drop.dart';
-import 'package:enefty_icons/enefty_icons.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-/// Complete editor screen with file list and Monaco editor
-/// This is the bottom layer in the layered architecture
-class EditorScreen extends ConsumerStatefulWidget {
-  const EditorScreen({super.key});
-
-  @override
-  ConsumerState<EditorScreen> createState() => _EditorScreenState();
-}
-
-class _EditorScreenState extends ConsumerState<EditorScreen>
-    with SingleTickerProviderStateMixin {
-  // Animation controllers for sidebar
-  late AnimationController _sidebarAnimationController;
-  late Animation<double> _sidebarAnimation;
-  bool _isSidebarExpanded = false;
-  bool _isDragging = false;
-
-  // Settings state
-  EditorSettings _editorSettings = const EditorSettings();
-  bool _hasAppliedInitialSettings = false;
-
-  // Sidebar dimensions
-  static const double _expandedSidebarWidth = 280;
-
-  @override
-  void initState() {
-    super.initState();
-
-    // Initialize animations
-    _sidebarAnimationController = AnimationController(
-      duration: const Duration(milliseconds: 300),
-      vsync: this,
-    );
-    _sidebarAnimation = CurvedAnimation(
-      parent: _sidebarAnimationController,
-      curve: Curves.easeInOutCubic,
-    );
-
-    // Load saved editor settings
-    _loadEditorSettings();
-  }
-
-  @override
-  void dispose() {
-    _sidebarAnimationController.dispose();
-    super.dispose();
-  }
-
-  Future<void> _loadEditorSettings() async {
-    final settings = await EditorSettings.load();
-    if (mounted) {
-      setState(() {
-        _editorSettings = settings;
-      });
-    }
-  }
-
-  Future<void> _applySettingsToEditor() async {
-    final editorService = ref.read(monacoEditorServiceProvider);
-    await editorService.applySettings(_editorSettings);
-  }
-
-  Future<void> _saveAndApplySettings(EditorSettings newSettings) async {
-    setState(() {
-      _editorSettings = newSettings;
-    });
-    await newSettings.save();
-    await _applySettingsToEditor();
-  }
-
-  void _toggleSidebar() {
-    setState(() {
-      _isSidebarExpanded = !_isSidebarExpanded;
-      if (_isSidebarExpanded) {
-        _sidebarAnimationController.forward();
-      } else {
-        _sidebarAnimationController.reverse();
-      }
-    });
-  }
-
-  Future<void> _increaseFontSize() async {
-    if (_editorSettings.fontSize < 32) {
-      final newSettings =
-          _editorSettings.copyWith(fontSize: _editorSettings.fontSize + 1);
-      await _saveAndApplySettings(newSettings);
-    }
-  }
-
-  Future<void> _decreaseFontSize() async {
-    if (_editorSettings.fontSize > 8) {
-      final newSettings =
-          _editorSettings.copyWith(fontSize: _editorSettings.fontSize - 1);
-      await _saveAndApplySettings(newSettings);
-    }
-  }
-
-  Future<void> _toggleWordWrap() async {
-    final newWrap =
-        _editorSettings.wordWrap == WordWrap.off ? WordWrap.on : WordWrap.off;
-    final newSettings = _editorSettings.copyWith(wordWrap: newWrap);
-    await _saveAndApplySettings(newSettings);
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final selectionState = ref.watch(selectionProvider);
-    final selectionNotifier = ref.read(selectionProvider.notifier);
-    final editorStatus = ref.watch(monacoEditorStatusProvider);
-
-    // Listen for editor ready state to apply initial settings
-    ref.listen<MonacoEditorStatus>(monacoEditorStatusProvider,
-        (previous, next) {
-      if (!_hasAppliedInitialSettings && next.isReady) {
-        _hasAppliedInitialSettings = true;
-        _applySettingsToEditor();
-      }
-    });
-
-    return Scaffold(
-      backgroundColor: context.surface,
-      appBar: AppBar(
-        title: Row(
-          mainAxisAlignment: MainAxisAlignment.center,
-          children: [
-            Container(
-              padding: const EdgeInsets.all(8),
-              decoration: BoxDecoration(
-                gradient: LinearGradient(
-                  colors: [
-                    context.primary,
-                    context.primary.addOpacity(0.8),
-                  ],
-                ),
-                borderRadius: BorderRadius.circular(10),
-              ),
-              child: const Icon(
-                Icons.collections_bookmark_rounded,
-                color: Colors.white,
-                size: 20,
-              ),
-            ),
-            const SizedBox(width: 12),
-            const Text('Context Collector'),
-          ],
-        ),
-        centerTitle: true,
-        actions: [
-          Row(
-            mainAxisSize: MainAxisSize.min,
-            children: [
-              AnimatedScale(
-                scale: selectionState.hasFiles ? 1.0 : 0.0,
-                duration: const Duration(milliseconds: 200),
-                child: IconButton(
-                  onPressed: selectionState.hasFiles
-                      ? selectionNotifier.clearFiles
-                      : null,
-                  icon: const Icon(Icons.clear_all_rounded),
-                  tooltip: 'Clear all files',
-                  style: IconButton.styleFrom(
-                    backgroundColor: context.error.addOpacity(0.1),
-                    foregroundColor: context.error,
-                  ),
-                  splashRadius: 0.1,
-                  highlightColor: Colors.transparent,
-                  splashColor: Colors.transparent,
-                  hoverColor: context.error.addOpacity(0.05),
-                ),
-              ),
-              const SizedBox(width: 8),
-            ],
-          ),
-          IconButton(
-            onPressed: () {
-              Navigator.push(
-                context,
-                MaterialPageRoute<void>(
-                  builder: (context) => const SettingsScreen(),
-                ),
-              );
-            },
-            icon: const Icon(Icons.settings_rounded),
-            tooltip: 'Settings',
-            splashRadius: 0.1,
-            highlightColor: Colors.transparent,
-            splashColor: Colors.transparent,
-            hoverColor: context.onSurface.addOpacity(0.04),
-          ),
-          const SizedBox(width: 8),
-        ],
-      ),
-      body: DropTarget(
-        onDragEntered: (details) {
-          setState(() => _isDragging = true);
-        },
-        onDragExited: (details) {
-          setState(() => _isDragging = false);
-        },
-        onDragDone: (details) async {
-          setState(() => _isDragging = false);
-
-          final files = <String>[];
-          final directories = <String>[];
-
-          for (final file in details.files) {
-            final filePath = file.path;
-
-            // Check if this is a VS Code directory drop
-            if (filePath.contains('/tmp/Drops/')) {
-              try {
-                // Try to read as VS Code directory listing
-                final content = await File(filePath).readAsString();
-                final directoryPath =
-                    VSCodeDropDetector.extractDirectoryPath(content);
-
-                if (directoryPath != null) {
-                  // Just add the directory path and let normal error handling deal with permissions
-                  directories.add(directoryPath);
-                  continue;
-                }
-              } catch (_) {
-                // Not a VS Code directory listing, process normally
-              }
-            }
-
-            // Handle typed drops (desktop_drop 0.6.0+)
-            if (file is DropItemDirectory) {
-              directories.add(filePath);
-            } else if (file is DropItemFile) {
-              // JetBrains workaround: Check if this "file" is actually a directory
-              // JetBrains incorrectly reports directories as DropItemFile
-              final checkType = FileSystemEntity.typeSync(filePath);
-              if (checkType == FileSystemEntityType.directory) {
-                directories.add(filePath);
-              } else {
-                files.add(filePath);
-              }
-            } else {
-              // Fallback for regular XFile - use filesystem check
-              final entity = FileSystemEntity.typeSync(filePath);
-              if (entity == FileSystemEntityType.directory) {
-                directories.add(filePath);
-              } else if (entity == FileSystemEntityType.file) {
-                files.add(filePath);
-              } else if (DropFileResolver.isTemporaryDropFile(filePath)) {
-                // Handle other temporary drop files
-                try {
-                  final testFile = File(filePath);
-                  if (testFile.existsSync() &&
-                      testFile.statSync().type == FileSystemEntityType.file) {
-                    files.add(filePath);
-                  }
-                } catch (_) {
-                  // Skip files that can't be accessed
-                }
-              }
-            }
-          }
-
-          if (files.isNotEmpty) {
-            await selectionNotifier.addFiles(files);
-          }
-
-          for (final directory in directories) {
-            await selectionNotifier.addDirectory(directory);
-          }
-        },
-        child: AnimatedContainer(
-          duration: const Duration(milliseconds: 200),
-          decoration: BoxDecoration(
-            color: _isDragging
-                ? context.primary.addOpacity(0.05)
-                : Colors.transparent,
-            border: _isDragging
-                ? Border.all(
-                    color: context.primary.addOpacity(0.3),
-                    width: 2,
-                  )
-                : null,
-          ),
-          child: Column(
-            children: [
-              // Main editor area
-              Expanded(
-                child: ResizableSplitter(
-                  initialRatio: 0.35,
-                  maxRatio: 0.6,
-                  startPanel: Column(
-                    children: [
-                      const ActionButtonsWidget(),
-                      const Expanded(child: FileListWidget()),
-                      if (selectionState.isProcessing)
-                        const LinearProgressIndicator(),
-                    ],
-                  ),
-                  endPanel: Stack(
-                    children: [
-                      // Monaco Editor
-                      const MonacoEditorContainer(
-                        key: Key('editor-screen-monaco'),
-                      ),
-
-                      // Animated Sidebar (INSIDE Monaco editor area)
-                      AnimatedBuilder(
-                        animation: _sidebarAnimation,
-                        builder: (context, child) {
-                          final width =
-                              _expandedSidebarWidth * _sidebarAnimation.value;
-
-                          return Positioned(
-                            left: 0,
-                            top: 0,
-                            bottom: 0,
-                            child: SizedBox(
-                              width: width,
-                              child: width > 0
-                                  ? ClipRect(
-                                      child: Container(
-                                        decoration: BoxDecoration(
-                                          color:
-                                              context.surfaceContainerHighest,
-                                          border: BorderDirectional(
-                                            end: BorderSide(
-                                              color: context.outline
-                                                  .addOpacity(0.2),
-                                            ),
-                                          ),
-                                          boxShadow: [
-                                            BoxShadow(
-                                              color: context.shadow
-                                                  .addOpacity(0.05),
-                                              offset: const Offset(2, 0),
-                                              blurRadius: 4,
-                                            ),
-                                          ],
-                                        ),
-                                        child: _buildExpandedSidebar(
-                                            context, selectionState),
-                                      ),
-                                    )
-                                  : null,
-                            ),
-                          );
-                        },
-                      ),
-
-                      // Floating Toggle Button (positioned in editor area)
-                      Positioned(
-                        left:
-                            _isSidebarExpanded ? _expandedSidebarWidth - 20 : 8,
-                        top: 16,
-                        child: AnimatedBuilder(
-                          animation: _sidebarAnimation,
-                          builder: (context, child) {
-                            return Material(
-                              color: _isSidebarExpanded
-                                  ? context.surfaceContainerHighest
-                                  : context.surface,
-                              elevation: 4,
-                              shape: const CircleBorder(),
-                              child: InkWell(
-                                onTap: _toggleSidebar,
-                                customBorder: const CircleBorder(),
-                                splashColor: Colors.transparent,
-                                highlightColor: Colors.transparent,
-                                hoverColor: context.onSurface.addOpacity(0.04),
-                                child: Container(
-                                  width: 36,
-                                  height: 36,
-                                  decoration: BoxDecoration(
-                                    shape: BoxShape.circle,
-                                    border: Border.all(
-                                      color: context.outline.addOpacity(0.2),
-                                    ),
-                                  ),
-                                  child: Icon(
-                                    _isSidebarExpanded
-                                        ? Icons.chevron_left
-                                        : EneftyIcons.setting_3_outline,
-                                    size: 20,
-                                    color: context.onSurfaceVariant,
-                                  ),
-                                ),
-                              ),
-                            );
-                          },
-                        ),
-                      ),
-                    ],
-                  ),
-                ),
-              ),
-
-              // Bottom info bar
-              if (editorStatus.isReady)
-                MonacoEditorInfoBar(
-                  bridge: ref.read(monacoEditorServiceProvider).bridge,
-                  onCopy: () =>
-                      _copyToClipboard(context, selectionState.combinedContent),
-                ),
-            ],
-          ),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildExpandedSidebar(
-    BuildContext context,
-    SelectionState selectionState,
-  ) {
-    return SingleChildScrollView(
-      padding: const EdgeInsets.all(16),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          // Header with some spacing for the floating button
-          const SizedBox(height: 28),
-          Row(
-            children: [
-              Icon(
-                Icons.tune,
-                size: 20,
-                color: context.primary,
-              ),
-              const SizedBox(width: 8),
-              Text(
-                'Quick Settings',
-                style: context.titleSmall?.copyWith(
-                  fontWeight: FontWeight.w600,
-                ),
-              ),
-            ],
-          ),
-          const SizedBox(height: 20),
-
-          // File Count Badge
-          if (selectionState.selectedFilesCount > 0) ...[
-            Container(
-              padding: const EdgeInsets.symmetric(
-                horizontal: 12,
-                vertical: 8,
-              ),
-              decoration: BoxDecoration(
-                color: context.primary.addOpacity(0.1),
-                borderRadius: BorderRadius.circular(8),
-                border: Border.all(
-                  color: context.primary.addOpacity(0.3),
-                ),
-              ),
-              child: Row(
-                children: [
-                  Icon(
-                    Icons.description_outlined,
-                    size: 16,
-                    color: context.primary,
-                  ),
-                  const SizedBox(width: 8),
-                  Text(
-                    '${selectionState.selectedFilesCount} files selected',
-                    style: context.labelMedium?.copyWith(
-                      color: context.primary,
-                      fontWeight: FontWeight.w500,
-                    ),
-                  ),
-                ],
-              ),
-            ),
-            const SizedBox(height: 16),
-          ],
-
-          // Font Size Section
-          _buildSectionTitle('Font Size'),
-          const SizedBox(height: 8),
-          Row(
-            children: [
-              IconButton(
-                onPressed:
-                    _editorSettings.fontSize > 8 ? _decreaseFontSize : null,
-                icon: Icon(
-                  Icons.remove,
-                  color: context.onSurfaceVariant,
-                ),
-                iconSize: 18,
-                style: IconButton.styleFrom(
-                  minimumSize: const Size(32, 32),
-                ),
-                splashRadius: 0.1,
-                highlightColor: Colors.transparent,
-                splashColor: Colors.transparent,
-                hoverColor: context.onSurface.addOpacity(0.04),
-              ),
-              Expanded(
-                child: Container(
-                  height: 32,
-                  decoration: BoxDecoration(
-                    color: context.surface,
-                    borderRadius: BorderRadius.circular(8),
-                  ),
-                  child: Center(
-                    child: Text(
-                      '${_editorSettings.fontSize.round()}px',
-                      style: context.labelLarge?.copyWith(
-                        fontWeight: FontWeight.w600,
-                      ),
-                    ),
-                  ),
-                ),
-              ),
-              IconButton(
-                onPressed:
-                    _editorSettings.fontSize < 32 ? _increaseFontSize : null,
-                icon: Icon(
-                  Icons.add,
-                  color: context.onSurfaceVariant,
-                ),
-                iconSize: 18,
-                style: IconButton.styleFrom(
-                  minimumSize: const Size(32, 32),
-                ),
-                splashRadius: 0.1,
-                highlightColor: Colors.transparent,
-                splashColor: Colors.transparent,
-                hoverColor: context.onSurface.addOpacity(0.04),
-              ),
-            ],
-          ),
-
-          const SizedBox(height: 20),
-
-          // Quick Toggles
-          _buildSectionTitle('Editor Options'),
-          const SizedBox(height: 8),
-
-          _buildToggleTile(
-            icon: Icons.wrap_text,
-            title: 'Word Wrap',
-            value: _editorSettings.wordWrap != WordWrap.off,
-            onChanged: (_) => _toggleWordWrap(),
-          ),
-
-          _buildToggleTile(
-            icon: Icons.format_list_numbered,
-            title: 'Line Numbers',
-            value: _editorSettings.showLineNumbers,
-            onChanged: (value) async {
-              final newSettings =
-                  _editorSettings.copyWith(showLineNumbers: value);
-              await _saveAndApplySettings(newSettings);
-            },
-          ),
-
-          _buildToggleTile(
-            icon: Icons.map_outlined,
-            title: 'Minimap',
-            value: _editorSettings.showMinimap,
-            onChanged: (value) async {
-              final newSettings = _editorSettings.copyWith(showMinimap: value);
-              await _saveAndApplySettings(newSettings);
-            },
-          ),
-
-          _buildToggleTile(
-            icon: _editorSettings.readOnly ? Icons.edit_off : Icons.edit,
-            title: 'Edit Mode',
-            value: !_editorSettings.readOnly,
-            onChanged: (isEditable) async {
-              final newSettings =
-                  _editorSettings.copyWith(readOnly: !isEditable);
-              await _saveAndApplySettings(newSettings);
-            },
-          ),
-
-          const SizedBox(height: 20),
-
-          // Theme Quick Select
-          Row(
-            children: [
-              Icon(
-                Icons.palette_outlined,
-                size: 16,
-                color: context.onSurfaceVariant,
-              ),
-              const SizedBox(width: 8),
-              _buildSectionTitle('Theme'),
-            ],
-          ),
-          const SizedBox(height: 8),
-          Theme(
-            data: Theme.of(context).copyWith(
-              // Override dropdown position calculation
-              popupMenuTheme: PopupMenuThemeData(
-                color: context.surface,
-                elevation: 8,
-                shape: RoundedRectangleBorder(
-                  borderRadius: BorderRadius.circular(8),
-                ),
-              ),
-            ),
-            child: Container(
-              decoration: BoxDecoration(
-                color: context.surface,
-                borderRadius: BorderRadius.circular(8),
-              ),
-              child: DropdownButtonHideUnderline(
-                child: DropdownButton<String>(
-                  isExpanded: true,
-                  value: _editorSettings.theme,
-                  padding: const EdgeInsets.symmetric(
-                    horizontal: 12,
-                    vertical: 4,
-                  ),
-                  borderRadius: BorderRadius.circular(8),
-                  dropdownColor: context.surface,
-                  menuMaxHeight: 300,
-                  items: [
-                    _buildThemeDropdownItem('vs', 'Light'),
-                    _buildThemeDropdownItem('vs-dark', 'Dark'),
-                    _buildThemeDropdownItem('hc-black', 'High Contrast'),
-                    _buildThemeDropdownItem('one-dark-pro', 'One Dark Pro'),
-                  ],
-                  onChanged: (value) async {
-                    if (value != null) {
-                      final newSettings =
-                          _editorSettings.copyWith(theme: value);
-                      await _saveAndApplySettings(newSettings);
-                    }
-                  },
-                ),
-              ),
-            ),
-          ),
-
-          const SizedBox(height: 24),
-
-          // Full Settings Button
-          FilledButton.icon(
-            icon: const Icon(Icons.settings, size: 18),
-            label: const Text('All Settings'),
-            onPressed: () => _showEnhancedEditorSettings(context),
-            style: FilledButton.styleFrom(
-              minimumSize: const Size(double.infinity, 40),
-            ),
-          ),
-
-          const SizedBox(height: 12),
-
-          // Copy Button
-          OutlinedButton.icon(
-            icon: const Icon(Icons.copy, size: 18),
-            label: const Text('Copy Content'),
-            onPressed: selectionState.combinedContent.isNotEmpty
-                ? () =>
-                    _copyToClipboard(context, selectionState.combinedContent)
-                : null,
-            style: OutlinedButton.styleFrom(
-              minimumSize: const Size(double.infinity, 40),
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildSectionTitle(String title) {
-    return Text(
-      title,
-      style: context.labelMedium?.copyWith(
-        fontWeight: FontWeight.w600,
-        color: context.onSurfaceVariant,
-      ),
-    );
-  }
-
-  Widget _buildToggleTile({
-    required IconData icon,
-    required String title,
-    required bool value,
-    required ValueChanged<bool> onChanged,
-  }) {
-    return Container(
-      margin: const EdgeInsets.only(bottom: 8),
-      child: Material(
-        color: context.surface,
-        borderRadius: BorderRadius.circular(8),
-        child: InkWell(
-          onTap: () => onChanged(!value),
-          borderRadius: BorderRadius.circular(8),
-          splashColor: Colors.transparent,
-          highlightColor: Colors.transparent,
-          hoverColor: context.onSurface.addOpacity(0.02),
-          child: Padding(
-            padding: const EdgeInsets.symmetric(
-              horizontal: 12,
-              vertical: 8,
-            ),
-            child: Row(
-              children: [
-                Icon(
-                  icon,
-                  size: 18,
-                  color: value ? context.primary : context.onSurfaceVariant,
-                ),
-                const SizedBox(width: 12),
-                Expanded(
-                  child: Text(
-                    title,
-                    style: context.bodyMedium,
-                  ),
-                ),
-                Switch(
-                  value: value,
-                  onChanged: onChanged,
-                  materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
-                ),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-
-  DropdownMenuItem<String> _buildThemeDropdownItem(String value, String label) {
-    return DropdownMenuItem(
-      value: value,
-      child: Text(
-        label,
-        style: context.bodyMedium,
-      ),
-    );
-  }
-
-  Future<void> _showEnhancedEditorSettings(BuildContext context) async {
-    final newSettings = await EnhancedEditorSettingsDialog.show(
-      context,
-      _editorSettings,
-      customThemes: [],
-      customKeybindingPresets: [],
-    );
-    if (newSettings != null && mounted) {
-      await _saveAndApplySettings(newSettings);
-    }
-  }
-
-  void _copyToClipboard(BuildContext context, String content) {
-    Clipboard.setData(ClipboardData(text: content)).then((_) {
-      ScaffoldMessenger.of(context).showSnackBar(
-        SnackBar(
-          content: Row(
-            children: [
-              Icon(
-                Icons.check_circle,
-                color: context.onPrimary,
-                size: 20,
-              ),
-              const SizedBox(width: 8),
-              const Text('Content copied to clipboard!'),
-            ],
-          ),
-          backgroundColor: context.primary,
-          behavior: SnackBarBehavior.floating,
-          duration: const Duration(seconds: 2),
-          shape: RoundedRectangleBorder(
-            borderRadius: BorderRadius.circular(8),
-          ),
-        ),
-      );
-    }).catchError((dynamic error) {
-      ScaffoldMessenger.of(context).showSnackBar(
-        SnackBar(
-          content: Text('Error copying to clipboard: $error'),
-          backgroundColor: context.error,
-        ),
-      );
-    });
-  }
-}
diff --git a/lib/src/features/editor/presentation/ui/editor_settings_dialog.dart b/lib/src/features/editor/presentation/ui/editor_settings_dialog.dart
deleted file mode 100644
index 13dca48..0000000
--- a/lib/src/features/editor/presentation/ui/editor_settings_dialog.dart
+++ /dev/null
@@ -1,283 +0,0 @@
-import 'package:context_collector/src/features/editor/domain/editor_settings.dart';
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:flutter/material.dart';
-
-class EditorSettingsDialog extends StatefulWidget {
-  const EditorSettingsDialog({
-    required this.settings,
-    super.key,
-  });
-
-  final EditorSettings settings;
-
-  static Future<EditorSettings?> show(
-    BuildContext context,
-    EditorSettings currentSettings,
-  ) async {
-    return showDialog<EditorSettings>(
-      context: context,
-      builder: (context) => EditorSettingsDialog(settings: currentSettings),
-    );
-  }
-
-  @override
-  State<EditorSettingsDialog> createState() => _EditorSettingsDialogState();
-}
-
-class _EditorSettingsDialogState extends State<EditorSettingsDialog> {
-  late EditorSettings _settings;
-
-  @override
-  void initState() {
-    super.initState();
-    _settings = widget.settings;
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    return Dialog(
-      shape: RoundedRectangleBorder(
-        borderRadius: BorderRadius.circular(16),
-      ),
-      child: Container(
-        width: 400,
-        padding: const EdgeInsetsDirectional.all(24),
-        child: Column(
-          mainAxisSize: MainAxisSize.min,
-          crossAxisAlignment: CrossAxisAlignment.start,
-          children: [
-            Row(
-              children: [
-                Icon(
-                  Icons.settings_outlined,
-                  color: context.primary,
-                ),
-                const SizedBox(width: 12),
-                Text(
-                  'Editor Settings',
-                  style: context.titleLarge?.copyWith(
-                    fontWeight: FontWeight.w600,
-                  ),
-                ),
-              ],
-            ),
-            const SizedBox(height: 24),
-
-            // Font size
-            _buildSectionTitle(context, 'Font Size'),
-            const SizedBox(height: 8),
-            Row(
-              children: [
-                Expanded(
-                  child: Slider(
-                    value: _settings.fontSize,
-                    min: 10,
-                    max: 20,
-                    divisions: 10,
-                    label: '${_settings.fontSize.round()}px',
-                    onChanged: (value) {
-                      setState(() {
-                        _settings = _settings.copyWith(fontSize: value);
-                      });
-                    },
-                  ),
-                ),
-                const SizedBox(width: 16),
-                Container(
-                  width: 60,
-                  padding: const EdgeInsetsDirectional.symmetric(
-                    horizontal: 12,
-                    vertical: 8,
-                  ),
-                  decoration: BoxDecoration(
-                    color: context.primary.addOpacity(0.1),
-                    borderRadius: BorderRadius.circular(8),
-                    border: Border.all(
-                      color: context.primary.addOpacity(0.3),
-                    ),
-                  ),
-                  child: Text(
-                    '${_settings.fontSize.round()}px',
-                    style: context.bodyMedium?.copyWith(
-                      fontWeight: FontWeight.w600,
-                    ),
-                    textAlign: TextAlign.center,
-                  ),
-                ),
-              ],
-            ),
-            const SizedBox(height: 16),
-
-            // Preview
-            Container(
-              padding: const EdgeInsetsDirectional.all(12),
-              decoration: BoxDecoration(
-                color: context.isDark
-                    ? Colors.black.addOpacity(0.3)
-                    : Colors.grey.shade100,
-                borderRadius: BorderRadius.circular(8),
-                border: Border.all(
-                  color: context.onSurface.addOpacity(0.1),
-                ),
-              ),
-              child: Row(
-                children: [
-                  if (_settings.showLineNumbers) ...[
-                    Text(
-                      '1\n2\n3',
-                      style: TextStyle(
-                        fontFamily: 'monospace',
-                        fontSize: _settings.fontSize * 0.9,
-                        height: 1.4,
-                        color: context.onSurface.addOpacity(0.4),
-                      ),
-                    ),
-                    Container(
-                      width: 1,
-                      height: 50,
-                      margin:
-                          const EdgeInsetsDirectional.symmetric(horizontal: 12),
-                      color: context.onSurface.addOpacity(0.1),
-                    ),
-                  ],
-                  Expanded(
-                    child: Text(
-                      'Sample text preview\nLine 2 of code\nLine 3 of code',
-                      style: TextStyle(
-                        fontFamily: 'monospace',
-                        fontSize: _settings.fontSize,
-                        height: 1.4,
-                        color: context.onSurface,
-                      ),
-                      softWrap: _settings.wordWrap.enabled,
-                      overflow: _settings.wordWrap.enabled
-                          ? TextOverflow.visible
-                          : TextOverflow.ellipsis,
-                    ),
-                  ),
-                ],
-              ),
-            ),
-            const SizedBox(height: 24),
-
-            // Options
-            _buildSectionTitle(context, 'Display Options'),
-            const SizedBox(height: 12),
-
-            // Show line numbers
-            _buildOptionTile(
-              context,
-              title: 'Show Line Numbers',
-              subtitle: 'Display line numbers on the left side',
-              value: _settings.showLineNumbers,
-              onChanged: (value) {
-                setState(() {
-                  _settings = _settings.copyWith(showLineNumbers: value);
-                });
-              },
-            ),
-
-            // Word wrap
-            _buildOptionTile(
-              context,
-              title: 'Word Wrap',
-              subtitle: 'Wrap long lines instead of horizontal scrolling',
-              value: _settings.wordWrap.enabled,
-              onChanged: (value) {
-                setState(() {
-                  _settings = _settings.copyWith(
-                      wordWrap: value ? WordWrap.on : WordWrap.off);
-                });
-              },
-            ),
-
-            const SizedBox(height: 24),
-
-            // Actions
-            Row(
-              mainAxisAlignment: MainAxisAlignment.end,
-              children: [
-                TextButton(
-                  onPressed: () => Navigator.of(context).pop(),
-                  child: const Text('Cancel'),
-                ),
-                const SizedBox(width: 8),
-                FilledButton(
-                  onPressed: () async {
-                    await _settings.save();
-                    if (mounted) {
-                      Navigator.of(context).pop(_settings);
-                    }
-                  },
-                  child: const Text('Apply'),
-                ),
-              ],
-            ),
-          ],
-        ),
-      ),
-    );
-  }
-
-  Widget _buildSectionTitle(BuildContext context, String title) {
-    return Text(
-      title,
-      style: context.titleSmall?.copyWith(
-        fontWeight: FontWeight.w600,
-        color: context.onSurface.addOpacity(0.8),
-      ),
-    );
-  }
-
-  Widget _buildOptionTile(
-    BuildContext context, {
-    required String title,
-    required String subtitle,
-    required bool value,
-    required ValueChanged<bool> onChanged,
-  }) {
-    return Padding(
-      padding: const EdgeInsetsDirectional.only(bottom: 8),
-      child: Material(
-        color: Colors.transparent,
-        child: InkWell(
-          onTap: () => onChanged(!value),
-          borderRadius: BorderRadius.circular(8),
-          child: Padding(
-            padding: const EdgeInsetsDirectional.symmetric(
-              horizontal: 12,
-              vertical: 8,
-            ),
-            child: Row(
-              children: [
-                Expanded(
-                  child: Column(
-                    crossAxisAlignment: CrossAxisAlignment.start,
-                    children: [
-                      Text(
-                        title,
-                        style: context.bodyMedium?.copyWith(
-                          fontWeight: FontWeight.w500,
-                        ),
-                      ),
-                      Text(
-                        subtitle,
-                        style: context.labelSmall?.copyWith(
-                          color: context.onSurface.addOpacity(0.6),
-                        ),
-                      ),
-                    ],
-                  ),
-                ),
-                Switch(
-                  value: value,
-                  onChanged: onChanged,
-                ),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/editor/presentation/ui/enhanced_editor_settings_dialog.dart b/lib/src/features/editor/presentation/ui/enhanced_editor_settings_dialog.dart
deleted file mode 100644
index c6cb138..0000000
--- a/lib/src/features/editor/presentation/ui/enhanced_editor_settings_dialog.dart
+++ /dev/null
@@ -1,2061 +0,0 @@
-import 'dart:convert';
-import 'dart:io';
-
-import 'package:context_collector/src/features/editor/domain/editor_settings.dart';
-import 'package:context_collector/src/features/editor/domain/keybinding_manager.dart';
-import 'package:context_collector/src/features/editor/domain/monaco_data.dart';
-import 'package:context_collector/src/features/editor/domain/theme_manager.dart';
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:file_picker/file_picker.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/services.dart';
-
-/// Enhanced settings dialog with tabbed interface and comprehensive options
-class EnhancedEditorSettingsDialog extends StatefulWidget {
-  const EnhancedEditorSettingsDialog({
-    required this.settings,
-    super.key,
-    this.customThemes = const [],
-    this.customKeybindingPresets = const [],
-  });
-
-  final EditorSettings settings;
-  final List<EditorTheme> customThemes;
-  final List<KeybindingPreset> customKeybindingPresets;
-
-  static Future<EditorSettings?> show(
-    BuildContext context,
-    EditorSettings currentSettings, {
-    List<EditorTheme> customThemes = const [],
-    List<KeybindingPreset> customKeybindingPresets = const [],
-  }) async {
-    return showDialog<EditorSettings>(
-      context: context,
-      barrierDismissible: false,
-      builder: (context) => EnhancedEditorSettingsDialog(
-        settings: currentSettings,
-        customThemes: customThemes,
-        customKeybindingPresets: customKeybindingPresets,
-      ),
-    );
-  }
-
-  @override
-  State<EnhancedEditorSettingsDialog> createState() =>
-      _EnhancedEditorSettingsDialogState();
-}
-
-class _EnhancedEditorSettingsDialogState
-    extends State<EnhancedEditorSettingsDialog> with TickerProviderStateMixin {
-  late EditorSettings _settings;
-  late TabController _tabController;
-
-  // Form controllers
-  final _fontSizeController = TextEditingController();
-  final _lineHeightController = TextEditingController();
-  final _letterSpacingController = TextEditingController();
-  final _tabSizeController = TextEditingController();
-  final _wordWrapColumnController = TextEditingController();
-
-  // Focus nodes
-  final _fontSizeFocus = FocusNode();
-  final _lineHeightFocus = FocusNode();
-  final _letterSpacingFocus = FocusNode();
-  final _tabSizeFocus = FocusNode();
-  final _wordWrapColumnFocus = FocusNode();
-
-  @override
-  void initState() {
-    super.initState();
-    _settings = widget.settings;
-    _tabController = TabController(length: 6, vsync: this);
-
-    // Initialize form controllers
-    _fontSizeController.text = _settings.fontSize.toString();
-    _lineHeightController.text = _settings.lineHeight.toString();
-    _letterSpacingController.text = _settings.letterSpacing.toString();
-    _tabSizeController.text = _settings.tabSize.toString();
-    _wordWrapColumnController.text = _settings.wordWrapColumn.toString();
-  }
-
-  @override
-  void dispose() {
-    _tabController.dispose();
-    _fontSizeController.dispose();
-    _lineHeightController.dispose();
-    _letterSpacingController.dispose();
-    _tabSizeController.dispose();
-    _wordWrapColumnController.dispose();
-    _fontSizeFocus.dispose();
-    _lineHeightFocus.dispose();
-    _letterSpacingFocus.dispose();
-    _tabSizeFocus.dispose();
-    _wordWrapColumnFocus.dispose();
-    super.dispose();
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    return Dialog(
-      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
-      clipBehavior: Clip.antiAlias,
-      child: Container(
-        width: 900,
-        height: 700,
-        decoration: BoxDecoration(
-          color: context.surface,
-          borderRadius: BorderRadius.circular(16),
-        ),
-        child: Column(
-          children: [
-            _buildHeader(),
-            _buildTabBar(),
-            Expanded(child: _buildTabContent()),
-            _buildFooter(),
-          ],
-        ),
-      ),
-    );
-  }
-
-  Widget _buildHeader() {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(24),
-      decoration: BoxDecoration(
-        color: context.primary.addOpacity(0.05),
-        border: Border(
-          bottom: BorderSide(
-            color: context.onSurface.addOpacity(0.1),
-          ),
-        ),
-      ),
-      child: Row(
-        children: [
-          Icon(
-            Icons.settings_outlined,
-            size: 28,
-            color: context.primary,
-          ),
-          const SizedBox(width: 16),
-          Expanded(
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Text(
-                  'Editor Settings',
-                  style: context.headlineSmall?.copyWith(
-                    fontWeight: FontWeight.w600,
-                    color: context.onSurface,
-                  ),
-                ),
-                const SizedBox(height: 4),
-                Text(
-                  'Customize your Monaco editor experience',
-                  style: context.bodyMedium?.copyWith(
-                    color: context.onSurface.addOpacity(0.7),
-                  ),
-                ),
-              ],
-            ),
-          ),
-          IconButton(
-            onPressed: () => Navigator.of(context).pop(),
-            icon: Icon(
-              Icons.close,
-              color: context.onSurface.addOpacity(0.6),
-            ),
-            tooltip: 'Close',
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildTabBar() {
-    return Container(
-      decoration: BoxDecoration(
-        color: context.surface,
-        border: Border(
-          bottom: BorderSide(
-            color: context.onSurface.addOpacity(0.1),
-          ),
-        ),
-      ),
-      child: TabBar(
-        controller: _tabController,
-        isScrollable: true,
-        tabAlignment: TabAlignment.start,
-        labelColor: context.primary,
-        unselectedLabelColor: context.onSurface.addOpacity(0.6),
-        indicatorColor: context.primary,
-        indicatorWeight: 3,
-        labelStyle: context.labelLarge?.copyWith(
-          fontWeight: FontWeight.w600,
-        ),
-        unselectedLabelStyle: context.labelLarge?.copyWith(
-          fontWeight: FontWeight.w400,
-        ),
-        tabs: const [
-          Tab(text: 'General'),
-          Tab(text: 'Appearance'),
-          Tab(text: 'Editor'),
-          Tab(text: 'Keybindings'),
-          Tab(text: 'Languages'),
-          Tab(text: 'Advanced'),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildTabContent() {
-    return TabBarView(
-      controller: _tabController,
-      children: [
-        _buildGeneralTab(),
-        _buildAppearanceTab(),
-        _buildEditorTab(),
-        _buildKeybindingsTab(),
-        _buildLanguagesTab(),
-        _buildAdvancedTab(),
-      ],
-    );
-  }
-
-  Widget _buildGeneralTab() {
-    return SingleChildScrollView(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          _buildSectionHeader('Font & Typography'),
-          const SizedBox(height: 16),
-
-          // Font Family
-          _buildDropdownField(
-            label: 'Font Family',
-            value: _settings.fontFamily,
-            items: [
-              'JetBrains Mono, SF Mono, Menlo, Consolas, "Courier New", monospace',
-              'JetBrains Mono, SF Mono, Menlo, Consolas, monospace',
-              'SF Mono, Monaco, Consolas, monospace',
-              'Consolas, Monaco, monospace',
-              'Courier New, monospace',
-              'monospace',
-            ],
-            onChanged: (value) {
-              if (value != null) {
-                setState(() {
-                  _settings = _settings.copyWith(fontFamily: value);
-                });
-              }
-            },
-            hint: 'Select font family',
-          ),
-          const SizedBox(height: 16),
-
-          Row(
-            children: [
-              // Font Size
-              Expanded(
-                child: _buildNumberField(
-                  label: 'Font Size',
-                  controller: _fontSizeController,
-                  focusNode: _fontSizeFocus,
-                  min: 8,
-                  max: 72,
-                  suffix: 'px',
-                  onChanged: (value) {
-                    setState(() {
-                      _settings = _settings.copyWith(fontSize: value);
-                    });
-                  },
-                ),
-              ),
-              const SizedBox(width: 16),
-
-              // Line Height
-              Expanded(
-                child: _buildNumberField(
-                  label: 'Line Height',
-                  controller: _lineHeightController,
-                  focusNode: _lineHeightFocus,
-                  min: 1,
-                  max: 3,
-                  step: 0.1,
-                  onChanged: (value) {
-                    setState(() {
-                      _settings = _settings.copyWith(lineHeight: value);
-                    });
-                  },
-                ),
-              ),
-              const SizedBox(width: 16),
-
-              // Letter Spacing
-              Expanded(
-                child: _buildNumberField(
-                  label: 'Letter Spacing',
-                  controller: _letterSpacingController,
-                  focusNode: _letterSpacingFocus,
-                  min: -2,
-                  max: 5,
-                  step: 0.1,
-                  suffix: 'px',
-                  onChanged: (value) {
-                    setState(() {
-                      _settings = _settings.copyWith(letterSpacing: value);
-                    });
-                  },
-                ),
-              ),
-            ],
-          ),
-
-          const SizedBox(height: 32),
-          _buildSectionHeader('Basic Options'),
-          const SizedBox(height: 16),
-
-          // Read Only
-          _buildSwitchTile(
-            title: 'Read Only',
-            subtitle: 'Make editor read-only (view mode)',
-            value: _settings.readOnly,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(readOnly: value);
-              });
-            },
-          ),
-
-          // Automatic Layout
-          _buildSwitchTile(
-            title: 'Automatic Layout',
-            subtitle: 'Automatically adjust editor size',
-            value: _settings.automaticLayout,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(automaticLayout: value);
-              });
-            },
-          ),
-
-          // Mouse Wheel Zoom
-          _buildSwitchTile(
-            title: 'Mouse Wheel Zoom',
-            subtitle: 'Enable zooming with Ctrl+Mouse wheel',
-            value: _settings.mouseWheelZoom,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(mouseWheelZoom: value);
-              });
-            },
-          ),
-
-          const SizedBox(height: 32),
-          _buildPreviewSection(),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildAppearanceTab() {
-    final availableThemes =
-        ThemeManager.getAllThemes(customThemes: widget.customThemes);
-
-    return SingleChildScrollView(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          _buildSectionHeader('Theme'),
-          const SizedBox(height: 16),
-
-          // Theme Selection
-          Container(
-            padding: const EdgeInsetsDirectional.all(16),
-            decoration: BoxDecoration(
-              color: context.surface,
-              borderRadius: BorderRadius.circular(12),
-              border: Border.all(
-                color: context.onSurface.addOpacity(0.1),
-              ),
-            ),
-            child: Column(
-              children: [
-                for (final category in ThemeCategory.values)
-                  if (availableThemes.any((t) => t.category == category)) ...[
-                    _buildThemeCategorySection(category, availableThemes),
-                    if (category != ThemeCategory.values.last)
-                      const SizedBox(height: 24),
-                  ],
-              ],
-            ),
-          ),
-
-          const SizedBox(height: 32),
-          _buildSectionHeader('Display'),
-          const SizedBox(height: 16),
-
-          // Line Numbers
-          Row(
-            children: [
-              Expanded(
-                child: _buildSwitchTile(
-                  title: 'Show Line Numbers',
-                  subtitle: 'Display line numbers in the gutter',
-                  value: _settings.showLineNumbers,
-                  onChanged: (value) {
-                    setState(() {
-                      _settings = _settings.copyWith(showLineNumbers: value);
-                    });
-                  },
-                ),
-              ),
-              const SizedBox(width: 16),
-              if (_settings.showLineNumbers)
-                Expanded(
-                  child: _buildDropdownField<LineNumbersStyle>(
-                    label: 'Line Number Style',
-                    value: _settings.lineNumbersStyle,
-                    items: LineNumbersStyle.values,
-                    itemBuilder: (style) {
-                      switch (style) {
-                        case LineNumbersStyle.off:
-                          return 'Off';
-                        case LineNumbersStyle.on:
-                          return 'On';
-                        case LineNumbersStyle.relative:
-                          return 'Relative';
-                        case LineNumbersStyle.interval:
-                          return 'Interval';
-                      }
-                    },
-                    onChanged: (value) {
-                      if (value != null) {
-                        setState(() {
-                          _settings =
-                              _settings.copyWith(lineNumbersStyle: value);
-                        });
-                      }
-                    },
-                  ),
-                ),
-            ],
-          ),
-
-          // Minimap
-          _buildSwitchTile(
-            title: 'Show Minimap',
-            subtitle: 'Display miniature overview of the entire file',
-            value: _settings.showMinimap,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(showMinimap: value);
-              });
-            },
-          ),
-
-          if (_settings.showMinimap) ...[
-            Row(
-              children: [
-                Expanded(
-                  child: _buildDropdownField<MinimapSide>(
-                    label: 'Minimap Side',
-                    value: _settings.minimapSide,
-                    items: MinimapSide.values,
-                    itemBuilder: (side) => side.name.capitalize(),
-                    onChanged: (value) {
-                      if (value != null) {
-                        setState(() {
-                          _settings = _settings.copyWith(minimapSide: value);
-                        });
-                      }
-                    },
-                  ),
-                ),
-                const SizedBox(width: 16),
-                Expanded(
-                  child: _buildSwitchTile(
-                    title: 'Render Characters',
-                    subtitle: 'Show actual characters in minimap',
-                    value: _settings.minimapRenderCharacters,
-                    onChanged: (value) {
-                      setState(() {
-                        _settings =
-                            _settings.copyWith(minimapRenderCharacters: value);
-                      });
-                    },
-                  ),
-                ),
-              ],
-            ),
-          ],
-
-          // Other Display Options
-          _buildSwitchTile(
-            title: 'Show Indent Guides',
-            subtitle: 'Display vertical lines to show indentation',
-            value: _settings.showIndentGuides,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(showIndentGuides: value);
-              });
-            },
-          ),
-
-          _buildDropdownField<RenderWhitespace>(
-            label: 'Render Whitespace',
-            value: _settings.renderWhitespace,
-            items: RenderWhitespace.values,
-            itemBuilder: (ws) {
-              switch (ws) {
-                case RenderWhitespace.none:
-                  return 'None';
-                case RenderWhitespace.boundary:
-                  return 'Boundary';
-                case RenderWhitespace.selection:
-                  return 'Selection';
-                case RenderWhitespace.trailing:
-                  return 'Trailing';
-                case RenderWhitespace.all:
-                  return 'All';
-              }
-            },
-            onChanged: (value) {
-              if (value != null) {
-                setState(() {
-                  _settings = _settings.copyWith(renderWhitespace: value);
-                });
-              }
-            },
-          ),
-
-          _buildSwitchTile(
-            title: 'Bracket Pair Colorization',
-            subtitle: 'Color matching brackets with different colors',
-            value: _settings.bracketPairColorization,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(bracketPairColorization: value);
-              });
-            },
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildEditorTab() {
-    return SingleChildScrollView(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          _buildSectionHeader('Text Editing'),
-          const SizedBox(height: 16),
-
-          // Word Wrap
-          _buildDropdownField<WordWrap>(
-            label: 'Word Wrap',
-            value: _settings.wordWrap,
-            items: WordWrap.values,
-            itemBuilder: (wrap) {
-              switch (wrap) {
-                case WordWrap.off:
-                  return 'Off';
-                case WordWrap.on:
-                  return 'On';
-                case WordWrap.wordWrapColumn:
-                  return 'At Column';
-                case WordWrap.bounded:
-                  return 'Bounded';
-              }
-            },
-            onChanged: (value) {
-              if (value != null) {
-                setState(() {
-                  _settings = _settings.copyWith(wordWrap: value);
-                });
-              }
-            },
-          ),
-
-          if (_settings.wordWrap == WordWrap.wordWrapColumn) ...[
-            const SizedBox(height: 16),
-            _buildNumberField(
-              label: 'Word Wrap Column',
-              controller: _wordWrapColumnController,
-              focusNode: _wordWrapColumnFocus,
-              min: 40,
-              max: 200,
-              onChanged: (value) {
-                setState(() {
-                  _settings = _settings.copyWith(wordWrapColumn: value.toInt());
-                });
-              },
-            ),
-          ],
-
-          const SizedBox(height: 16),
-
-          Row(
-            children: [
-              Expanded(
-                child: _buildNumberField(
-                  label: 'Tab Size',
-                  controller: _tabSizeController,
-                  focusNode: _tabSizeFocus,
-                  min: 1,
-                  max: 16,
-                  onChanged: (value) {
-                    setState(() {
-                      _settings = _settings.copyWith(tabSize: value.toInt());
-                    });
-                  },
-                ),
-              ),
-              const SizedBox(width: 16),
-              Expanded(
-                child: _buildSwitchTile(
-                  title: 'Insert Spaces',
-                  subtitle: 'Use spaces instead of tabs',
-                  value: _settings.insertSpaces,
-                  onChanged: (value) {
-                    setState(() {
-                      _settings = _settings.copyWith(insertSpaces: value);
-                    });
-                  },
-                ),
-              ),
-            ],
-          ),
-
-          const SizedBox(height: 32),
-          _buildSectionHeader('Auto Features'),
-          const SizedBox(height: 16),
-
-          _buildSwitchTile(
-            title: 'Format on Save',
-            subtitle: 'Automatically format code when saving',
-            value: _settings.formatOnSave,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(formatOnSave: value);
-              });
-            },
-          ),
-
-          _buildSwitchTile(
-            title: 'Format on Paste',
-            subtitle: 'Automatically format pasted code',
-            value: _settings.formatOnPaste,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(formatOnPaste: value);
-              });
-            },
-          ),
-
-          _buildSwitchTile(
-            title: 'Format on Type',
-            subtitle: 'Format code as you type',
-            value: _settings.formatOnType,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(formatOnType: value);
-              });
-            },
-          ),
-
-          const SizedBox(height: 32),
-          _buildSectionHeader('Code Intelligence'),
-          const SizedBox(height: 16),
-
-          _buildSwitchTile(
-            title: 'Quick Suggestions',
-            subtitle: 'Show auto-completion suggestions',
-            value: _settings.quickSuggestions,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(quickSuggestions: value);
-              });
-            },
-          ),
-
-          _buildSwitchTile(
-            title: 'Parameter Hints',
-            subtitle: 'Show parameter hints for functions',
-            value: _settings.parameterHints,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(parameterHints: value);
-              });
-            },
-          ),
-
-          _buildSwitchTile(
-            title: 'Hover Information',
-            subtitle: 'Show hover information for symbols',
-            value: _settings.hover,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(hover: value);
-              });
-            },
-          ),
-
-          const SizedBox(height: 32),
-          _buildSectionHeader('Cursor & Selection'),
-          const SizedBox(height: 16),
-
-          Row(
-            children: [
-              Expanded(
-                child: _buildDropdownField<CursorBlinking>(
-                  label: 'Cursor Blinking',
-                  value: _settings.cursorBlinking,
-                  items: CursorBlinking.values,
-                  itemBuilder: (blinking) => blinking.name.capitalize(),
-                  onChanged: (value) {
-                    if (value != null) {
-                      setState(() {
-                        _settings = _settings.copyWith(cursorBlinking: value);
-                      });
-                    }
-                  },
-                ),
-              ),
-              const SizedBox(width: 16),
-              Expanded(
-                child: _buildDropdownField<CursorStyle>(
-                  label: 'Cursor Style',
-                  value: _settings.cursorStyle,
-                  items: CursorStyle.values,
-                  itemBuilder: (style) => style.name.capitalize(),
-                  onChanged: (value) {
-                    if (value != null) {
-                      setState(() {
-                        _settings = _settings.copyWith(cursorStyle: value);
-                      });
-                    }
-                  },
-                ),
-              ),
-            ],
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildKeybindingsTab() {
-    final allPresets = KeybindingManager.getAllPresets(
-      customPresets: widget.customKeybindingPresets,
-    );
-
-    return SingleChildScrollView(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          _buildSectionHeader('Keybinding Preset'),
-          const SizedBox(height: 16),
-
-          // Preset Selection
-          Container(
-            padding: const EdgeInsetsDirectional.all(16),
-            decoration: BoxDecoration(
-              color: context.surface,
-              borderRadius: BorderRadius.circular(12),
-              border: Border.all(
-                color: context.onSurface.addOpacity(0.1),
-              ),
-            ),
-            child: Column(
-              children: [
-                for (final preset in allPresets) ...[
-                  RadioListTile<KeybindingPresetEnum>(
-                    title: Text(
-                      preset.name,
-                      style: context.bodyLarge?.copyWith(
-                        fontWeight: FontWeight.w500,
-                      ),
-                    ),
-                    subtitle: preset.description != null
-                        ? Text(
-                            preset.description!,
-                            style: context.bodySmall?.copyWith(
-                              color: context.onSurface.addOpacity(0.6),
-                            ),
-                          )
-                        : null,
-                    value: KeybindingPresetEnum.values.firstWhere(
-                      (p) => p.name == preset.id,
-                      orElse: () => KeybindingPresetEnum.custom,
-                    ),
-                    groupValue: _settings.keybindingPreset,
-                    onChanged: (value) {
-                      if (value != null) {
-                        setState(() {
-                          _settings =
-                              _settings.copyWith(keybindingPreset: value);
-                        });
-                      }
-                    },
-                    activeColor: context.primary,
-                  ),
-                  if (preset != allPresets.last)
-                    Divider(
-                      color: context.onSurface.addOpacity(0.1),
-                      height: 1,
-                    ),
-                ],
-              ],
-            ),
-          ),
-
-          const SizedBox(height: 32),
-          _buildSectionHeader('Popular Shortcuts'),
-          const SizedBox(height: 16),
-
-          // Show common shortcuts
-          _buildShortcutsPreview(),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildLanguagesTab() {
-    return SingleChildScrollView(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          _buildSectionHeader('Language-Specific Settings'),
-          const SizedBox(height: 8),
-          Text(
-            'Configure settings that apply only to specific programming languages.',
-            style: context.bodyMedium?.copyWith(
-              color: context.onSurface.addOpacity(0.7),
-            ),
-          ),
-          const SizedBox(height: 24),
-          _buildLanguageConfigsList(),
-          const SizedBox(height: 24),
-          Center(
-            child: OutlinedButton.icon(
-              onPressed: () => _showLanguageSettingsDialog(context),
-              icon: const Icon(Icons.add),
-              label: const Text('Add Language Configuration'),
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildLanguageConfigsList() {
-    final entries = _settings.languageConfigs.entries.toList();
-    if (entries.isEmpty) {
-      return Container(
-        padding: const EdgeInsetsDirectional.all(24),
-        decoration: BoxDecoration(
-          color: context.surfaceContainerHighest.addOpacity(0.3),
-          borderRadius: BorderRadius.circular(12),
-          border: Border.all(
-            color: context.onSurface.addOpacity(0.1),
-          ),
-        ),
-        child: Column(
-          children: [
-            Icon(
-              Icons.code_off_outlined,
-              size: 48,
-              color: context.onSurface.addOpacity(0.4),
-            ),
-            const SizedBox(height: 16),
-            Text(
-              'No Language-Specific Configurations',
-              style: context.titleMedium?.copyWith(
-                fontWeight: FontWeight.w600,
-              ),
-            ),
-            const SizedBox(height: 8),
-            Text(
-              'Click "Add Language Configuration" to define custom settings for specific languages.',
-              textAlign: TextAlign.center,
-              style: context.bodyMedium?.copyWith(
-                color: context.onSurface.addOpacity(0.6),
-              ),
-            ),
-          ],
-        ),
-      );
-    }
-
-    return ListView.separated(
-      shrinkWrap: true,
-      physics: const NeverScrollableScrollPhysics(),
-      itemCount: entries.length,
-      separatorBuilder: (context, index) => Divider(
-        color: context.onSurface.addOpacity(0.1),
-        height: 1,
-      ),
-      itemBuilder: (context, index) {
-        final entry = entries[index];
-        final languageName = MonacoData.availableLanguages.firstWhere(
-            (lang) => lang['value'] == entry.key,
-            orElse: () => {'value': entry.key, 'text': entry.key})['text'];
-
-        return ListTile(
-          contentPadding: const EdgeInsetsDirectional.symmetric(
-              horizontal: 16, vertical: 8),
-          leading: Icon(Icons.language, color: context.primary),
-          title: Text(languageName ?? entry.key, style: context.bodyLarge),
-          subtitle: Text(
-            _getLanguageConfigSummary(entry.value),
-            style: context.bodySmall
-                ?.copyWith(color: context.onSurface.addOpacity(0.6)),
-            maxLines: 1,
-            overflow: TextOverflow.ellipsis,
-          ),
-          trailing: Row(
-            mainAxisSize: MainAxisSize.min,
-            children: [
-              IconButton(
-                icon: Icon(Icons.edit_outlined,
-                    color: context.onSurface.addOpacity(0.7)),
-                tooltip: 'Edit',
-                onPressed: () =>
-                    _showLanguageSettingsDialog(context, language: entry.key),
-              ),
-              IconButton(
-                icon: Icon(Icons.delete_outline, color: context.error),
-                tooltip: 'Remove',
-                onPressed: () => _removeLanguageConfig(entry.key),
-              ),
-            ],
-          ),
-          onTap: () =>
-              _showLanguageSettingsDialog(context, language: entry.key),
-        );
-      },
-    );
-  }
-
-  String _getLanguageConfigSummary(LanguageConfig config) {
-    final parts = <String>[];
-    if (config.tabSize != null) parts.add('Tab Size: ${config.tabSize}');
-    if (config.insertSpaces != null) {
-      parts.add(config.insertSpaces! ? 'Use Spaces' : 'Use Tabs');
-    }
-    if (config.wordWrap != null && config.wordWrap != WordWrap.off) {
-      parts.add('Word Wrap: ${config.wordWrap!.name.capitalize()}');
-    }
-    if (config.formatOnSave != null && config.formatOnSave!) {
-      parts.add('Format on Save');
-    }
-    return parts.isNotEmpty ? parts.join(', ') : 'Default settings';
-  }
-
-  void _removeLanguageConfig(String language) {
-    setState(() {
-      _settings.languageConfigs.remove(language);
-      _settings = _settings.copyWith(
-        languageConfigs: Map.from(_settings.languageConfigs),
-      );
-    });
-    ScaffoldMessenger.of(context).showSnackBar(
-      SnackBar(
-        content: Text('Removed configuration for $language'),
-        backgroundColor: context.error,
-        behavior: SnackBarBehavior.floating,
-      ),
-    );
-  }
-
-  Future<void> _showLanguageSettingsDialog(BuildContext context,
-      {String? language}) async {
-    final result = await showDialog<MapEntry<String, LanguageConfig>?>(
-      context: context,
-      barrierDismissible: false,
-      builder: (_) => _LanguageSettingsDialog(
-        currentConfigs: _settings.languageConfigs,
-        language: language,
-        initialConfig:
-            language != null ? _settings.languageConfigs[language] : null,
-      ),
-    );
-
-    if (result != null) {
-      setState(() {
-        final newConfigs =
-            Map<String, LanguageConfig>.from(_settings.languageConfigs);
-        newConfigs[result.key] = result.value;
-        _settings = _settings.copyWith(languageConfigs: newConfigs);
-      });
-    }
-  }
-
-  Widget _buildAdvancedTab() {
-    return SingleChildScrollView(
-      padding: const EdgeInsetsDirectional.all(24),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          _buildSectionHeader('Performance'),
-          const SizedBox(height: 16),
-          _buildSwitchTile(
-            title: 'Smooth Scrolling',
-            subtitle: 'Enable smooth scrolling animations',
-            value: _settings.smoothScrolling,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(smoothScrolling: value);
-              });
-            },
-          ),
-          _buildSwitchTile(
-            title: 'Disable Layer Hinting',
-            subtitle: 'May improve performance on some devices',
-            value: _settings.disableLayerHinting,
-            onChanged: (value) {
-              setState(() {
-                _settings = _settings.copyWith(disableLayerHinting: value);
-              });
-            },
-          ),
-          _buildSwitchTile(
-            title: 'Disable Monospace Optimizations',
-            subtitle: 'Disable font optimizations for monospace fonts',
-            value: _settings.disableMonospaceOptimizations,
-            onChanged: (value) {
-              setState(() {
-                _settings =
-                    _settings.copyWith(disableMonospaceOptimizations: value);
-              });
-            },
-          ),
-          const SizedBox(height: 32),
-          _buildSectionHeader('Accessibility'),
-          const SizedBox(height: 16),
-          _buildDropdownField<AccessibilitySupport>(
-            label: 'Accessibility Support',
-            value: _settings.accessibilitySupport,
-            items: AccessibilitySupport.values,
-            itemBuilder: (support) => support.name.capitalize(),
-            onChanged: (value) {
-              if (value != null) {
-                setState(() {
-                  _settings = _settings.copyWith(accessibilitySupport: value);
-                });
-              }
-            },
-          ),
-          const SizedBox(height: 32),
-          _buildSectionHeader('Reset & Backup'),
-          const SizedBox(height: 16),
-          Row(
-            children: [
-              Expanded(
-                child: OutlinedButton.icon(
-                  onPressed: _showResetDialog,
-                  icon: Icon(
-                    Icons.restore,
-                    color: context.error,
-                  ),
-                  label: Text(
-                    'Reset to Defaults',
-                    style: TextStyle(color: context.error),
-                  ),
-                  style: OutlinedButton.styleFrom(
-                    side: BorderSide(color: context.error),
-                  ),
-                ),
-              ),
-              const SizedBox(width: 16),
-              Expanded(
-                child: OutlinedButton.icon(
-                  onPressed: _exportSettings,
-                  icon: const Icon(Icons.download),
-                  label: const Text('Export Settings'),
-                ),
-              ),
-              const SizedBox(width: 16),
-              Expanded(
-                child: OutlinedButton.icon(
-                  onPressed: _importSettings,
-                  icon: const Icon(Icons.upload),
-                  label: const Text('Import Settings'),
-                ),
-              ),
-            ],
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildSectionHeader(String title) {
-    return Text(
-      title,
-      style: context.titleMedium?.copyWith(
-        fontWeight: FontWeight.w600,
-        color: context.onSurface,
-      ),
-    );
-  }
-
-  Widget _buildDropdownField<T>({
-    required String label,
-    required T value,
-    required List<T> items,
-    String Function(T)? itemBuilder,
-    void Function(T?)? onChanged,
-    String? hint,
-  }) {
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        Text(
-          label,
-          style: context.labelMedium?.copyWith(
-            fontWeight: FontWeight.w500,
-            color: context.onSurface.addOpacity(0.8),
-          ),
-        ),
-        const SizedBox(height: 8),
-        Container(
-          decoration: BoxDecoration(
-            borderRadius: BorderRadius.circular(8),
-            border: Border.all(
-              color: context.onSurface.addOpacity(0.2),
-            ),
-          ),
-          child: DropdownButtonFormField<T>(
-            value: value,
-            decoration: InputDecoration(
-              border: InputBorder.none,
-              contentPadding: const EdgeInsetsDirectional.symmetric(
-                horizontal: 16,
-                vertical: 12,
-              ),
-              hintText: hint,
-            ),
-            items: items.map((item) {
-              return DropdownMenuItem<T>(
-                value: item,
-                child: Text(
-                  itemBuilder?.call(item) ?? item.toString(),
-                  style: context.bodyMedium,
-                ),
-              );
-            }).toList(),
-            onChanged: onChanged,
-          ),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildNumberField({
-    required String label,
-    required TextEditingController controller,
-    required FocusNode focusNode,
-    required double min,
-    required double max,
-    required void Function(double) onChanged,
-    double step = 1.0,
-    String? suffix,
-  }) {
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        Text(
-          label,
-          style: context.labelMedium?.copyWith(
-            fontWeight: FontWeight.w500,
-            color: context.onSurface.addOpacity(0.8),
-          ),
-        ),
-        const SizedBox(height: 8),
-        Container(
-          decoration: BoxDecoration(
-            borderRadius: BorderRadius.circular(8),
-            border: Border.all(
-              color: context.onSurface.addOpacity(0.2),
-            ),
-          ),
-          child: TextFormField(
-            controller: controller,
-            focusNode: focusNode,
-            keyboardType: const TextInputType.numberWithOptions(decimal: true),
-            inputFormatters: [
-              FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d*')),
-            ],
-            decoration: InputDecoration(
-              border: InputBorder.none,
-              contentPadding: const EdgeInsetsDirectional.symmetric(
-                horizontal: 16,
-                vertical: 12,
-              ),
-              suffixText: suffix,
-            ),
-            onChanged: (value) {
-              final numValue = double.tryParse(value);
-              if (numValue != null && numValue >= min && numValue <= max) {
-                onChanged(numValue);
-              }
-            },
-          ),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildSwitchTile({
-    required String title,
-    required String subtitle,
-    required bool value,
-    required void Function(bool) onChanged,
-  }) {
-    return Container(
-      margin: const EdgeInsetsDirectional.only(bottom: 12),
-      child: Material(
-        color: Colors.transparent,
-        child: InkWell(
-          onTap: () => onChanged(!value),
-          borderRadius: BorderRadius.circular(8),
-          child: Padding(
-            padding: const EdgeInsetsDirectional.symmetric(
-              horizontal: 12,
-              vertical: 8,
-            ),
-            child: Row(
-              children: [
-                Expanded(
-                  child: Column(
-                    crossAxisAlignment: CrossAxisAlignment.start,
-                    children: [
-                      Text(
-                        title,
-                        style: context.bodyMedium?.copyWith(
-                          fontWeight: FontWeight.w500,
-                        ),
-                      ),
-                      Text(
-                        subtitle,
-                        style: context.labelSmall?.copyWith(
-                          color: context.onSurface.addOpacity(0.6),
-                        ),
-                      ),
-                    ],
-                  ),
-                ),
-                Switch(
-                  value: value,
-                  onChanged: onChanged,
-                  activeColor: context.primary,
-                ),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildThemeCategorySection(
-      ThemeCategory category, List<EditorTheme> themes) {
-    final categoryThemes = themes.where((t) => t.category == category).toList();
-    if (categoryThemes.isEmpty) return const SizedBox.shrink();
-
-    String categoryName;
-    switch (category) {
-      case ThemeCategory.light:
-        categoryName = 'Light Themes';
-      case ThemeCategory.dark:
-        categoryName = 'Dark Themes';
-      case ThemeCategory.highContrast:
-        categoryName = 'High Contrast';
-      case ThemeCategory.custom:
-        categoryName = 'Custom Themes';
-    }
-
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        Text(
-          categoryName,
-          style: context.labelLarge?.copyWith(
-            fontWeight: FontWeight.w600,
-            color: context.onSurface.addOpacity(0.8),
-          ),
-        ),
-        const SizedBox(height: 12),
-        Wrap(
-          spacing: 12,
-          runSpacing: 12,
-          children: categoryThemes.map((theme) {
-            final isSelected = _settings.theme == theme.id;
-            final previewColors = ThemeManager.getThemePreviewColors(theme);
-
-            return InkWell(
-              onTap: () {
-                setState(() {
-                  _settings = _settings.copyWith(theme: theme.id);
-                });
-              },
-              borderRadius: BorderRadius.circular(8),
-              child: Container(
-                width: 120,
-                height: 80,
-                decoration: BoxDecoration(
-                  borderRadius: BorderRadius.circular(8),
-                  border: Border.all(
-                    color: isSelected
-                        ? context.primary
-                        : context.onSurface.addOpacity(0.2),
-                    width: isSelected ? 2 : 1,
-                  ),
-                ),
-                child: Stack(
-                  children: [
-                    // Theme preview
-                    Container(
-                      decoration: BoxDecoration(
-                        borderRadius: BorderRadius.circular(7),
-                        color: Color(int.parse(previewColors['background']!
-                            .replaceFirst('#', '0xFF'))),
-                      ),
-                      child: Column(
-                        children: [
-                          Container(
-                            height: 20,
-                            decoration: BoxDecoration(
-                              color: Color(int.parse(previewColors['accent']!
-                                      .replaceFirst('#', '0xFF')))
-                                  .addOpacity(0.1),
-                              borderRadius: const BorderRadiusDirectional.only(
-                                topStart: Radius.circular(7),
-                                topEnd: Radius.circular(7),
-                              ),
-                            ),
-                          ),
-                          Expanded(
-                            child: Padding(
-                              padding: const EdgeInsetsDirectional.all(8),
-                              child: Row(
-                                children: [
-                                  Container(
-                                    width: 8,
-                                    decoration: BoxDecoration(
-                                      color: Color(int.parse(
-                                          previewColors['lineNumber']!
-                                              .replaceFirst('#', '0xFF'))),
-                                      borderRadius: BorderRadius.circular(1),
-                                    ),
-                                  ),
-                                  const SizedBox(width: 4),
-                                  Expanded(
-                                    child: Column(
-                                      crossAxisAlignment:
-                                          CrossAxisAlignment.start,
-                                      children: [
-                                        Container(
-                                          height: 2,
-                                          width: double.infinity,
-                                          color: Color(int.parse(
-                                              previewColors['foreground']!
-                                                  .replaceFirst('#', '0xFF'))),
-                                        ),
-                                        const SizedBox(height: 2),
-                                        Container(
-                                          height: 2,
-                                          width: 40,
-                                          color: Color(int.parse(
-                                              previewColors['accent']!
-                                                  .replaceFirst('#', '0xFF'))),
-                                        ),
-                                        const SizedBox(height: 2),
-                                        Container(
-                                          height: 2,
-                                          width: 60,
-                                          color: Color(int.parse(
-                                                  previewColors['foreground']!
-                                                      .replaceFirst(
-                                                          '#', '0xFF')))
-                                              .addOpacity(0.7),
-                                        ),
-                                      ],
-                                    ),
-                                  ),
-                                ],
-                              ),
-                            ),
-                          ),
-                        ],
-                      ),
-                    ),
-                    // Selection indicator
-                    if (isSelected)
-                      PositionedDirectional(
-                        top: 4,
-                        end: 4,
-                        child: Container(
-                          width: 16,
-                          height: 16,
-                          decoration: BoxDecoration(
-                            color: context.primary,
-                            shape: BoxShape.circle,
-                          ),
-                          child: Icon(
-                            Icons.check,
-                            size: 12,
-                            color: context.onPrimary,
-                          ),
-                        ),
-                      ),
-                  ],
-                ),
-              ),
-            );
-          }).toList(),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildPreviewSection() {
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        _buildSectionHeader('Preview'),
-        const SizedBox(height: 16),
-        Container(
-          padding: const EdgeInsetsDirectional.all(16),
-          decoration: BoxDecoration(
-            color: context.isDark
-                ? Colors.black.addOpacity(0.3)
-                : Colors.grey.shade100,
-            borderRadius: BorderRadius.circular(8),
-            border: Border.all(
-              color: context.onSurface.addOpacity(0.1),
-            ),
-          ),
-          child: Row(
-            children: [
-              if (_settings.showLineNumbers) ...[
-                Text(
-                  '1\n2\n3',
-                  style: TextStyle(
-                    fontFamily: _settings.fontFamily.split(',').first.trim(),
-                    fontSize: _settings.fontSize * 0.9,
-                    height: _settings.lineHeight,
-                    letterSpacing: _settings.letterSpacing,
-                    color: context.onSurface.addOpacity(0.4),
-                  ),
-                ),
-                Container(
-                  width: 1,
-                  height: 50,
-                  margin: const EdgeInsetsDirectional.symmetric(horizontal: 12),
-                  color: context.onSurface.addOpacity(0.1),
-                ),
-              ],
-              Expanded(
-                child: Text(
-                  'Sample code preview\nfunc main() {\n    print("Hello, World!")\n}',
-                  style: TextStyle(
-                    fontFamily: _settings.fontFamily.split(',').first.trim(),
-                    fontSize: _settings.fontSize,
-                    height: _settings.lineHeight,
-                    letterSpacing: _settings.letterSpacing,
-                    color: context.onSurface,
-                  ),
-                  softWrap: _settings.wordWrap != WordWrap.off,
-                  overflow: _settings.wordWrap != WordWrap.off
-                      ? TextOverflow.visible
-                      : TextOverflow.ellipsis,
-                ),
-              ),
-            ],
-          ),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildShortcutsPreview() {
-    // Get current preset shortcuts
-    final preset =
-        KeybindingManager.findPresetById(_settings.keybindingPreset.name);
-    if (preset == null) return const SizedBox.shrink();
-
-    final popularShortcuts = preset.keybindings.take(10).toList();
-
-    return Container(
-      padding: const EdgeInsetsDirectional.all(16),
-      decoration: BoxDecoration(
-        color: context.surface,
-        borderRadius: BorderRadius.circular(12),
-        border: Border.all(
-          color: context.onSurface.addOpacity(0.1),
-        ),
-      ),
-      child: Column(
-        children: [
-          for (final shortcut in popularShortcuts) ...[
-            Row(
-              children: [
-                Expanded(
-                  child: Text(
-                    shortcut.description ?? shortcut.command,
-                    style: context.bodyMedium,
-                  ),
-                ),
-                Container(
-                  padding: const EdgeInsetsDirectional.symmetric(
-                    horizontal: 8,
-                    vertical: 4,
-                  ),
-                  decoration: BoxDecoration(
-                    color: context.onSurface.addOpacity(0.1),
-                    borderRadius: BorderRadius.circular(4),
-                  ),
-                  child: Text(
-                    shortcut.key,
-                    style: context.labelSmall?.copyWith(
-                      fontFamily: 'monospace',
-                      fontWeight: FontWeight.w600,
-                    ),
-                  ),
-                ),
-              ],
-            ),
-            if (shortcut != popularShortcuts.last)
-              Divider(
-                color: context.onSurface.addOpacity(0.1),
-                height: 16,
-              ),
-          ],
-        ],
-      ),
-    );
-  }
-
-  Widget _buildFooter() {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(24),
-      decoration: BoxDecoration(
-        color: context.surface,
-        border: Border(
-          top: BorderSide(
-            color: context.onSurface.addOpacity(0.1),
-          ),
-        ),
-      ),
-      child: Row(
-        children: [
-          TextButton.icon(
-            onPressed: _loadPreset,
-            icon: const Icon(Icons.category_outlined),
-            label: const Text('Load Preset'),
-          ),
-          const Spacer(),
-          TextButton(
-            onPressed: () => Navigator.of(context).pop(),
-            child: const Text('Cancel'),
-          ),
-          const SizedBox(width: 12),
-          FilledButton(
-            onPressed: () async {
-              await _settings.save();
-              if (mounted) {
-                Navigator.of(context).pop(_settings);
-              }
-            },
-            child: const Text('Apply Settings'),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Future<void> _loadPreset() async {
-    await showDialog<dynamic>(
-      context: context,
-      builder: (context) => AlertDialog(
-        title: const Text('Load Preset'),
-        content: Column(
-          mainAxisSize: MainAxisSize.min,
-          children: [
-            for (final presetName in [
-              'beginner',
-              'developer',
-              'poweruser',
-              'accessibility'
-            ])
-              ListTile(
-                title: Text(presetName.capitalize()),
-                subtitle: Text(_getPresetDescription(presetName)),
-                onTap: () {
-                  setState(() {
-                    _settings = EditorSettings.createPreset(presetName);
-                    // Update form controllers
-                    _fontSizeController.text = _settings.fontSize.toString();
-                    _lineHeightController.text =
-                        _settings.lineHeight.toString();
-                    _letterSpacingController.text =
-                        _settings.letterSpacing.toString();
-                    _tabSizeController.text = _settings.tabSize.toString();
-                    _wordWrapColumnController.text =
-                        _settings.wordWrapColumn.toString();
-                  });
-                  Navigator.of(context).pop();
-                },
-              ),
-          ],
-        ),
-        actions: [
-          TextButton(
-            onPressed: () => Navigator.of(context).pop(),
-            child: const Text('Cancel'),
-          ),
-        ],
-      ),
-    );
-  }
-
-  String _getPresetDescription(String preset) {
-    switch (preset) {
-      case 'beginner':
-        return 'Larger font, word wrap enabled, helpful features';
-      case 'developer':
-        return 'Balanced settings for daily development';
-      case 'poweruser':
-        return 'Advanced features, compact layout';
-      case 'accessibility':
-        return 'Optimized for screen readers and visibility';
-      default:
-        return '';
-    }
-  }
-
-  Future<void> _showResetDialog() async {
-    await showDialog<void>(
-      context: context,
-      builder: (context) => AlertDialog(
-        title: const Text('Reset Settings'),
-        content: const Text(
-          'Are you sure you want to reset all settings to defaults? This cannot be undone.',
-        ),
-        actions: [
-          TextButton(
-            onPressed: () => Navigator.of(context).pop(),
-            child: const Text('Cancel'),
-          ),
-          TextButton(
-            onPressed: () {
-              setState(() {
-                _settings = const EditorSettings();
-                // Update form controllers
-                _fontSizeController.text = _settings.fontSize.toString();
-                _lineHeightController.text = _settings.lineHeight.toString();
-                _letterSpacingController.text =
-                    _settings.letterSpacing.toString();
-                _tabSizeController.text = _settings.tabSize.toString();
-                _wordWrapColumnController.text =
-                    _settings.wordWrapColumn.toString();
-              });
-              Navigator.of(context).pop();
-            },
-            style: TextButton.styleFrom(
-              foregroundColor: context.error,
-            ),
-            child: const Text('Reset'),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Future<void> _exportSettings() async {
-    final settingsJson = jsonEncode(_settings.toMonacoOptions());
-    try {
-      final outputFile = await FilePicker.platform.saveFile(
-        dialogTitle: 'Export Editor Settings',
-        fileName: 'editor_settings.json',
-        type: FileType.custom,
-        allowedExtensions: ['json'],
-      );
-
-      if (outputFile != null) {
-        final file = File(outputFile);
-        await file.writeAsString(settingsJson);
-        if (mounted) {
-          ScaffoldMessenger.of(context).showSnackBar(
-            SnackBar(
-              content: Text('Settings exported successfully to $outputFile'),
-              backgroundColor: context.primary,
-              behavior: SnackBarBehavior.floating,
-            ),
-          );
-        }
-      }
-    } catch (e) {
-      if (mounted) {
-        ScaffoldMessenger.of(context).showSnackBar(
-          SnackBar(
-            content: Text('Error exporting settings: $e'),
-            backgroundColor: context.error,
-            behavior: SnackBarBehavior.floating,
-          ),
-        );
-      }
-    }
-  }
-
-  Future<void> _importSettings() async {
-    try {
-      final result = await FilePicker.platform.pickFiles(
-        type: FileType.custom,
-        allowedExtensions: ['json'],
-      );
-
-      if (result != null && result.files.single.path != null) {
-        final file = File(result.files.single.path!);
-        final content = await file.readAsString();
-        final jsonMap = jsonDecode(content) as Map<String, dynamic>;
-
-        final newSettings = EditorSettings.fromJson(jsonMap);
-
-        setState(() {
-          _settings = newSettings;
-          // Update all form controllers
-          _fontSizeController.text = _settings.fontSize.toString();
-          _lineHeightController.text = _settings.lineHeight.toString();
-          _letterSpacingController.text = _settings.letterSpacing.toString();
-          _tabSizeController.text = _settings.tabSize.toString();
-          _wordWrapColumnController.text = _settings.wordWrapColumn.toString();
-          // ... update other controllers for all tabs ...
-        });
-
-        if (mounted) {
-          ScaffoldMessenger.of(context).showSnackBar(
-            SnackBar(
-              content: const Text('Settings imported successfully!'),
-              backgroundColor: context.primary,
-              behavior: SnackBarBehavior.floating,
-            ),
-          );
-        }
-      }
-    } catch (e) {
-      if (mounted) {
-        ScaffoldMessenger.of(context).showSnackBar(
-          SnackBar(
-            content: Text('Error importing settings: $e'),
-            backgroundColor: context.error,
-            behavior: SnackBarBehavior.floating,
-          ),
-        );
-      }
-    }
-  }
-}
-
-class _LanguageSettingsDialog extends StatefulWidget {
-  const _LanguageSettingsDialog({
-    required this.currentConfigs,
-    this.language,
-    this.initialConfig,
-  });
-
-  final Map<String, LanguageConfig> currentConfigs;
-  final String? language;
-  final LanguageConfig? initialConfig;
-
-  @override
-  State<_LanguageSettingsDialog> createState() =>
-      _LanguageSettingsDialogState();
-}
-
-class _LanguageSettingsDialogState extends State<_LanguageSettingsDialog> {
-  String? _selectedLanguage;
-  late LanguageConfig _config;
-
-  final _tabSizeController = TextEditingController();
-  final _rulersController =
-      TextEditingController(); // For comma-separated numbers
-
-  @override
-  void initState() {
-    super.initState();
-    _selectedLanguage = widget.language;
-    _config = widget.initialConfig ?? const LanguageConfig();
-
-    _tabSizeController.text = _config.tabSize?.toString() ?? '';
-    _rulersController.text = _config.rulers?.join(',') ?? '';
-  }
-
-  @override
-  void dispose() {
-    _tabSizeController.dispose();
-    _rulersController.dispose();
-    super.dispose();
-  }
-
-  List<DropdownMenuItem<String>> _getLanguageDropdownItems() {
-    final existingKeys = widget.currentConfigs.keys.toSet();
-    if (widget.language != null) {
-      // If editing, allow current language
-      existingKeys.remove(widget.language);
-    }
-
-    return MonacoData.availableLanguages
-        .where((lang) => !existingKeys.contains(lang['value']))
-        .map((lang) => DropdownMenuItem<String>(
-              value: lang['value'],
-              child: Text(lang['text'] ?? lang['value']!),
-            ))
-        .toList();
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final theme = context.themeData;
-    final isEditing = widget.language != null;
-
-    return AlertDialog(
-      title: Text(isEditing
-          ? 'Edit ${MonacoData.availableLanguages.firstWhere((l) => l['value'] == _selectedLanguage, orElse: () => {
-                'text': _selectedLanguage!
-              })['text']} Settings'
-          : 'Add Language-Specific Settings'),
-      content: SingleChildScrollView(
-        child: Column(
-          mainAxisSize: MainAxisSize.min,
-          crossAxisAlignment: CrossAxisAlignment.start,
-          children: <Widget>[
-            if (!isEditing)
-              DropdownButtonFormField<String>(
-                decoration: const InputDecoration(labelText: 'Language'),
-                value: _selectedLanguage,
-                items: _getLanguageDropdownItems(),
-                onChanged: (value) {
-                  setState(() {
-                    _selectedLanguage = value;
-                  });
-                },
-                validator: (value) =>
-                    value == null ? 'Please select a language' : null,
-              )
-            else
-              Padding(
-                padding: const EdgeInsetsDirectional.only(bottom: 16),
-                child: Text(
-                    'Editing settings for: ${MonacoData.availableLanguages.firstWhere((l) => l['value'] == _selectedLanguage, orElse: () => {
-                          'text': _selectedLanguage!
-                        })['text']}',
-                    style: theme.titleMedium),
-              ),
-            const SizedBox(height: 16),
-            _buildTextField(
-                controller: _tabSizeController,
-                label: 'Tab Size (Optional)',
-                keyboardType: TextInputType.number,
-                inputFormatters: [FilteringTextInputFormatter.digitsOnly],
-                onChanged: (value) {
-                  final val = int.tryParse(value);
-                  _config = _config.copyWith(tabSize: val);
-                }),
-            const SizedBox(height: 16),
-            _buildSwitch(
-              label: 'Insert Spaces (Optional)',
-              value: _config.insertSpaces,
-              onChanged: (value) {
-                setState(() {
-                  _config = _config.copyWith(insertSpaces: value);
-                });
-              },
-            ),
-            const SizedBox(height: 16),
-            _buildDropdown<WordWrap>(
-              label: 'Word Wrap (Optional)',
-              value: _config.wordWrap,
-              items: [null, ...WordWrap.values],
-              // Allow clearing
-              itemBuilder: (ww) =>
-                  ww == null ? 'Default' : ww.name.capitalize(),
-              onChanged: (value) {
-                setState(() {
-                  _config = _config.copyWith(wordWrap: value);
-                });
-              },
-            ),
-            const SizedBox(height: 16),
-            _buildTextField(
-                controller: _rulersController,
-                label: 'Rulers (Optional, e.g., 80,100)',
-                keyboardType: TextInputType.text,
-                onChanged: (value) {
-                  final rulers = value
-                      .split(',')
-                      .map((s) => int.tryParse(s.trim()))
-                      .whereType<int>()
-                      .toList();
-                  _config = _config.copyWith(
-                      rulers: rulers.isNotEmpty ? rulers : null);
-                }),
-            const SizedBox(height: 16),
-            _buildSwitch(
-              label: 'Format on Save (Optional)',
-              value: _config.formatOnSave,
-              onChanged: (value) {
-                setState(() {
-                  _config = _config.copyWith(formatOnSave: value);
-                });
-              },
-            ),
-            _buildSwitch(
-              label: 'Format on Paste (Optional)',
-              value: _config.formatOnPaste,
-              onChanged: (value) {
-                setState(() {
-                  _config = _config.copyWith(formatOnPaste: value);
-                });
-              },
-            ),
-            _buildSwitch(
-              label: 'Format on Type (Optional)',
-              value: _config.formatOnType,
-              onChanged: (value) {
-                setState(() {
-                  _config = _config.copyWith(formatOnType: value);
-                });
-              },
-            ),
-            _buildSwitch(
-              label: 'Bracket Pair Colorization (Optional)',
-              value: _config.bracketPairColorization,
-              onChanged: (value) {
-                setState(() {
-                  _config = _config.copyWith(bracketPairColorization: value);
-                });
-              },
-            ),
-          ],
-        ),
-      ),
-      actions: <Widget>[
-        TextButton(
-          child: const Text('Cancel'),
-          onPressed: () {
-            Navigator.of(context).pop();
-          },
-        ),
-        FilledButton(
-          child: const Text('Save'),
-          onPressed: () {
-            if (_selectedLanguage != null) {
-              // Clear fields if they are empty strings after editing, to truly make them null
-              final finalConfig = _config.copyWith(
-                tabSize:
-                    _tabSizeController.text.isEmpty ? null : _config.tabSize,
-                rulers: _rulersController.text.isEmpty ? null : _config.rulers,
-              );
-              Navigator.of(context)
-                  .pop(MapEntry(_selectedLanguage!, finalConfig));
-            } else if (!isEditing) {
-              // Show error if no language selected when adding
-              ScaffoldMessenger.of(context).showSnackBar(
-                SnackBar(
-                  content: const Text('Please select a language.'),
-                  backgroundColor: Theme.of(context).colorScheme.error,
-                ),
-              );
-            }
-          },
-        ),
-      ],
-    );
-  }
-
-  Widget _buildTextField({
-    required TextEditingController controller,
-    required String label,
-    required ValueChanged<String> onChanged,
-    TextInputType? keyboardType,
-    List<TextInputFormatter>? inputFormatters,
-  }) {
-    return TextFormField(
-      controller: controller,
-      decoration: InputDecoration(
-        labelText: label,
-        border: const OutlineInputBorder(),
-      ),
-      keyboardType: keyboardType,
-      inputFormatters: inputFormatters,
-      onChanged: onChanged,
-    );
-  }
-
-  Widget _buildSwitch({
-    required String label,
-    required ValueChanged<bool?> onChanged,
-    bool? value, // Nullable for tri-state (default, true, false)
-  }) {
-    return Row(
-      mainAxisAlignment: MainAxisAlignment.spaceBetween,
-      children: [
-        Text(label, style: context.bodyMedium),
-        Switch(
-          value: value ?? false, // Default to false for switch UI if null
-          onChanged: (newValue) {
-            // If it was null, toggle to true. If true, to false. If false, to null (clear).
-            if (value == null) {
-              onChanged(true);
-            } else if (value == true) {
-              onChanged(false);
-            } else {
-              onChanged(null); // This allows clearing the setting
-            }
-          },
-          activeColor: context.primary,
-          // tristate: true, // Enable if you want visual tristate
-        ),
-      ],
-    );
-  }
-
-  Widget _buildDropdown<T>({
-    required String label,
-    T? value,
-    required List<T?> items,
-    required String Function(T?) itemBuilder,
-    required void Function(T?)? onChanged,
-  }) {
-    return DropdownButtonFormField<T?>(
-      decoration: InputDecoration(
-        labelText: label,
-        border: const OutlineInputBorder(),
-      ),
-      value: value,
-      items: items.map((item) {
-        return DropdownMenuItem<T?>(
-          value: item,
-          child: Text(itemBuilder(item)),
-        );
-      }).toList(),
-      onChanged: onChanged,
-    );
-  }
-}
-
-extension StringExtension on String {
-  String capitalize() {
-    if (isEmpty) return this;
-    return this[0].toUpperCase() + substring(1);
-  }
-}
diff --git a/lib/src/features/editor/presentation/ui/global_monaco_container.dart b/lib/src/features/editor/presentation/ui/global_monaco_container.dart
deleted file mode 100644
index 4505583..0000000
--- a/lib/src/features/editor/presentation/ui/global_monaco_container.dart
+++ /dev/null
@@ -1,55 +0,0 @@
-// lib/src/features/editor/presentation/ui/global_monaco_container.dart
-import 'package:context_collector/src/features/editor/presentation/ui/editor_screen.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_providers.dart';
-import 'package:context_collector/src/features/scan/presentation/state/selection_notifier.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-/// Global container with layered architecture
-/// Bottom layer: Complete Editor UI (file list + monaco editor) - always loaded
-/// Top layer: Home Screen - fades in/out based on file selection
-class GlobalMonacoContainer extends ConsumerWidget {
-  const GlobalMonacoContainer({
-    required this.child,
-    super.key,
-  });
-
-  final Widget child;
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final selectionState = ref.watch(selectionProvider);
-    ref.watch(monacoEditorStatusProvider);
-
-    // Show home overlay when:
-    // 1. No files are manually added (not including welcome/test content)
-    // 2. All files have been cleared
-    final showHomeOverlay = selectionState.allFiles.isEmpty;
-
-    debugPrint(
-        '[GlobalMonacoContainer] Build - ShowHomeOverlay: $showHomeOverlay, Files: ${selectionState.allFiles.length}');
-
-    return Material(
-      child: Stack(
-        children: [
-          // BOTTOM LAYER: Complete Editor UI (always present, always loaded)
-          const EditorScreen(),
-
-          // TOP LAYER: Home Screen overlay (fades in/out)
-          // Using IgnorePointer to ensure underlying widgets can receive events when hidden
-          AnimatedSwitcher(
-            duration: const Duration(milliseconds: 400),
-            child: showHomeOverlay
-                ? child // This is the HomeScreen with drop zone
-                : IgnorePointer(
-                    key: const ValueKey('ignore-pointer'),
-                    child: Container(
-                      key: const ValueKey('empty-overlay'),
-                    ),
-                  ),
-          ),
-        ],
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/editor/presentation/ui/monaco_editor_container.dart b/lib/src/features/editor/presentation/ui/monaco_editor_container.dart
deleted file mode 100644
index 290ac2b..0000000
--- a/lib/src/features/editor/presentation/ui/monaco_editor_container.dart
+++ /dev/null
@@ -1,182 +0,0 @@
-// lib/src/features/editor/presentation/ui/monaco_editor_container.dart
-import 'package:context_collector/src/features/editor/assets_manager/notifier.dart';
-import 'package:context_collector/src/features/editor/presentation/ui/monaco_editor_integrated.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_providers.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_service.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_state.dart';
-import 'package:context_collector/src/features/scan/presentation/state/selection_notifier.dart';
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-/// Monaco Editor Container - Always present in the editor screen
-class MonacoEditorContainer extends ConsumerStatefulWidget {
-  const MonacoEditorContainer({
-    super.key,
-    this.height,
-    this.onReady,
-  });
-
-  final double? height;
-  final VoidCallback? onReady;
-
-  @override
-  ConsumerState<MonacoEditorContainer> createState() =>
-      _MonacoEditorContainerState();
-}
-
-class _MonacoEditorContainerState extends ConsumerState<MonacoEditorContainer> {
-  bool _hasNotifiedReady = false;
-  bool _hasInitialized = false;
-
-  @override
-  void initState() {
-    super.initState();
-
-    // Initialize editor when widget is created
-    WidgetsBinding.instance.addPostFrameCallback((_) {
-      if (!_hasInitialized) {
-        _hasInitialized = true;
-      }
-    });
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final editorStatus = ref.watch(monacoEditorStatusProvider);
-    final assetStatus = ref.watch(monacoAssetStatusProvider);
-    ref.watch(selectionProvider);
-    final editorService = ref.watch(monacoEditorServiceProvider);
-
-    // Listen for selection changes to update editor content
-    ref
-      ..listen<SelectionState>(selectionProvider, (previous, next) {
-        debugPrint(
-            '[MonacoEditorContainer] Selection changed - has content: ${next.combinedContent.isNotEmpty}');
-
-        if (previous?.combinedContent != next.combinedContent) {
-          Future.microtask(() {
-            if (next.combinedContent.isNotEmpty) {
-              debugPrint('[MonacoEditorContainer] Setting editor content');
-              editorService.setContent(next.combinedContent);
-            } else {
-              debugPrint('[MonacoEditorContainer] Clearing editor content');
-              editorService.clearContent();
-            }
-          });
-        }
-      })
-
-      // Listen for status changes
-      ..listen<MonacoEditorStatus>(monacoEditorStatusProvider,
-          (previous, next) {
-        debugPrint(
-            '[MonacoEditorContainer] Status changed: ${previous?.state} ‚Üí ${next.state}');
-
-        // Notify ready callback once
-        if (!_hasNotifiedReady && next.isReady) {
-          _hasNotifiedReady = true;
-          widget.onReady?.call();
-        }
-      });
-
-    // Only show editor if assets are ready
-    final shouldCreateEditor = assetStatus.state == MonacoAssetState.ready;
-
-    return Stack(
-      children: [
-        // Create editor widget when assets are ready
-        if (shouldCreateEditor) _buildEditor(editorService, editorStatus),
-
-        // Overlay for loading/error states during initialization
-        if ((editorStatus.isLoading || editorStatus.hasError) &&
-            !editorStatus.isReady)
-          _buildOverlay(editorStatus),
-      ],
-    );
-  }
-
-  Widget _buildEditor(
-    MonacoEditorService service,
-    MonacoEditorStatus status,
-  ) {
-    debugPrint(
-        '[MonacoEditorContainer] Building editor widget - Status: ${status.state}');
-
-    return MonacoEditorIntegrated(
-      key: const Key('monaco_editor_webview'),
-      bridge: service.bridge,
-      onReady: () {
-        debugPrint(
-            '[MonacoEditorContainer] Editor WebView ready, marking service ready');
-        service.markEditorReady();
-      },
-      height: widget.height,
-    );
-  }
-
-  Widget _buildOverlay(MonacoEditorStatus status) {
-    return AnimatedSwitcher(
-      duration: const Duration(milliseconds: 300),
-      child: ColoredBox(
-        key: ValueKey(status.state),
-        color: context.surface.addOpacity(0.95),
-        child: Center(
-          child: _buildStatusContent(status),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildStatusContent(MonacoEditorStatus status) {
-    if (status.hasError) {
-      return Column(
-        mainAxisSize: MainAxisSize.min,
-        children: [
-          Icon(Icons.error_outline, size: 48, color: context.error),
-          const SizedBox(height: 16),
-          Text(
-            'Editor Error',
-            style: context.titleMedium?.copyWith(color: context.error),
-          ),
-          const SizedBox(height: 8),
-          Text(
-            status.error ?? 'Unknown error',
-            style: context.bodySmall,
-            textAlign: TextAlign.center,
-          ),
-          const SizedBox(height: 16),
-          FilledButton(
-            onPressed: () {
-              ref.read(monacoEditorServiceProvider).retryInitialization();
-            },
-            child: const Text('Retry'),
-          ),
-        ],
-      );
-    }
-
-    return Column(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        CircularProgressIndicator(
-          value: status.progress > 0 ? status.progress : null,
-        ),
-        const SizedBox(height: 16),
-        Text(
-          'Loading Editor...',
-          style: context.titleMedium,
-        ),
-        if (status.message != null) ...[
-          const SizedBox(height: 8),
-          Text(
-            status.message!,
-            style: context.bodySmall?.copyWith(
-              color: context.onSurface.addOpacity(0.7),
-            ),
-          ),
-        ],
-      ],
-    );
-  }
-}
diff --git a/lib/src/features/editor/presentation/ui/monaco_editor_info_bar.dart b/lib/src/features/editor/presentation/ui/monaco_editor_info_bar.dart
deleted file mode 100644
index f903375..0000000
--- a/lib/src/features/editor/presentation/ui/monaco_editor_info_bar.dart
+++ /dev/null
@@ -1,487 +0,0 @@
-import 'package:context_collector/src/features/editor/bridge/monaco_bridge_platform.dart';
-import 'package:context_collector/src/features/editor/domain/monaco_data.dart';
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:enefty_icons/enefty_icons.dart';
-import 'package:flutter/material.dart';
-
-/// Enhanced info bar for Monaco editor with comprehensive controls
-class MonacoEditorInfoBar extends StatefulWidget {
-  const MonacoEditorInfoBar({
-    required this.bridge,
-    required this.onCopy,
-    super.key,
-  });
-
-  final MonacoBridgePlatform bridge;
-  final VoidCallback onCopy;
-
-  @override
-  State<MonacoEditorInfoBar> createState() => _MonacoEditorInfoBarState();
-}
-
-class _MonacoEditorInfoBarState extends State<MonacoEditorInfoBar> {
-  final List<Map<String, String>> _availableLanguages =
-      MonacoData.availableLanguages;
-
-  String _selectedLanguage = MonacoData.availableLanguages.isNotEmpty
-      ? MonacoData.availableLanguages.first['value']!
-      : 'markdown';
-
-  @override
-  void initState() {
-    super.initState();
-    _updateCurrentLanguage();
-    widget.bridge.addListener(_updateCurrentLanguage);
-  }
-
-  @override
-  void dispose() {
-    widget.bridge.removeListener(_updateCurrentLanguage);
-    super.dispose();
-  }
-
-  Future<void> _updateCurrentLanguage() async {
-    if (!widget.bridge.isReady) return;
-
-    try {
-      final stats = await widget.bridge.getEditorStats();
-      if (!mounted) return;
-
-      final detectedLanguage = stats['language'] as String? ?? 'markdown';
-      final isSupported =
-          _availableLanguages.any((lang) => lang['value'] == detectedLanguage);
-
-      setState(() {
-        _selectedLanguage = isSupported
-            ? detectedLanguage
-            : (_availableLanguages.isNotEmpty
-                ? _availableLanguages.first['value']!
-                : 'markdown');
-      });
-    } catch (e) {
-      // Handle error silently - language detection is not critical
-    }
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    return ListenableBuilder(
-      listenable: widget.bridge,
-      builder: (context, _) {
-        if (!widget.bridge.isReady) {
-          return _buildLoadingIndicator(context);
-        }
-
-        return Container(
-          padding: const EdgeInsetsDirectional.symmetric(horizontal: 8),
-          decoration: const BoxDecoration(color: Colors.transparent),
-          child: Row(
-            children: [
-              // Stats Display - takes only needed space
-              _buildStatsDisplay(),
-
-              const SizedBox(width: 12),
-
-              // Language Selector - right after stats
-              _buildDropDown<String>(
-                context: context,
-                icon: Icons.translate,
-                value: _selectedLanguage,
-                items: _availableLanguages.map(_buildLanguageMenuItem).toList(),
-                onChanged: _handleLanguageChange,
-                displayNameBuilder: _getLanguageDisplayName,
-                tooltip: 'Select Language',
-              ),
-
-              // Flexible spacer - pushes buttons to end
-              const Spacer(),
-
-              // Action Buttons - at absolute end
-              ..._buildActionButtons(),
-            ],
-          ),
-        );
-      },
-    );
-  }
-
-  Widget _buildStatsDisplay() {
-    return ValueListenableBuilder<Map<String, int>>(
-      valueListenable: widget.bridge.liveStats,
-      builder: (context, stats, _) {
-        final statsText = _formatStatsText(stats);
-
-        return ConstrainedBox(
-          constraints: const BoxConstraints(maxWidth: 300),
-          // Prevent excessive width
-          child: Text(
-            statsText,
-            style: context.labelSmall?.copyWith(
-              color: context.onSurface.addOpacity(0.7),
-            ),
-            overflow: TextOverflow.ellipsis,
-            maxLines: 1,
-          ),
-        );
-      },
-    );
-  }
-
-  String _formatStatsText(Map<String, int> stats) {
-    final lines = stats['lines'] ?? 0;
-    final chars = stats['chars'] ?? 0;
-    final selectedLines = stats['selLn'] ?? 0;
-    final selectedChars = stats['selCh'] ?? 0;
-    final cursors = stats['carets'] ?? 1;
-
-    final selectionInfo = (selectedLines > 0 || selectedChars > 0)
-        ? ' (Sel Ln: $selectedLines Ch: $selectedChars)'
-        : '';
-
-    final cursorInfo = cursors > 1 ? ' ‚Äî $cursors cursors' : '';
-
-    return 'Ln: $lines Ch: $chars$selectionInfo$cursorInfo';
-  }
-
-  DropdownMenuItem<String> _buildLanguageMenuItem(
-      Map<String, String> language) {
-    return DropdownMenuItem<String>(
-      value: language['value'],
-      child: Text(
-        language['text']!,
-        style: context.labelMedium,
-      ),
-    );
-  }
-
-  Future<void> _handleLanguageChange(String? newLanguage) async {
-    if (newLanguage == null || newLanguage == _selectedLanguage) return;
-
-    try {
-      await widget.bridge.setLanguage(newLanguage);
-      // Language update will be handled by the listener
-    } catch (e) {
-      // Handle error silently or show a snackbar if needed
-    }
-  }
-
-  String _getLanguageDisplayName(String languageValue) {
-    final language = _availableLanguages.firstWhere(
-      (lang) => lang['value'] == languageValue,
-      orElse: () => {'text': languageValue.toUpperCase()},
-    );
-    return language['text']!;
-  }
-
-  List<Widget> _buildActionButtons() {
-    final buttons = [
-      (EneftyIcons.copy_outline, 'Copy Content', widget.onCopy),
-      (
-        EneftyIcons.textalign_justifyleft_outline,
-        'Format Content',
-        () => widget.bridge.format()
-      ),
-      (
-        EneftyIcons.arrow_circle_up_outline,
-        'Scroll to Top',
-        () => widget.bridge.scrollToTop()
-      ),
-      (
-        EneftyIcons.arrow_circle_down_outline,
-        'Scroll to Bottom',
-        () => widget.bridge.scrollToBottom()
-      ),
-    ];
-
-    return buttons
-        .map((buttonData) => _buildActionButton(
-              context,
-              icon: buttonData.$1,
-              tooltip: buttonData.$2,
-              onPressed: buttonData.$3,
-            ))
-        .toList();
-  }
-
-  Widget _buildLoadingIndicator(BuildContext context) {
-    return Container(
-      padding: const EdgeInsetsDirectional.symmetric(
-        horizontal: 16,
-        vertical: 12,
-      ),
-      decoration: BoxDecoration(
-        color: context.onSurface.addOpacity(0.05),
-        borderRadius: BorderRadius.circular(12),
-        border: Border.all(
-          color: context.onSurface.addOpacity(0.1),
-        ),
-      ),
-      child: Row(
-        mainAxisSize: MainAxisSize.min,
-        children: [
-          SizedBox(
-            width: 16,
-            height: 16,
-            child: CircularProgressIndicator(
-              strokeWidth: 2,
-              color: context.primary,
-            ),
-          ),
-          const SizedBox(width: 12),
-          Text(
-            'Initializing Monaco Editor...',
-            style: context.bodyMedium?.copyWith(
-              color: context.onSurface.addOpacity(0.6),
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildDropDown<T>({
-    required BuildContext context,
-    required IconData icon,
-    required T value,
-    required List<DropdownMenuItem<T>> items,
-    required ValueChanged<T?> onChanged,
-    required String Function(T value) displayNameBuilder,
-    String? tooltip,
-  }) {
-    // For language dropdown specifically, use PopupMenuButton for better positioning
-    if (T == String && items.length > 20) {
-      return _buildLanguagePopupMenu(
-        context: context,
-        icon: icon,
-        value: value as String,
-        onChanged: onChanged as ValueChanged<String?>,
-        displayNameBuilder: displayNameBuilder as String Function(String),
-        tooltip: tooltip,
-      );
-    }
-
-    // Default dropdown for other uses
-    return Tooltip(
-      message: tooltip ?? '',
-      child: Container(
-        padding: const EdgeInsetsDirectional.symmetric(
-          horizontal: 8,
-          vertical: 4,
-        ),
-        decoration: BoxDecoration(
-          color: context.onSurface.addOpacity(0.05),
-          borderRadius: BorderRadius.circular(8),
-        ),
-        child: Theme(
-          data: Theme.of(context).copyWith(
-            // This ensures the dropdown opens upward when at the bottom
-            popupMenuTheme: PopupMenuThemeData(
-              position: PopupMenuPosition.over,
-              color: context.surface,
-              elevation: 8,
-              shape: RoundedRectangleBorder(
-                borderRadius: BorderRadius.circular(8),
-              ),
-            ),
-          ),
-          child: DropdownButtonHideUnderline(
-            child: DropdownButton<T>(
-              icon: Icon(
-                Icons.arrow_drop_down,
-                size: 20,
-                color: context.onSurface.addOpacity(0.7),
-              ),
-              isDense: true,
-              value: value,
-              items: items,
-              onChanged: onChanged,
-              selectedItemBuilder: (context) => items
-                  .map((item) => _buildDropdownSelectedItem(
-                      icon, displayNameBuilder(value), context))
-                  .toList(),
-              hint: _buildDropdownHint(icon, context),
-              // Dropdown styling
-              dropdownColor: context.surface,
-              menuMaxHeight: 300, // Reduced to ensure it fits better
-              style: context.labelMedium,
-              borderRadius: BorderRadius.circular(8),
-              // Force dropdown to calculate position from bottom
-              menuWidth: 250, // Set fixed width for consistency
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildDropdownSelectedItem(
-      IconData icon, String displayName, BuildContext context) {
-    return Row(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        Icon(
-          icon,
-          size: 16,
-          color: context.primary,
-        ),
-        const SizedBox(width: 6),
-        Flexible(
-          child: Text(
-            displayName,
-            style: context.labelSmall?.copyWith(
-              color: context.onSurface.addOpacity(0.9),
-            ),
-            overflow: TextOverflow.ellipsis,
-            maxLines: 1,
-          ),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildDropdownHint(IconData icon, BuildContext context) {
-    return Row(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        Icon(
-          icon,
-          size: 16,
-          color: context.onSurface.addOpacity(0.7),
-        ),
-        const SizedBox(width: 6),
-        Text(
-          'Select...',
-          style: context.labelSmall,
-          overflow: TextOverflow.ellipsis,
-        ),
-      ],
-    );
-  }
-
-  Widget _buildActionButton(
-    BuildContext context, {
-    required IconData icon,
-    required String tooltip,
-    required VoidCallback? onPressed,
-  }) {
-    return IconButton(
-      icon: Icon(icon, size: 20),
-      tooltip: tooltip,
-      onPressed: onPressed,
-      style: IconButton.styleFrom(
-        foregroundColor: context.onSurface.addOpacity(0.7),
-        padding: const EdgeInsets.all(10),
-      ),
-      iconSize: 20,
-      splashRadius: 0.1, // Virtually removes splash
-      highlightColor: Colors.transparent,
-      splashColor: Colors.transparent,
-      hoverColor: context.onSurface.addOpacity(0.04),
-    );
-  }
-
-  Widget _buildLanguagePopupMenu({
-    required BuildContext context,
-    required IconData icon,
-    required String value,
-    required ValueChanged<String?> onChanged,
-    required String Function(String) displayNameBuilder,
-    String? tooltip,
-  }) {
-    return ThemeWithoutEffects(
-      child: Tooltip(
-        message: tooltip ?? '',
-        child: PopupMenuButton<String>(
-          tooltip: '',
-          position: PopupMenuPosition.over,
-          constraints: const BoxConstraints(
-            maxHeight: 400,
-            minWidth: 200,
-            maxWidth: 250,
-          ),
-          shape: RoundedRectangleBorder(
-            borderRadius: BorderRadius.circular(8),
-          ),
-          color: context.surface,
-          elevation: 8,
-          offset: const Offset(0, -8),
-          initialValue: value,
-          onSelected: onChanged,
-          splashRadius: 0.1,
-          enableFeedback: false,
-          itemBuilder: (BuildContext context) {
-            return _availableLanguages.map((language) {
-              final isSelected = language['value'] == value;
-              return PopupMenuItem<String>(
-                value: language['value'],
-                height: 40,
-                child: Container(
-                  padding: const EdgeInsets.symmetric(horizontal: 8),
-                  child: Row(
-                    children: [
-                      if (isSelected)
-                        Icon(
-                          Icons.check,
-                          size: 16,
-                          color: context.primary,
-                        )
-                      else
-                        const SizedBox(width: 16),
-                      const SizedBox(width: 8),
-                      Expanded(
-                        child: Text(
-                          language['text']!,
-                          style: context.labelMedium?.copyWith(
-                            color: isSelected ? context.primary : null,
-                            fontWeight: isSelected ? FontWeight.w600 : null,
-                          ),
-                        ),
-                      ),
-                    ],
-                  ),
-                ),
-              );
-            }).toList();
-          },
-          child: Container(
-            padding: const EdgeInsetsDirectional.symmetric(
-              horizontal: 8,
-              vertical: 6,
-            ),
-            decoration: BoxDecoration(
-              color: context.onSurface.addOpacity(0.05),
-              borderRadius: BorderRadius.circular(8),
-            ),
-            child: Row(
-              mainAxisSize: MainAxisSize.min,
-              children: [
-                Icon(
-                  icon,
-                  size: 16,
-                  color: context.primary,
-                ),
-                const SizedBox(width: 6),
-                Flexible(
-                  child: Text(
-                    displayNameBuilder(value),
-                    style: context.labelSmall?.copyWith(
-                      color: context.onSurface.addOpacity(0.9),
-                    ),
-                    overflow: TextOverflow.ellipsis,
-                    maxLines: 1,
-                  ),
-                ),
-                const SizedBox(width: 4),
-                Icon(
-                  Icons.arrow_drop_down,
-                  size: 20,
-                  color: context.onSurface.addOpacity(0.7),
-                ),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/editor/presentation/ui/monaco_editor_integrated.dart b/lib/src/features/editor/presentation/ui/monaco_editor_integrated.dart
deleted file mode 100644
index 415cfe2..0000000
--- a/lib/src/features/editor/presentation/ui/monaco_editor_integrated.dart
+++ /dev/null
@@ -1,838 +0,0 @@
-// ignore_for_file: avoid_dynamic_calls
-import 'dart:async';
-import 'dart:convert';
-import 'dart:io';
-
-import 'package:context_collector/src/features/editor/assets_manager/notifier.dart';
-import 'package:context_collector/src/features/editor/assets_manager/widget.dart';
-import 'package:context_collector/src/features/editor/bridge/monaco_bridge_platform.dart';
-import 'package:context_collector/src/features/editor/bridge/platform_webview_controller.dart';
-import 'package:context_collector/src/features/editor/utils/webview_debug_helper.dart';
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-// Platform-specific imports
-import 'package:webview_flutter/webview_flutter.dart' as wf;
-import 'package:webview_windows/webview_windows.dart' as ww;
-
-/// Monaco Editor that integrates with the asset management system
-class MonacoEditorIntegrated extends ConsumerStatefulWidget {
-  const MonacoEditorIntegrated({
-    required this.bridge,
-    super.key,
-    this.onReady,
-    this.height,
-    this.showAssetStatus = false,
-  });
-
-  final MonacoBridgePlatform bridge;
-  final VoidCallback? onReady;
-  final double? height;
-  final bool showAssetStatus;
-
-  @override
-  ConsumerState<MonacoEditorIntegrated> createState() =>
-      _MonacoEditorIntegratedState();
-}
-
-class _MonacoEditorIntegratedState
-    extends ConsumerState<MonacoEditorIntegrated> {
-  late PlatformWebViewController _webViewController;
-  bool _isWebViewLoading = true;
-  String? _webViewError;
-  Timer? _initTimer;
-  Timer? _readinessCheckTimer;
-  bool _bridgeIsMarkedReady = false;
-  String _webViewStatus = 'Starting WebView...';
-  int _readinessCheckCount = 0;
-
-  @override
-  void initState() {
-    super.initState();
-    debugPrint('[MonacoEditorIntegrated] initState');
-    _checkAssetsAndInitialize();
-  }
-
-  @override
-  void dispose() {
-    debugPrint('[MonacoEditorIntegrated] dispose');
-    _initTimer?.cancel();
-    _readinessCheckTimer?.cancel();
-    widget.bridge.detachWebView();
-    _webViewController.dispose();
-    super.dispose();
-  }
-
-  /// Check if assets are ready and initialize WebView accordingly
-  Future<void> _checkAssetsAndInitialize() async {
-    final assetStatus = ref.read(monacoAssetStatusProvider);
-
-    if (assetStatus.isReady) {
-      // Assets are ready, initialize WebView immediately
-      await _initWebView();
-    } else if (assetStatus.hasError) {
-      // Assets failed to load, show error
-      setState(() {
-        _webViewError = 'Monaco assets failed to load: ${assetStatus.error}';
-        _isWebViewLoading = false;
-      });
-    } else {
-      // Assets are still loading, wait for them
-      _updateWebViewStatus('Waiting for Monaco assets...');
-    }
-  }
-
-  /// Initialize WebView with ready assets
-  Future<void> _initWebView() async {
-    try {
-      _updateWebViewStatus('Initializing WebView...');
-
-      // Get the asset path from the asset manager
-      final assetPath = ref.read(monacoAssetPathProvider);
-      if (assetPath == null) {
-        throw Exception('Monaco asset path not available');
-      }
-
-      // Setup timeout - give plenty of time for Windows
-      _initTimer = Timer(const Duration(seconds: 90), () {
-        if (!widget.bridge.isReady && mounted) {
-          setState(() {
-            _webViewError =
-                'Monaco Editor initialization timed out after 90 seconds.\n'
-                'Please check the debug console for errors.';
-            _isWebViewLoading = false;
-          });
-        }
-      });
-
-      // Create platform-specific controller
-      _webViewController = PlatformWebViewFactory.createController();
-
-      if (Platform.isWindows) {
-        await _initWindowsWebView(assetPath);
-      } else {
-        await _initFlutterWebView(assetPath);
-      }
-
-      // Attach to bridge
-      _updateWebViewStatus('Connecting to Monaco bridge...');
-      widget.bridge.attachWebView(_webViewController);
-
-      debugPrint('[MonacoEditorIntegrated] WebView initialization completed');
-    } catch (e) {
-      debugPrint('[MonacoEditorIntegrated] WebView initialization error: $e');
-      if (mounted) {
-        setState(() {
-          _webViewError = 'Failed to initialize Monaco WebView: $e';
-          _isWebViewLoading = false;
-        });
-      }
-    }
-  }
-
-  Future<void> _initWindowsWebView(String assetPath) async {
-    final controller = _webViewController as WindowsWebViewController;
-
-    _updateWebViewStatus('Setting up Windows WebView2...');
-    await controller.initialize();
-
-    // Add a script that will be executed on every page load
-    _updateWebViewStatus('Injecting communication scripts...');
-    await controller.windowsController.addScriptToExecuteOnDocumentCreated('''
-      // Create flutterChannel immediately when document is created
-      console.log('[Windows Init] Creating flutterChannel on document creation');
-      window.flutterChannel = {
-        postMessage: function(msg) {
-          console.log('[flutterChannel] Posting message:', msg);
-          if (window.chrome && window.chrome.webview) {
-            window.chrome.webview.postMessage(msg);
-          } else {
-            console.error('[flutterChannel] WebView2 API not available!');
-          }
-        }
-      };
-      console.log('[Windows Init] flutterChannel created successfully');
-    ''');
-
-    _updateWebViewStatus('Setting up communication channel...');
-    await controller.addJavaScriptChannel('flutterChannel', _handleMessage);
-
-    _updateWebViewStatus('Loading Monaco Editor...');
-    await _loadMonacoForWindows(controller, assetPath);
-  }
-
-  Future<void> _initFlutterWebView(String assetPath) async {
-    final controller = _webViewController as FlutterWebViewController;
-
-    _updateWebViewStatus('Configuring WebView...');
-    await controller.setJavaScriptMode();
-
-    if (!Platform.isMacOS) {
-      await controller.setBackgroundColor(Colors.transparent);
-    }
-
-    _updateWebViewStatus('Setting up communication...');
-    await controller.addJavaScriptChannel('flutterChannel', _handleMessage);
-
-    _updateWebViewStatus('Setting up navigation...');
-    controller.setNavigationDelegate(
-      wf.NavigationDelegate(
-        onProgress: _onLoadProgress,
-        onPageFinished: (_) => _onPageLoaded(),
-        onWebResourceError: _onLoadError,
-        onNavigationRequest: (wf.NavigationRequest request) {
-          if (request.url.startsWith('flutter://')) {
-            final payload = Uri.decodeFull(request.url.substring(10));
-            _handleUrlMessage(payload);
-            return wf.NavigationDecision.prevent;
-          }
-          return wf.NavigationDecision.navigate;
-        },
-      ),
-    );
-
-    _updateWebViewStatus('Loading Monaco Editor...');
-    await _loadMonacoForFlutter(controller, assetPath);
-  }
-
-  void _onLoadProgress(int progress) {
-    _updateWebViewStatus('Loading Monaco... ($progress%)');
-
-    if (progress == 100 && !Platform.isWindows) {
-      _injectReadinessDetection();
-    }
-  }
-
-  // Test method for Windows debugging
-  Future<void> _loadTestHtmlForWindows(
-      WindowsWebViewController controller) async {
-    debugPrint('[MonacoEditorIntegrated] Loading test HTML for Windows...');
-
-    const testHtml = '''
-<!DOCTYPE html>
-<html>
-<head>
-    <title>Windows Test</title>
-    <style>
-        body { background: #1e1e1e; color: white; padding: 20px; font-family: sans-serif; }
-    </style>
-</head>
-<body>
-    <h1>WebView2 Test</h1>
-    <div id="status">Checking communication...</div>
-    
-    <script>
-        const status = document.getElementById('status');
-        
-        // Test flutterChannel
-        if (window.flutterChannel) {
-            status.innerHTML += '<br>‚úì flutterChannel exists';
-            
-            // Send test message
-            window.flutterChannel.postMessage(JSON.stringify({
-                event: 'test',
-                message: 'Hello from test page'
-            }));
-            
-            // Send ready event after delay
-            setTimeout(() => {
-                window.flutterChannel.postMessage(JSON.stringify({
-                    event: 'onEditorReady',
-                    detail: 'Test page ready'
-                }));
-                status.innerHTML += '<br>‚úì Ready event sent';
-            }, 1000);
-        } else {
-            status.innerHTML += '<br>‚úó flutterChannel NOT found';
-        }
-        
-        // Test WebView2 API
-        if (window.chrome && window.chrome.webview) {
-            status.innerHTML += '<br>‚úì WebView2 API available';
-        } else {
-            status.innerHTML += '<br>‚úó WebView2 API NOT found';
-        }
-    </script>
-</body>
-</html>
-''';
-
-    await controller.loadHtmlString(testHtml);
-  }
-
-  Future<void> _loadMonacoForWindows(
-      WindowsWebViewController controller, String assetPath) async {
-    // Uncomment to test with simple HTML first
-    // await _loadTestHtmlForWindows(controller);
-    // return;
-
-    try {
-      debugPrint('[MonacoEditorIntegrated] Loading Monaco for Windows...');
-      debugPrint('  Asset path: $assetPath');
-
-      // Verify the VS directory exists
-      final vsDir = Directory('$assetPath/monaco-editor/min/vs');
-      if (!vsDir.existsSync()) {
-        throw Exception('VS directory not found at: ${vsDir.path}');
-      }
-
-      // Load the index.html template from assets
-      const asset = 'assets/monaco/index.html';
-      var htmlContent = await rootBundle.loadString(asset);
-
-      // For Windows, we need to handle paths carefully
-      // Use absolute file paths without file:/// to avoid CORS issues
-      final normalizedPath = assetPath.replaceAll(r'\', '/');
-
-      // Replace the VS_PATH placeholder with the actual path
-      // For Windows, we'll use a different approach in the HTML
-      htmlContent = htmlContent.replaceAll(
-          '__VS_PATH__', '$normalizedPath/monaco-editor/min/vs');
-
-      // Load the modified HTML
-      await controller.loadHtmlString(htmlContent);
-
-      // Start checking for readiness after the page loads
-      _readinessCheckTimer = Timer.periodic(const Duration(seconds: 1), (_) {
-        _checkWindowsEditorReadiness();
-      });
-    } catch (e) {
-      debugPrint('[MonacoEditorIntegrated] Windows loading error: $e');
-      throw Exception('Failed to load Monaco HTML for Windows: $e');
-    }
-  }
-
-  Future<void> _checkWindowsEditorReadiness() async {
-    if (!mounted || _bridgeIsMarkedReady) {
-      _readinessCheckTimer?.cancel();
-      return;
-    }
-
-    _readinessCheckCount++;
-    debugPrint(
-        '[MonacoEditorIntegrated] Checking Windows readiness (attempt $_readinessCheckCount)...');
-
-    try {
-      // First check if the page is loaded and flutterChannel exists
-      await _webViewController.runJavaScript('''
-        (function() {
-          console.log('[Ready Check] Checking environment...');
-          const status = {
-            hasRequire: typeof require !== 'undefined',
-            hasMonaco: typeof monaco !== 'undefined',
-            hasEditor: typeof window.editor !== 'undefined',
-            hasFlutterChannel: typeof window.flutterChannel !== 'undefined',
-            documentReady: document.readyState === 'complete',
-            monacoStatus: window.monacoStatus || {}
-          };
-          console.log('[Ready Check] Status:', JSON.stringify(status, null, 2));
-          
-          // If editor exists but we haven't sent ready event, force it
-          if (status.hasEditor && status.hasFlutterChannel && window.editor) {
-            console.log('[Ready Check] Editor found! Forcing ready event...');
-            
-            // Make sure all API functions are available
-            if (!window.setEditorContent) {
-              window.setEditorContent = function(content) {
-                if (window.editor) window.editor.setValue(content || '');
-              };
-            }
-            if (!window.getEditorContent) {
-              window.getEditorContent = function() {
-                return window.editor ? window.editor.getValue() : '';
-              };
-            }
-            if (!window.setEditorLanguage) {
-              window.setEditorLanguage = function(language) {
-                if (window.editor && window.editor.getModel()) {
-                  monaco.editor.setModelLanguage(window.editor.getModel(), language);
-                }
-              };
-            }
-            if (!window.setEditorTheme) {
-              window.setEditorTheme = function(theme) {
-                if (monaco) monaco.editor.setTheme(theme);
-              };
-            }
-            if (!window.setEditorOptions) {
-              window.setEditorOptions = function(options) {
-                if (window.editor) window.editor.updateOptions(options);
-              };
-            }
-            
-            // Send ready event
-            window.flutterChannel.postMessage(JSON.stringify({
-              event: 'onEditorReady',
-              payload: {
-                detail: 'Windows editor ready (forced)',
-                checkCount: $_readinessCheckCount
-              }
-            }));
-            
-            // Stop checking after sending ready
-            return true;
-          } else if (!status.hasRequire && status.documentReady) {
-            console.error('[Ready Check] CRITICAL: require is not defined after document ready!');
-            window.flutterChannel.postMessage(JSON.stringify({
-              event: 'error',
-              message: 'require is not defined - Monaco loader failed'
-            }));
-            return true; // Stop checking
-          }
-          
-          return false; // Continue checking
-        })();
-      ''').then((Object? result) {
-        if (result.asBool) {
-          _readinessCheckTimer?.cancel();
-        }
-      });
-    } catch (e) {
-      debugPrint('[MonacoEditorIntegrated] Ready check error: $e');
-    }
-
-    // Stop checking after 30 attempts (30 seconds) - reduced from 60
-    if (_readinessCheckCount >= 30) {
-      _readinessCheckTimer?.cancel();
-      if (!_bridgeIsMarkedReady && mounted) {
-        setState(() {
-          _webViewError =
-              'Monaco Editor failed to initialize after 30 seconds.\n'
-              'The editor may not have loaded properly.';
-          _isWebViewLoading = false;
-        });
-      }
-    }
-  }
-
-  Future<void> _loadMonacoForFlutter(
-      FlutterWebViewController controller, String assetPath) async {
-    try {
-      // Load the HTML template
-      const asset = 'assets/monaco/index.html';
-      final htmlContent = await rootBundle.loadString(asset);
-
-      // Replace the VS path with our prepared asset path
-      final vsPath = '$assetPath/monaco-editor/min/vs';
-      final modifiedHtml = htmlContent.replaceAll('__VS_PATH__', vsPath);
-
-      // Write to a temporary file and load it
-      final tempFile = File('$assetPath/index.html');
-      await tempFile.writeAsString(modifiedHtml);
-
-      await controller.loadFile(tempFile.path);
-    } catch (e) {
-      throw Exception('Failed to load Monaco HTML: $e');
-    }
-  }
-
-  Future<void> _injectReadinessDetection() async {
-    // For non-Windows platforms
-    await _webViewController.runJavaScript('''
-      // Listen for console logs that indicate editor is ready
-      const originalLog = console.log;
-      console.log = function(...args) {
-        originalLog.apply(console, args);
-        const message = args.join(' ');
-        
-        // Check for various ready indicators
-        if (message.includes('Monaco editor instance created') ||
-            message.includes('ENHANCED_EDITOR_READY_EVENT_FIRED') ||
-            message.includes('onEditorReady')) {
-          if (window.flutterChannel) {
-            window.flutterChannel.postMessage(JSON.stringify({
-              event: 'onEditorReady',
-              detail: 'Editor ready detected from console'
-            }));
-          }
-        }
-      };
-
-      // Also check periodically
-      setTimeout(function checkReady() {
-        if (window.editor && window.flutterChannel) {
-          window.flutterChannel.postMessage(JSON.stringify({
-            event: 'onEditorReady',
-            detail: 'Editor ready via periodic check'
-          }));
-        } else {
-          setTimeout(checkReady, 1000);
-        }
-      }, 1000);
-    ''');
-  }
-
-  void _handleMessage(String message) {
-    debugPrint(
-        '[MonacoEditorIntegrated] Received message: ${message.substring(0, message.length.clamp(0, 200))}...');
-
-    if (message.startsWith('log:')) {
-      return; // Skip log messages
-    }
-
-    try {
-      final decoded = json.decode(message) as Map<String, dynamic>;
-
-      if (decoded['event'] == 'onEditorReady') {
-        if (!_bridgeIsMarkedReady) {
-          _readinessCheckTimer?.cancel();
-
-          // Extract detail from various possible locations
-          final detail = decoded['detail'] ??
-              decoded['payload']?['detail'] ??
-              'Editor ready';
-
-          debugPrint('[MonacoEditorIntegrated] ‚úÖ Editor ready: $detail');
-
-          widget.bridge.markReady();
-          _bridgeIsMarkedReady = true;
-          widget.onReady?.call();
-
-          if (mounted) {
-            setState(() {
-              _isWebViewLoading = false;
-              _webViewError = null;
-            });
-          }
-          _initTimer?.cancel();
-        }
-      } else if (decoded['event'] == 'error') {
-        final errorMessage = decoded['message'] ??
-            decoded['payload']?['message'] ??
-            'Unknown error';
-        debugPrint('[MonacoEditorIntegrated] ‚ùå Editor error: $errorMessage');
-
-        if (mounted && !_bridgeIsMarkedReady) {
-          setState(() {
-            _webViewError = 'Monaco Error: $errorMessage';
-            _isWebViewLoading = false;
-          });
-        }
-        _initTimer?.cancel();
-      } else if (decoded['event'] == 'channelTest') {
-        debugPrint(
-            '[MonacoEditorIntegrated] Channel test received: ${decoded['message']}');
-      } else if (decoded['event'] == 'stats') {
-        // Forward stats to bridge
-        widget.bridge.handleJavaScriptMessage(message);
-      }
-
-      // Forward all messages to bridge
-      widget.bridge.handleJavaScriptMessage(message);
-    } catch (e) {
-      debugPrint('[MonacoEditorIntegrated] Error parsing message: $e');
-      // Still forward to bridge even if we can't parse it
-      widget.bridge.handleJavaScriptMessage(message);
-    }
-  }
-
-  void _handleUrlMessage(String payload) {
-    debugPrint('[MonacoEditorIntegrated] URL message: $payload');
-
-    // Handle flutter:// URL scheme messages
-    try {
-      if (payload == 'onEditorReady') {
-        _handleMessage(json.encode(
-            {'event': 'onEditorReady', 'detail': 'Ready via URL scheme'}));
-      }
-    } catch (e) {
-      debugPrint('[MonacoEditorIntegrated] Error handling URL message: $e');
-    }
-  }
-
-  void _onPageLoaded() {
-    debugPrint('[MonacoEditorIntegrated] Page loaded');
-    _updateWebViewStatus('Monaco page loaded, waiting for initialization...');
-  }
-
-  void _onLoadError(wf.WebResourceError error) {
-    debugPrint(
-        '[MonacoEditorIntegrated] WebResourceError: ${error.description}');
-    _initTimer?.cancel();
-    _readinessCheckTimer?.cancel();
-
-    if (mounted) {
-      setState(() {
-        _webViewError = 'Failed to load Monaco: ${error.description}';
-        _isWebViewLoading = false;
-      });
-    }
-  }
-
-  void _updateWebViewStatus(String status) {
-    if (mounted) {
-      setState(() {
-        _webViewStatus = status;
-      });
-    }
-    debugPrint('[MonacoEditorIntegrated] Status: $status');
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final assetStatus = ref.watch(monacoAssetStatusProvider);
-
-    // Listen for asset status changes
-    ref.listen<MonacoAssetStatus>(monacoAssetStatusProvider, (previous, next) {
-      if (previous?.state != next.state) {
-        if (next.isReady && _isWebViewLoading && _webViewError == null) {
-          // Assets just became ready, initialize WebView
-          _initWebView();
-        } else if (next.hasError) {
-          // Assets failed
-          setState(() {
-            _webViewError = 'Monaco assets error: ${next.error}';
-            _isWebViewLoading = false;
-          });
-        }
-      }
-    });
-
-    return SizedBox(
-      height: widget.height ?? double.infinity,
-      child: Column(
-        children: [
-          // Asset status indicator (optional)
-          if (widget.showAssetStatus) ...[
-            Container(
-              padding: const EdgeInsetsDirectional.symmetric(
-                  horizontal: 16, vertical: 8),
-              child: Row(
-                children: [
-                  const MonacoAssetLoadingIndicator(size: 16),
-                  const SizedBox(width: 8),
-                  Text(
-                    assetStatus.isReady
-                        ? 'Assets Ready'
-                        : 'Preparing Assets...',
-                    style: context.bodySmall?.copyWith(
-                      color: context.onSurfaceVariant,
-                    ),
-                  ),
-                ],
-              ),
-            ),
-            const Divider(height: 1),
-          ],
-
-          // Main editor area
-          Expanded(
-            child: _buildEditorContent(assetStatus),
-          ),
-        ],
-      ),
-    );
-  }
-
-  Widget _buildEditorContent(MonacoAssetStatus assetStatus) {
-    // Show asset loading if assets aren't ready yet
-    if (!assetStatus.isReady && !assetStatus.hasError) {
-      return const Center(
-        child: MonacoAssetLoadingWidget(compact: true),
-      );
-    }
-
-    // Show error if there's a WebView error
-    if (_webViewError != null) {
-      return _buildErrorView();
-    }
-
-    // Show the WebView with loading overlay if needed
-    return Stack(
-      children: [
-        _buildWebView(),
-        if (_isWebViewLoading) _buildWebViewLoadingOverlay(),
-      ],
-    );
-  }
-
-  Widget _buildWebView() {
-    if (Platform.isWindows) {
-      final controller = _webViewController as WindowsWebViewController;
-      return ww.Webview(controller.windowsController);
-    } else {
-      final controller = _webViewController as FlutterWebViewController;
-      return wf.WebViewWidget(controller: controller.flutterController);
-    }
-  }
-
-  Widget _buildWebViewLoadingOverlay() {
-    return ColoredBox(
-      color: context.isDark ? const Color(0xFF1E1E1E) : Colors.white,
-      child: Center(
-        child: Column(
-          mainAxisSize: MainAxisSize.min,
-          children: [
-            const CircularProgressIndicator(),
-            const SizedBox(height: 16),
-            Text(
-              'Starting Monaco Editor...',
-              style: context.bodyMedium?.copyWith(
-                color: context.onSurface.addOpacity(0.8),
-              ),
-            ),
-            const SizedBox(height: 8),
-            Text(
-              _webViewStatus,
-              style: context.bodySmall?.copyWith(
-                color: context.onSurface.addOpacity(0.6),
-              ),
-            ),
-            if (Platform.isWindows && _readinessCheckCount > 5) ...[
-              const SizedBox(height: 8),
-              Text(
-                'Check attempt: $_readinessCheckCount',
-                style: context.bodySmall?.copyWith(
-                  color: context.onSurface.addOpacity(0.4),
-                ),
-              ),
-            ],
-          ],
-        ),
-      ),
-    );
-  }
-
-  Widget _buildErrorView() {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(32),
-      child: Center(
-        child: Column(
-          mainAxisSize: MainAxisSize.min,
-          children: [
-            Icon(
-              Icons.error_outline,
-              size: 64,
-              color: context.error,
-            ),
-            const SizedBox(height: 16),
-            Text(
-              'Monaco Editor Error',
-              style: context.titleLarge?.copyWith(
-                color: context.error,
-              ),
-            ),
-            const SizedBox(height: 8),
-            Container(
-              padding: const EdgeInsetsDirectional.all(16),
-              decoration: BoxDecoration(
-                color: context.errorContainer,
-                borderRadius: BorderRadius.circular(8),
-              ),
-              child: Text(
-                _webViewError ?? 'Unknown error',
-                textAlign: TextAlign.center,
-                style: context.bodyMedium?.copyWith(
-                  color: context.onErrorContainer,
-                ),
-              ),
-            ),
-            const SizedBox(height: 24),
-            Row(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                OutlinedButton.icon(
-                  onPressed: () {
-                    setState(() {
-                      _webViewError = null;
-                      _isWebViewLoading = true;
-                      _bridgeIsMarkedReady = false;
-                      _webViewStatus = 'Retrying...';
-                      _readinessCheckCount = 0;
-                    });
-                    _checkAssetsAndInitialize();
-                  },
-                  icon: const Icon(Icons.refresh),
-                  label: const Text('Retry'),
-                ),
-                const SizedBox(width: 16),
-                Consumer(
-                  builder: (context, ref, child) {
-                    return TextButton.icon(
-                      onPressed: () => ref
-                          .read(monacoAssetManagerProvider)
-                          .retryInitialization(),
-                      icon: const Icon(Icons.refresh),
-                      label: const Text('Reload Assets'),
-                    );
-                  },
-                ),
-                if (Platform.isWindows) ...[
-                  const SizedBox(width: 16),
-                  PopupMenuButton<String>(
-                    icon: const Icon(Icons.bug_report),
-                    tooltip: 'Debug Options',
-                    onSelected: (value) async {
-                      switch (value) {
-                        case 'test_basic':
-                          await WebViewDebugHelper.testWebView2Basic();
-                        case 'test_monaco':
-                          final assetPath = ref.read(monacoAssetPathProvider);
-                          if (assetPath != null) {
-                            await WebViewDebugHelper.testMonacoLoading(
-                                assetPath);
-                          }
-                        case 'test_file':
-                          final assetPath = ref.read(monacoAssetPathProvider);
-                          if (assetPath != null) {
-                            await WebViewDebugHelper.testFileUrlAccess(
-                                assetPath);
-                          }
-                        case 'open_devtools':
-                          try {
-                            if (_webViewController
-                                is WindowsWebViewController) {
-                              final winController = _webViewController
-                                  as WindowsWebViewController;
-                              await winController.windowsController
-                                  .openDevTools();
-                            }
-                          } catch (e) {
-                            debugPrint('Error opening DevTools: $e');
-                          }
-                        case 'reload_test':
-                          if (_webViewController is WindowsWebViewController) {
-                            setState(() {
-                              _isWebViewLoading = true;
-                              _webViewError = null;
-                            });
-                            await _loadTestHtmlForWindows(
-                                _webViewController as WindowsWebViewController);
-                          }
-                      }
-                    },
-                    itemBuilder: (context) => [
-                      const PopupMenuItem(
-                        value: 'test_basic',
-                        child: Text('Test Basic WebView2'),
-                      ),
-                      const PopupMenuItem(
-                        value: 'test_monaco',
-                        child: Text('Test Monaco Loading'),
-                      ),
-                      const PopupMenuItem(
-                        value: 'test_file',
-                        child: Text('Test File URL Access'),
-                      ),
-                      const PopupMenuDivider(),
-                      const PopupMenuItem(
-                        value: 'open_devtools',
-                        child: Text('Open DevTools'),
-                      ),
-                      const PopupMenuDivider(),
-                      const PopupMenuItem(
-                        value: 'reload_test',
-                        child: Text('Load Test HTML'),
-                      ),
-                    ],
-                  ),
-                ],
-              ],
-            ),
-          ],
-        ),
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/editor/services/monaco_editor_providers.dart b/lib/src/features/editor/services/monaco_editor_providers.dart
deleted file mode 100644
index 28ad077..0000000
--- a/lib/src/features/editor/services/monaco_editor_providers.dart
+++ /dev/null
@@ -1,74 +0,0 @@
-// lib/src/features/editor/services/monaco_editor_providers.dart
-import 'package:context_collector/src/features/editor/assets_manager/notifier.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_service.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_state.dart';
-import 'package:flutter/cupertino.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-/// Provider for Monaco editor status
-final monacoEditorStatusProvider =
-    StateNotifierProvider<MonacoEditorStatusNotifier, MonacoEditorStatus>(
-        (ref) {
-  return MonacoEditorStatusNotifier();
-});
-
-/// Provider for the global Monaco editor service
-final monacoEditorServiceProvider = Provider<MonacoEditorService>((ref) {
-  final service = MonacoEditorService(ref);
-
-  // Dispose when provider is disposed
-  ref
-    ..onDispose(service.dispose)
-
-    // Listen to asset status changes to automatically initialize when ready
-    ..listen<MonacoAssetStatus>(monacoAssetStatusProvider, (previous, next) {
-      final editorStatus = ref.read(monacoEditorStatusProvider);
-
-      // If assets just became ready and editor is idle, initialize
-      if (previous?.isReady != true &&
-          next.isReady &&
-          editorStatus.state == MonacoEditorServiceState.idle) {
-        debugPrint(
-            '[MonacoEditorServiceProvider] Assets ready, initializing editor');
-        service.initialize();
-      }
-
-      // If assets failed and editor was waiting, update status
-      if (next.hasError &&
-          editorStatus.state == MonacoEditorServiceState.waitingForAssets) {
-        ref.read(monacoEditorStatusProvider.notifier).updateStatus(
-              MonacoEditorStatus(
-                state: MonacoEditorServiceState.error,
-                error: 'Monaco assets failed to load: ${next.error}',
-                lastUpdate: DateTime.now(),
-              ),
-            );
-      }
-    });
-
-  return service;
-});
-
-/// Convenient provider for checking if editor is ready
-final monacoEditorReadyProvider = Provider<bool>((ref) {
-  final status = ref.watch(monacoEditorStatusProvider);
-  return status.isReady;
-});
-
-/// Provider for checking if editor should be visible
-final monacoEditorVisibleProvider = Provider<bool>((ref) {
-  final status = ref.watch(monacoEditorStatusProvider);
-  return status.isVisible;
-});
-
-/// Provider for checking if editor can be shown (ready + has content)
-final monacoEditorCanShowProvider = Provider<bool>((ref) {
-  final status = ref.watch(monacoEditorStatusProvider);
-  return status.canShow;
-});
-
-/// Provider for editor loading progress
-final monacoEditorProgressProvider = Provider<double>((ref) {
-  final status = ref.watch(monacoEditorStatusProvider);
-  return status.progress;
-});
diff --git a/lib/src/features/editor/services/monaco_editor_service.dart b/lib/src/features/editor/services/monaco_editor_service.dart
deleted file mode 100644
index 827dd20..0000000
--- a/lib/src/features/editor/services/monaco_editor_service.dart
+++ /dev/null
@@ -1,290 +0,0 @@
-// lib/src/features/editor/services/monaco_editor_service.dart
-import 'dart:async';
-
-import 'package:context_collector/src/features/editor/bridge/monaco_bridge_platform.dart';
-import 'package:context_collector/src/features/editor/domain/editor_settings.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_providers.dart';
-import 'package:context_collector/src/features/editor/services/monaco_editor_state.dart';
-import 'package:flutter/foundation.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-/// Global Monaco Editor Service
-/// Manages a single instance of Monaco Editor throughout the app lifecycle
-class MonacoEditorService {
-  MonacoEditorService(this._ref) {
-    _bridge = MonacoBridgePlatform();
-    _config = const MonacoEditorConfig(showInitContent: false);
-  }
-
-  final Ref _ref;
-  late final MonacoBridgePlatform _bridge;
-  late final MonacoEditorConfig _config;
-
-  Completer<void>? _initCompleter;
-  Timer? _retryTimer;
-  StreamSubscription<dynamic>? _assetStatusSubscription;
-
-  // Content management
-  String? _currentContent;
-  String? _queuedContent;
-  bool _isContentUpdatePending = false;
-
-  /// Get the bridge instance (for UI components)
-  MonacoBridgePlatform get bridge => _bridge;
-
-  /// Get current editor content
-  String? get currentContent => _currentContent;
-
-  /// Initialize the editor service
-  /// This should be called once at app startup after assets are ready
-  Future<void> initialize() async {
-    debugPrint('[MonacoEditorService] Starting initialization');
-
-    // Check current state
-    final currentStatus = _ref.read(monacoEditorStatusProvider);
-    if (currentStatus.state != MonacoEditorServiceState.idle) {
-      debugPrint(
-          '[MonacoEditorService] Already initialized or initializing: ${currentStatus.state}');
-      return;
-    }
-
-    // Prevent multiple initializations
-    if (_initCompleter != null) {
-      debugPrint('[MonacoEditorService] Already initializing, waiting...');
-      return _initCompleter!.future;
-    }
-
-    _initCompleter = Completer<void>();
-
-    try {
-      // Update state to trigger UI creation
-      _updateStatus(MonacoEditorStatus(
-        state: MonacoEditorServiceState.initializing,
-        progress: 0.1,
-        message: 'Initializing Monaco Editor...',
-        lastUpdate: DateTime.now(),
-      ));
-
-      // Mark as loading - this will trigger the UI to create the WebView
-      _updateStatus(MonacoEditorStatus(
-        state: MonacoEditorServiceState.loading,
-        progress: 0.5,
-        message: 'Loading Monaco Editor...',
-        lastUpdate: DateTime.now(),
-      ));
-
-      // The actual readiness will be signaled by the UI component
-      // via markEditorReady()
-    } catch (e) {
-      await _handleInitializationError(e);
-    }
-  }
-
-  /// Called by the UI when the editor WebView is ready
-  void markEditorReady() {
-    debugPrint('[MonacoEditorService] Editor marked as ready');
-
-    _updateStatus(MonacoEditorStatus(
-      state: MonacoEditorServiceState.ready,
-      progress: 1,
-      message: 'Monaco Editor ready',
-      isVisible: true, // Always visible in layered architecture
-      hasContent: _currentContent != null || _config.showInitContent,
-      lastUpdate: DateTime.now(),
-    ));
-
-    // Complete initialization
-    _initCompleter?.complete();
-    _initCompleter = null;
-
-    // Set initial content if configured
-    if (_config.showInitContent &&
-        _currentContent == null &&
-        _queuedContent == null) {
-      Future.microtask(() async {
-        await _bridge.setContent(_config.initContent);
-        await _bridge.setLanguage(_config.initLanguage);
-      });
-    }
-
-    // Process any queued content
-    if (_queuedContent != null) {
-      debugPrint('[MonacoEditorService] Processing queued content');
-      final content = _queuedContent!;
-      _queuedContent = null;
-      setContent(content);
-    }
-  }
-
-  /// Set editor content
-  Future<void> setContent(String content) async {
-    debugPrint(
-        '[MonacoEditorService] Setting content (length: ${content.length})');
-
-    _currentContent = content;
-    final status = _ref.read(monacoEditorStatusProvider);
-
-    // If not ready, queue the content
-    if (!status.isReady) {
-      debugPrint('[MonacoEditorService] Editor not ready, queueing content');
-      _queuedContent = content;
-      _updateStatus(status.copyWith(
-        queuedContent: content,
-        hasContent: true,
-      ));
-      return;
-    }
-
-    // Prevent concurrent updates
-    if (_isContentUpdatePending) {
-      _queuedContent = content;
-      return;
-    }
-
-    _isContentUpdatePending = true;
-
-    try {
-      await _bridge.setContent(content);
-
-      _updateStatus(status.copyWith(
-        hasContent: content.isNotEmpty,
-      ));
-
-      // Process any content that was queued during update
-      if (_queuedContent != null) {
-        final nextContent = _queuedContent!;
-        _queuedContent = null;
-        await setContent(nextContent);
-      }
-    } finally {
-      _isContentUpdatePending = false;
-    }
-  }
-
-  /// Clear editor content
-  Future<void> clearContent() async {
-    debugPrint('[MonacoEditorService] Clearing content');
-
-    // Set back to init content if configured
-    if (_config.showInitContent) {
-      await setContent(_config.initContent);
-      await _bridge.setLanguage(_config.initLanguage);
-    } else {
-      await setContent('');
-    }
-
-    _currentContent = null;
-  }
-
-  /// Show the editor (no longer needed with layered architecture)
-  @Deprecated('Editor visibility is now managed by overlay')
-  void show() {
-    debugPrint('[MonacoEditorService] Show requested (deprecated)');
-    // No-op: visibility is now controlled by the overlay
-  }
-
-  /// Hide the editor (no longer needed with layered architecture)
-  @Deprecated('Editor visibility is now managed by overlay')
-  void hide() {
-    debugPrint('[MonacoEditorService] Hide requested (deprecated)');
-    // No-op: visibility is now controlled by the overlay
-  }
-
-  /// Apply editor settings
-  Future<void> applySettings(EditorSettings settings) async {
-    final status = _ref.read(monacoEditorStatusProvider);
-    if (status.isReady) {
-      await _bridge.updateSettings(settings);
-      await _bridge.applyKeybindingPreset(settings.keybindingPreset);
-
-      if (settings.customKeybindings.isNotEmpty) {
-        await _bridge.setupKeybindings(settings.customKeybindings);
-      }
-    }
-  }
-
-  /// Retry initialization after error
-  Future<void> retryInitialization() async {
-    debugPrint('[MonacoEditorService] Manual retry requested');
-
-    _retryTimer?.cancel();
-    _initCompleter = null;
-
-    await initialize();
-  }
-
-  /// Get current status
-  MonacoEditorStatus get status => _ref.read(monacoEditorStatusProvider);
-
-  /// Get live stats from the editor
-  ValueNotifier<Map<String, int>> get liveStats => _bridge.liveStats;
-
-  // Private methods
-
-  void _updateStatus(MonacoEditorStatus status) {
-    _ref.read(monacoEditorStatusProvider.notifier).updateStatus(status);
-  }
-
-  Future<void> _handleInitializationError(dynamic error) async {
-    final currentStatus = _ref.read(monacoEditorStatusProvider);
-    final newRetryCount = currentStatus.retryCount + 1;
-
-    debugPrint(
-        '[MonacoEditorService] Initialization error (attempt $newRetryCount): $error');
-
-    if (newRetryCount >= _config.maxRetries) {
-      _updateStatus(MonacoEditorStatus(
-        state: MonacoEditorServiceState.error,
-        error:
-            'Failed to initialize Monaco Editor after ${_config.maxRetries} attempts: $error',
-        retryCount: newRetryCount,
-        lastUpdate: DateTime.now(),
-      ));
-
-      _initCompleter?.completeError(error.toString());
-      _initCompleter = null;
-      return;
-    }
-
-    // Calculate retry delay with exponential backoff
-    final retryDelay = _config.retryDelay * newRetryCount;
-
-    _updateStatus(MonacoEditorStatus(
-      state: MonacoEditorServiceState.retrying,
-      message:
-          'Retrying in ${retryDelay.inSeconds} seconds (attempt $newRetryCount/${_config.maxRetries})...',
-      error: error.toString(),
-      retryCount: newRetryCount,
-      lastUpdate: DateTime.now(),
-    ));
-
-    _retryTimer = Timer(retryDelay, () {
-      debugPrint(
-          '[MonacoEditorService] Retrying initialization (attempt $newRetryCount)');
-      initialize();
-    });
-  }
-
-  /// Dispose of resources
-  void dispose() {
-    debugPrint('[MonacoEditorService] Disposing');
-    _retryTimer?.cancel();
-    _assetStatusSubscription?.cancel();
-    _bridge.dispose();
-  }
-}
-
-/// State notifier for Monaco editor status
-class MonacoEditorStatusNotifier extends StateNotifier<MonacoEditorStatus> {
-  MonacoEditorStatusNotifier()
-      : super(const MonacoEditorStatus(state: MonacoEditorServiceState.idle));
-
-  void updateStatus(MonacoEditorStatus status) {
-    state = status;
-    debugPrint('[MonacoEditorStatusNotifier] Status updated: $status');
-  }
-
-  void reset() {
-    state = const MonacoEditorStatus(state: MonacoEditorServiceState.idle);
-  }
-}
diff --git a/lib/src/features/editor/services/monaco_editor_state.dart b/lib/src/features/editor/services/monaco_editor_state.dart
deleted file mode 100644
index 582d08d..0000000
--- a/lib/src/features/editor/services/monaco_editor_state.dart
+++ /dev/null
@@ -1,138 +0,0 @@
-// lib/src/features/editor/services/monaco_editor_state.dart
-import 'package:flutter/foundation.dart';
-
-/// States for the global Monaco editor instance
-enum MonacoEditorServiceState {
-  /// Initial state, editor not yet initialized
-  idle,
-
-  /// Waiting for assets to be ready
-  waitingForAssets,
-
-  /// Creating and initializing the editor instance
-  initializing,
-
-  /// Loading Monaco and setting up the environment
-  loading,
-
-  /// Editor is fully ready and can be shown instantly
-  ready,
-
-  /// Error occurred during initialization
-  error,
-
-  /// Retrying after an error
-  retrying,
-}
-
-/// Detailed status of the Monaco editor service
-@immutable
-class MonacoEditorStatus {
-  const MonacoEditorStatus({
-    required this.state,
-    this.progress = 0.0,
-    this.message,
-    this.error,
-    this.retryCount = 0,
-    this.lastUpdate,
-    this.isVisible = false,
-    this.hasContent = false,
-    this.queuedContent,
-  });
-
-  final MonacoEditorServiceState state;
-  final double progress;
-  final String? message;
-  final String? error;
-  final int retryCount;
-  final DateTime? lastUpdate;
-  final bool isVisible;
-  final bool hasContent;
-  final String? queuedContent;
-
-  MonacoEditorStatus copyWith({
-    MonacoEditorServiceState? state,
-    double? progress,
-    String? message,
-    String? error,
-    int? retryCount,
-    DateTime? lastUpdate,
-    bool? isVisible,
-    bool? hasContent,
-    String? queuedContent,
-  }) {
-    return MonacoEditorStatus(
-      state: state ?? this.state,
-      progress: progress ?? this.progress,
-      message: message ?? this.message,
-      error: error ?? this.error,
-      retryCount: retryCount ?? this.retryCount,
-      lastUpdate: lastUpdate ?? this.lastUpdate,
-      isVisible: isVisible ?? this.isVisible,
-      hasContent: hasContent ?? this.hasContent,
-      queuedContent: queuedContent ?? this.queuedContent,
-    );
-  }
-
-  bool get isReady => state == MonacoEditorServiceState.ready;
-
-  bool get isLoading => [
-        MonacoEditorServiceState.waitingForAssets,
-        MonacoEditorServiceState.initializing,
-        MonacoEditorServiceState.loading,
-        MonacoEditorServiceState.retrying,
-      ].contains(state);
-
-  bool get hasError => state == MonacoEditorServiceState.error;
-
-  bool get canShow => isReady && hasContent;
-
-  @override
-  String toString() => 'MonacoEditorStatus('
-      'state: $state, '
-      'progress: ${(progress * 100).toInt()}%, '
-      'visible: $isVisible, '
-      'hasContent: $hasContent'
-      ')';
-}
-
-/// Configuration for the editor initialization
-@immutable
-class MonacoEditorConfig {
-  const MonacoEditorConfig({
-    this.initContent = _defaultInitContent,
-    this.initLanguage = 'markdown',
-    this.showInitContent = true,
-    this.maxRetries = 3,
-    this.retryDelay = const Duration(seconds: 2),
-  });
-
-  final String initContent;
-  final String initLanguage;
-  final bool showInitContent;
-  final int maxRetries;
-  final Duration retryDelay;
-
-  static const String _defaultInitContent = '''
-# Welcome to Context Collector! üéØ
-
-Your **Monaco Editor** is ready and waiting for files.
-
-## Quick Start
-- üìÅ **Drag and drop** files or folders into the app
-- ‚å®Ô∏è **Edit** with full Monaco Editor features
-- üé® **Customize** using the settings panel
-- üìã **Copy** combined content with one click
-
-## Features
-- Syntax highlighting for 50+ languages
-- IntelliSense and auto-completion
-- Multiple cursor support
-- Find and replace
-- Code folding
-- And much more!
-
----
-*Drop your files to begin editing...*
-''';
-}
diff --git a/lib/src/features/editor/ui/dialogs/language_settings_dialog.dart b/lib/src/features/editor/ui/dialogs/language_settings_dialog.dart
new file mode 100644
index 0000000..679b3ab
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/language_settings_dialog.dart
@@ -0,0 +1,275 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Dialog for configuring language-specific settings
+class LanguageSettingsDialog extends StatefulWidget {
+  const LanguageSettingsDialog({
+    required this.currentConfigs,
+    this.language,
+    this.initialConfig,
+    super.key,
+  });
+
+  final Map<String, LanguageConfig> currentConfigs;
+  final String? language;
+  final LanguageConfig? initialConfig;
+
+  @override
+  State<LanguageSettingsDialog> createState() => _LanguageSettingsDialogState();
+}
+
+class _LanguageSettingsDialogState extends State<LanguageSettingsDialog> {
+  String? _selectedLanguage;
+  late LanguageConfig _config;
+
+  final _tabSizeController = TextEditingController();
+  final _rulersController = TextEditingController();
+
+  @override
+  void initState() {
+    super.initState();
+    _selectedLanguage = widget.language;
+    _config = widget.initialConfig ?? const LanguageConfig();
+
+    _tabSizeController.text = _config.tabSize?.toString() ?? '';
+    _rulersController.text = _config.rulers.join(',');
+  }
+
+  @override
+  void dispose() {
+    _tabSizeController.dispose();
+    _rulersController.dispose();
+    super.dispose();
+  }
+
+  List<DropdownMenuItem<String>> _getLanguageDropdownItems() {
+    final existingKeys = widget.currentConfigs.keys.toSet();
+    if (widget.language != null) {
+      existingKeys.remove(widget.language);
+    }
+
+    return EditorConstants.languages.entries
+        .where((entry) => !existingKeys.contains(entry.key))
+        .map(
+          (entry) => DropdownMenuItem<String>(
+            value: entry.key,
+            child: Text(entry.value),
+          ),
+        )
+        .toList();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final theme = context.themeData;
+    final isEditing = widget.language != null;
+
+    return AlertDialog(
+      title: Text(
+        isEditing
+            ? 'Edit ${EditorConstants.languages[_selectedLanguage] ?? _selectedLanguage} Settings'
+            : 'Add Language-Specific Settings',
+      ),
+      content: SingleChildScrollView(
+        child: Column(
+          mainAxisSize: MainAxisSize.min,
+          crossAxisAlignment: CrossAxisAlignment.start,
+          children: <Widget>[
+            if (!isEditing)
+              DropdownButtonFormField<String>(
+                decoration: const InputDecoration(labelText: 'Language'),
+                value: _selectedLanguage,
+                items: _getLanguageDropdownItems(),
+                onChanged: (value) {
+                  setState(() {
+                    _selectedLanguage = value;
+                  });
+                },
+                validator: (value) =>
+                    value == null ? 'Please select a language' : null,
+              )
+            else
+              Padding(
+                padding: const EdgeInsetsDirectional.only(bottom: 16),
+                child: Text(
+                  'Editing settings for: ${EditorConstants.languages[_selectedLanguage] ?? _selectedLanguage}',
+                  style: theme.titleMedium,
+                ),
+              ),
+            const SizedBox(height: 16),
+            _buildTabSizeField(),
+            const SizedBox(height: 16),
+            _buildInsertSpacesSwitch(),
+            const SizedBox(height: 16),
+            _buildWordWrapDropdown(),
+            const SizedBox(height: 16),
+            _buildRulersField(),
+            const SizedBox(height: 16),
+            _buildFormatOptions(),
+          ],
+        ),
+      ),
+      actions: <Widget>[
+        TextButton(
+          child: const Text('Cancel'),
+          onPressed: () {
+            Navigator.of(context).pop();
+          },
+        ),
+        FilledButton(
+          child: const Text('Save'),
+          onPressed: () {
+            if (_selectedLanguage != null) {
+              final finalConfig = _config.copyWith(
+                tabSize: _tabSizeController.text.isEmpty
+                    ? null
+                    : _config.tabSize,
+                rulers: _rulersController.text.isEmpty ? [] : _config.rulers,
+              );
+              Navigator.of(context).pop(
+                MapEntry(_selectedLanguage!, finalConfig),
+              );
+            } else if (!isEditing) {
+              ScaffoldMessenger.of(context).showSnackBar(
+                SnackBar(
+                  content: const Text('Please select a language.'),
+                  backgroundColor: Theme.of(context).colorScheme.error,
+                ),
+              );
+            }
+          },
+        ),
+      ],
+    );
+  }
+
+  Widget _buildTabSizeField() {
+    return TextFormField(
+      controller: _tabSizeController,
+      decoration: const InputDecoration(
+        labelText: 'Tab Size (Optional)',
+        border: OutlineInputBorder(),
+      ),
+      keyboardType: TextInputType.number,
+      inputFormatters: [FilteringTextInputFormatter.digitsOnly],
+      onChanged: (value) {
+        final val = int.tryParse(value);
+        _config = _config.copyWith(tabSize: val);
+      },
+    );
+  }
+
+  Widget _buildInsertSpacesSwitch() {
+    return Row(
+      mainAxisAlignment: MainAxisAlignment.spaceBetween,
+      children: [
+        Text('Insert Spaces (Optional)', style: context.bodyMedium),
+        Switch(
+          value: _config.insertSpaces ?? false,
+          onChanged: (newValue) {
+            setState(() {
+              if (_config.insertSpaces == null) {
+                _config = _config.copyWith(insertSpaces: true);
+              } else if (_config.insertSpaces == true) {
+                _config = _config.copyWith(insertSpaces: false);
+              } else {
+                _config = _config.copyWith(insertSpaces: null);
+              }
+            });
+          },
+          activeColor: context.primary,
+        ),
+      ],
+    );
+  }
+
+  Widget _buildWordWrapDropdown() {
+    return DropdownButtonFormField<WordWrap?>(
+      decoration: const InputDecoration(
+        labelText: 'Word Wrap (Optional)',
+        border: OutlineInputBorder(),
+      ),
+      value: _config.wordWrap,
+      items: [
+        const DropdownMenuItem<WordWrap?>(
+          value: null,
+          child: Text('Default'),
+        ),
+        ...WordWrap.values.map(
+          (ww) => DropdownMenuItem<WordWrap?>(
+            value: ww,
+            child: Text(ww.name.toTitle),
+          ),
+        ),
+      ],
+      onChanged: (value) {
+        setState(() {
+          _config = _config.copyWith(wordWrap: value);
+        });
+      },
+    );
+  }
+
+  Widget _buildRulersField() {
+    return TextFormField(
+      controller: _rulersController,
+      decoration: const InputDecoration(
+        labelText: 'Rulers (Optional, e.g., 80,100)',
+        border: OutlineInputBorder(),
+      ),
+      onChanged: (value) {
+        final rulers = value
+            .split(',')
+            .map((s) => int.tryParse(s.trim()))
+            .whereType<int>()
+            .toList();
+        _config = _config.copyWith(rulers: rulers);
+      },
+    );
+  }
+
+  Widget _buildFormatOptions() {
+    return Column(
+      children: [
+        SwitchListTile(
+          title: const Text('Format on Save (Optional)'),
+          value: _config.formatOnSave ?? false,
+          onChanged: (value) {
+            setState(() {
+              _config = _config.copyWith(formatOnSave: value);
+            });
+          },
+        ),
+        SwitchListTile(
+          title: const Text('Format on Paste (Optional)'),
+          value: _config.formatOnPaste ?? false,
+          onChanged: (value) {
+            setState(() {
+              _config = _config.copyWith(formatOnPaste: value);
+            });
+          },
+        ),
+        SwitchListTile(
+          title: const Text('Format on Type (Optional)'),
+          value: _config.formatOnType ?? false,
+          onChanged: (value) {
+            setState(() {
+              _config = _config.copyWith(formatOnType: value);
+            });
+          },
+        ),
+        SwitchListTile(
+          title: const Text('Bracket Pair Colorization (Optional)'),
+          value: _config.bracketPairColorization ?? false,
+          onChanged: (value) {
+            setState(() {
+              _config = _config.copyWith(bracketPairColorization: value);
+            });
+          },
+        ),
+      ],
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/settings_dialog.dart b/lib/src/features/editor/ui/dialogs/settings_dialog.dart
new file mode 100644
index 0000000..88e57ee
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/settings_dialog.dart
@@ -0,0 +1,423 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Refactored settings dialog with extracted tabs
+class EditorSettingsDialog extends StatefulWidget {
+  const EditorSettingsDialog({
+    required this.settings,
+    super.key,
+    this.customThemes = const [],
+    this.customKeybindingPresets = const [],
+  });
+
+  final EditorSettings settings;
+  final List<EditorTheme> customThemes;
+  final List<KeybindingPreset> customKeybindingPresets;
+
+  static Future<EditorSettings?> show(
+    BuildContext context,
+    EditorSettings currentSettings, {
+    List<EditorTheme> customThemes = const [],
+    List<KeybindingPreset> customKeybindingPresets = const [],
+  }) async {
+    return showDialog<EditorSettings>(
+      context: context,
+      barrierDismissible: false,
+      builder: (context) => EditorSettingsDialog(
+        settings: currentSettings,
+        customThemes: customThemes,
+        customKeybindingPresets: customKeybindingPresets,
+      ),
+    );
+  }
+
+  @override
+  State<EditorSettingsDialog> createState() => _EditorSettingsDialogState();
+}
+
+class _EditorSettingsDialogState extends State<EditorSettingsDialog>
+    with TickerProviderStateMixin {
+  late EditorSettings _settings;
+  late TabController _tabController;
+
+  // Form controllers
+  final _fontSizeController = TextEditingController();
+  final _lineHeightController = TextEditingController();
+  final _letterSpacingController = TextEditingController();
+  final _tabSizeController = TextEditingController();
+  final _wordWrapColumnController = TextEditingController();
+
+  // Focus nodes
+  final _fontSizeFocus = FocusNode();
+  final _lineHeightFocus = FocusNode();
+  final _letterSpacingFocus = FocusNode();
+  final _tabSizeFocus = FocusNode();
+  final _wordWrapColumnFocus = FocusNode();
+
+  @override
+  void initState() {
+    super.initState();
+    _settings = widget.settings;
+    _tabController = TabController(length: 6, vsync: this);
+
+    // Initialize form controllers
+    _fontSizeController.text = _settings.fontSize.toString();
+    _lineHeightController.text = _settings.lineHeight.toString();
+    _letterSpacingController.text = _settings.letterSpacing.toString();
+    _tabSizeController.text = _settings.tabSize.toString();
+    _wordWrapColumnController.text = _settings.wordWrapColumn.toString();
+  }
+
+  @override
+  void dispose() {
+    _tabController.dispose();
+    _fontSizeController.dispose();
+    _lineHeightController.dispose();
+    _letterSpacingController.dispose();
+    _tabSizeController.dispose();
+    _wordWrapColumnController.dispose();
+    _fontSizeFocus.dispose();
+    _lineHeightFocus.dispose();
+    _letterSpacingFocus.dispose();
+    _tabSizeFocus.dispose();
+    _wordWrapColumnFocus.dispose();
+    super.dispose();
+  }
+
+  void _updateSettings(EditorSettings newSettings) {
+    setState(() {
+      _settings = newSettings;
+    });
+  }
+
+  void _resetSettings() {
+    setState(() {
+      _settings = const EditorSettings();
+      // Update form controllers
+      _fontSizeController.text = _settings.fontSize.toString();
+      _lineHeightController.text = _settings.lineHeight.toString();
+      _letterSpacingController.text = _settings.letterSpacing.toString();
+      _tabSizeController.text = _settings.tabSize.toString();
+      _wordWrapColumnController.text = _settings.wordWrapColumn.toString();
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Dialog(
+      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
+      clipBehavior: Clip.antiAlias,
+      child: Container(
+        width: 900,
+        height: 700,
+        decoration: BoxDecoration(
+          color: context.surface,
+          borderRadius: BorderRadius.circular(16),
+        ),
+        child: Column(
+          children: [
+            DialogHeader(
+              title: 'Editor Settings',
+              subtitle: 'Customize your Monaco editor experience',
+              icon: Icons.settings_outlined,
+              onClose: () => Navigator.of(context).pop(),
+            ),
+            DialogTabBar(tabController: _tabController),
+            Expanded(child: _buildTabContent()),
+            DialogFooter(
+              onCancel: () => Navigator.of(context).pop(),
+              onApply: () async {
+                await EditorSettingsServiceHelper.save(_settings);
+                if (mounted) {
+                  Navigator.of(context).pop(_settings);
+                }
+              },
+              onLoadPreset: _loadPreset,
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+
+  Widget _buildTabContent() {
+    return TabBarView(
+      controller: _tabController,
+      children: [
+        GeneralTab(
+          settings: _settings,
+          fontSizeController: _fontSizeController,
+          lineHeightController: _lineHeightController,
+          letterSpacingController: _letterSpacingController,
+          fontSizeFocus: _fontSizeFocus,
+          lineHeightFocus: _lineHeightFocus,
+          letterSpacingFocus: _letterSpacingFocus,
+          onSettingsChanged: _updateSettings,
+        ),
+        AppearanceTab(
+          settings: _settings,
+          onSettingsChanged: _updateSettings,
+          customThemes: widget.customThemes,
+        ),
+        EditorTab(
+          settings: _settings,
+          tabSizeController: _tabSizeController,
+          wordWrapColumnController: _wordWrapColumnController,
+          tabSizeFocus: _tabSizeFocus,
+          wordWrapColumnFocus: _wordWrapColumnFocus,
+          onSettingsChanged: _updateSettings,
+        ),
+        KeybindingsTab(
+          settings: _settings,
+          onSettingsChanged: _updateSettings,
+          customKeybindingPresets: widget.customKeybindingPresets,
+        ),
+        LanguagesTab(
+          settings: _settings,
+          onSettingsChanged: _updateSettings,
+        ),
+        AdvancedTab(
+          settings: _settings,
+          onSettingsChanged: _updateSettings,
+          onResetSettings: _resetSettings,
+        ),
+      ],
+    );
+  }
+
+  Future<void> _loadPreset() async {
+    final preset = await showDialog<String?>(
+      context: context,
+      builder: (context) => const PresetSelectionDialog(),
+    );
+
+    if (preset != null) {
+      setState(() {
+        _settings = EditorSettings.createPreset(preset);
+        // Update form controllers
+        _fontSizeController.text = _settings.fontSize.toString();
+        _lineHeightController.text = _settings.lineHeight.toString();
+        _letterSpacingController.text = _settings.letterSpacing.toString();
+        _tabSizeController.text = _settings.tabSize.toString();
+        _wordWrapColumnController.text = _settings.wordWrapColumn.toString();
+      });
+    }
+  }
+}
+
+/// Reusable dialog header widget
+class DialogHeader extends StatelessWidget {
+  const DialogHeader({
+    required this.title,
+    required this.subtitle,
+    required this.icon,
+    required this.onClose,
+    super.key,
+  });
+
+  final String title;
+  final String subtitle;
+  final IconData icon;
+  final VoidCallback onClose;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsetsDirectional.all(24),
+      decoration: BoxDecoration(
+        color: context.primary.addOpacity(0.05),
+        border: Border(
+          bottom: BorderSide(
+            color: context.onSurface.addOpacity(0.1),
+          ),
+        ),
+      ),
+      child: Row(
+        children: [
+          Icon(
+            icon,
+            size: 28,
+            color: context.primary,
+          ),
+          const SizedBox(width: 16),
+          Expanded(
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                Text(
+                  title,
+                  style: context.headlineSmall?.copyWith(
+                    fontWeight: FontWeight.w600,
+                    color: context.onSurface,
+                  ),
+                ),
+                const SizedBox(height: 4),
+                Text(
+                  subtitle,
+                  style: context.bodyMedium?.copyWith(
+                    color: context.onSurface.addOpacity(0.7),
+                  ),
+                ),
+              ],
+            ),
+          ),
+          IconButton(
+            onPressed: onClose,
+            icon: Icon(
+              Icons.close,
+              color: context.onSurface.addOpacity(0.6),
+            ),
+            tooltip: 'Close',
+          ),
+        ],
+      ),
+    );
+  }
+}
+
+/// Reusable dialog tab bar widget
+class DialogTabBar extends StatelessWidget {
+  const DialogTabBar({
+    required this.tabController,
+    super.key,
+  });
+
+  final TabController tabController;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      decoration: BoxDecoration(
+        color: context.surface,
+        border: Border(
+          bottom: BorderSide(
+            color: context.onSurface.addOpacity(0.1),
+          ),
+        ),
+      ),
+      child: TabBar(
+        controller: tabController,
+        isScrollable: true,
+        tabAlignment: TabAlignment.start,
+        labelColor: context.primary,
+        unselectedLabelColor: context.onSurface.addOpacity(0.6),
+        indicatorColor: context.primary,
+        indicatorWeight: 3,
+        labelStyle: context.labelLarge?.copyWith(
+          fontWeight: FontWeight.w600,
+        ),
+        unselectedLabelStyle: context.labelLarge?.copyWith(
+          fontWeight: FontWeight.w400,
+        ),
+        tabs: const [
+          Tab(text: 'General'),
+          Tab(text: 'Appearance'),
+          Tab(text: 'Editor'),
+          Tab(text: 'Keybindings'),
+          Tab(text: 'Languages'),
+          Tab(text: 'Advanced'),
+        ],
+      ),
+    );
+  }
+}
+
+/// Reusable dialog footer widget
+class DialogFooter extends StatelessWidget {
+  const DialogFooter({
+    required this.onCancel,
+    required this.onApply,
+    required this.onLoadPreset,
+    super.key,
+  });
+
+  final VoidCallback onCancel;
+  final VoidCallback onApply;
+  final VoidCallback onLoadPreset;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsetsDirectional.all(24),
+      decoration: BoxDecoration(
+        color: context.surface,
+        border: Border(
+          top: BorderSide(
+            color: context.onSurface.addOpacity(0.1),
+          ),
+        ),
+      ),
+      child: Row(
+        children: [
+          TextButton.icon(
+            onPressed: onLoadPreset,
+            icon: const Icon(Icons.category_outlined),
+            label: const Text('Load Preset'),
+          ),
+          const Spacer(),
+          TextButton(
+            onPressed: onCancel,
+            child: const Text('Cancel'),
+          ),
+          const SizedBox(width: 12),
+          FilledButton(
+            onPressed: onApply,
+            child: const Text('Apply Settings'),
+          ),
+        ],
+      ),
+    );
+  }
+}
+
+/// Preset selection dialog
+class PresetSelectionDialog extends StatelessWidget {
+  const PresetSelectionDialog({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return AlertDialog(
+      title: const Text('Load Preset'),
+      content: Column(
+        mainAxisSize: MainAxisSize.min,
+        children: [
+          for (final presetName in [
+            'beginner',
+            'developer',
+            'poweruser',
+            'accessibility',
+          ])
+            ListTile(
+              title: Text(presetName.toTitle),
+              subtitle: Text(_getPresetDescription(presetName)),
+              onTap: () {
+                Navigator.of(context).pop(presetName);
+              },
+            ),
+        ],
+      ),
+      actions: [
+        TextButton(
+          onPressed: () => Navigator.of(context).pop(),
+          child: const Text('Cancel'),
+        ),
+      ],
+    );
+  }
+
+  String _getPresetDescription(String preset) {
+    switch (preset) {
+      case 'beginner':
+        return 'Larger font, word wrap enabled, helpful features';
+      case 'developer':
+        return 'Balanced settings for daily development';
+      case 'poweruser':
+        return 'Advanced features, compact layout';
+      case 'accessibility':
+        return 'Optimized for screen readers and visibility';
+      default:
+        return '';
+    }
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/advanced_tab.dart b/lib/src/features/editor/ui/dialogs/tabs/advanced_tab.dart
new file mode 100644
index 0000000..9c0b79d
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/advanced_tab.dart
@@ -0,0 +1,234 @@
+import 'dart:convert';
+import 'dart:io';
+
+import 'package:context_collector/context_collector.dart';
+import 'package:file_picker/file_picker.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Advanced settings tab
+class AdvancedTab extends StatelessWidget {
+  const AdvancedTab({
+    required this.settings,
+    required this.onSettingsChanged,
+    required this.onResetSettings,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+  final VoidCallback onResetSettings;
+
+  @override
+  Widget build(BuildContext context) {
+    return SingleChildScrollView(
+      padding: const EdgeInsetsDirectional.all(24),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const SettingsSectionHeader(title: 'Performance'),
+          const SizedBox(height: 16),
+          _buildPerformanceOptions(context),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Accessibility'),
+          const SizedBox(height: 16),
+          _buildAccessibilityOptions(context),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Reset & Backup'),
+          const SizedBox(height: 16),
+          _buildResetBackupOptions(context),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildPerformanceOptions(BuildContext context) {
+    return Column(
+      children: [
+        SettingsSwitchTile(
+          title: 'Smooth Scrolling',
+          subtitle: 'Enable smooth scrolling animations',
+          value: settings.smoothScrolling,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(smoothScrolling: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Disable Layer Hinting',
+          subtitle: 'May improve performance on some devices',
+          value: settings.disableLayerHinting,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(disableLayerHinting: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Disable Monospace Optimizations',
+          subtitle: 'Disable font optimizations for monospace fonts',
+          value: settings.disableMonospaceOptimizations,
+          onChanged: (value) {
+            onSettingsChanged(
+              settings.copyWith(
+                disableMonospaceOptimizations: value,
+              ),
+            );
+          },
+        ),
+      ],
+    );
+  }
+
+  Widget _buildAccessibilityOptions(BuildContext context) {
+    return SettingsDropdownField<AccessibilitySupport>(
+      label: 'Accessibility Support',
+      value: settings.accessibilitySupport,
+      items: AccessibilitySupport.values,
+      itemBuilder: (support) => support.name.toTitle,
+      onChanged: (value) {
+        if (value != null) {
+          onSettingsChanged(settings.copyWith(accessibilitySupport: value));
+        }
+      },
+    );
+  }
+
+  Widget _buildResetBackupOptions(BuildContext context) {
+    return Row(
+      children: [
+        Expanded(
+          child: OutlinedButton.icon(
+            onPressed: () => _showResetDialog(context),
+            icon: Icon(
+              Icons.restore,
+              color: context.error,
+            ),
+            label: Text(
+              'Reset to Defaults',
+              style: TextStyle(color: context.error),
+            ),
+            style: OutlinedButton.styleFrom(
+              side: BorderSide(color: context.error),
+            ),
+          ),
+        ),
+        const SizedBox(width: 16),
+        Expanded(
+          child: OutlinedButton.icon(
+            onPressed: () => _exportSettings(context),
+            icon: const Icon(Icons.download),
+            label: const Text('Export Settings'),
+          ),
+        ),
+        const SizedBox(width: 16),
+        Expanded(
+          child: OutlinedButton.icon(
+            onPressed: () => _importSettings(context),
+            icon: const Icon(Icons.upload),
+            label: const Text('Import Settings'),
+          ),
+        ),
+      ],
+    );
+  }
+
+  Future<void> _showResetDialog(BuildContext context) async {
+    await showDialog<void>(
+      context: context,
+      builder: (context) => AlertDialog(
+        title: const Text('Reset Settings'),
+        content: const Text(
+          'Are you sure you want to reset all settings to defaults? This cannot be undone.',
+        ),
+        actions: [
+          TextButton(
+            onPressed: () => Navigator.of(context).pop(),
+            child: const Text('Cancel'),
+          ),
+          TextButton(
+            onPressed: () {
+              onResetSettings();
+              Navigator.of(context).pop();
+            },
+            style: TextButton.styleFrom(
+              foregroundColor: context.error,
+            ),
+            child: const Text('Reset'),
+          ),
+        ],
+      ),
+    );
+  }
+
+  Future<void> _exportSettings(BuildContext context) async {
+    final settingsJson = jsonEncode(settings.toJson());
+    try {
+      final outputFile = await FilePicker.platform.saveFile(
+        dialogTitle: 'Export Editor Settings',
+        fileName: 'editor_settings.json',
+        type: FileType.custom,
+        allowedExtensions: ['json'],
+      );
+
+      if (outputFile != null) {
+        final file = File(outputFile);
+        await file.writeAsString(settingsJson);
+        if (context.mounted) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            SnackBar(
+              content: Text('Settings exported successfully to $outputFile'),
+              backgroundColor: context.primary,
+              behavior: SnackBarBehavior.floating,
+            ),
+          );
+        }
+      }
+    } catch (e) {
+      if (context.mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text('Error exporting settings: $e'),
+            backgroundColor: context.error,
+            behavior: SnackBarBehavior.floating,
+          ),
+        );
+      }
+    }
+  }
+
+  Future<void> _importSettings(BuildContext context) async {
+    try {
+      final result = await FilePicker.platform.pickFiles(
+        type: FileType.custom,
+        allowedExtensions: ['json'],
+      );
+
+      if (result != null && result.files.single.path != null) {
+        final file = File(result.files.single.path!);
+        final content = await file.readAsString();
+        final jsonMap = jsonDecode(content) as Map<String, dynamic>;
+
+        final newSettings = EditorSettings.fromJson(jsonMap);
+        onSettingsChanged(newSettings);
+
+        if (context.mounted) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            SnackBar(
+              content: const Text('Settings imported successfully!'),
+              backgroundColor: context.primary,
+              behavior: SnackBarBehavior.floating,
+            ),
+          );
+        }
+      }
+    } catch (e) {
+      if (context.mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text('Error importing settings: $e'),
+            backgroundColor: context.error,
+            behavior: SnackBarBehavior.floating,
+          ),
+        );
+      }
+    }
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/appearance_tab.dart b/lib/src/features/editor/ui/dialogs/tabs/appearance_tab.dart
new file mode 100644
index 0000000..2821c2a
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/appearance_tab.dart
@@ -0,0 +1,430 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Appearance settings tab for the editor settings dialog
+class AppearanceTab extends StatelessWidget {
+  const AppearanceTab({
+    required this.settings,
+    required this.onSettingsChanged,
+    required this.customThemes,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+  final List<EditorTheme> customThemes;
+
+  @override
+  Widget build(BuildContext context) {
+    final availableThemes = ThemeManager.getAllThemes(
+      customThemes: customThemes,
+    );
+
+    return SingleChildScrollView(
+      padding: const EdgeInsetsDirectional.all(24),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const SettingsSectionHeader(title: 'Theme'),
+          const SizedBox(height: 16),
+          _buildThemeSelection(context, availableThemes),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Display'),
+          const SizedBox(height: 16),
+          _buildDisplayOptions(context),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildThemeSelection(
+    BuildContext context,
+    List<EditorTheme> availableThemes,
+  ) {
+    return Container(
+      padding: const EdgeInsetsDirectional.all(16),
+      decoration: BoxDecoration(
+        color: context.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(
+          color: context.onSurface.addOpacity(0.1),
+        ),
+      ),
+      child: Column(
+        children: [
+          for (final category in ThemeCategory.values)
+            if (availableThemes.any((t) => t.category == category)) ...[
+              ThemeCategorySection(
+                category: category,
+                themes: availableThemes
+                    .where((t) => t.category == category)
+                    .toList(),
+                selectedTheme: settings.theme,
+                onThemeSelected: (themeId) {
+                  onSettingsChanged(settings.copyWith(theme: themeId));
+                },
+              ),
+              if (category != ThemeCategory.values.last)
+                const SizedBox(height: 24),
+            ],
+        ],
+      ),
+    );
+  }
+
+  Widget _buildDisplayOptions(BuildContext context) {
+    return Column(
+      children: [
+        _buildLineNumbersOptions(context),
+        const SizedBox(height: 16),
+        _buildMinimapOptions(context),
+        const SizedBox(height: 16),
+        _buildOtherDisplayOptions(context),
+      ],
+    );
+  }
+
+  Widget _buildLineNumbersOptions(BuildContext context) {
+    return Row(
+      children: [
+        Expanded(
+          child: SettingsSwitchTile(
+            title: 'Show Line Numbers',
+            subtitle: 'Display line numbers in the gutter',
+            value: settings.showLineNumbers,
+            onChanged: (value) {
+              onSettingsChanged(settings.copyWith(showLineNumbers: value));
+            },
+          ),
+        ),
+        const SizedBox(width: 16),
+        if (settings.showLineNumbers)
+          Expanded(
+            child: SettingsDropdownField<LineNumbersStyle>(
+              label: 'Line Number Style',
+              value: settings.lineNumbersStyle,
+              items: LineNumbersStyle.values,
+              itemBuilder: (style) => style.name.toTitle,
+              onChanged: (value) {
+                if (value != null) {
+                  onSettingsChanged(settings.copyWith(lineNumbersStyle: value));
+                }
+              },
+            ),
+          ),
+      ],
+    );
+  }
+
+  Widget _buildMinimapOptions(BuildContext context) {
+    return Column(
+      children: [
+        SettingsSwitchTile(
+          title: 'Show Minimap',
+          subtitle: 'Display miniature overview of the entire file',
+          value: settings.showMinimap,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(showMinimap: value));
+          },
+        ),
+        if (settings.showMinimap) ...[
+          const SizedBox(height: 16),
+          Row(
+            children: [
+              Expanded(
+                child: SettingsDropdownField<MinimapSide>(
+                  label: 'Minimap Side',
+                  value: settings.minimapSide,
+                  items: MinimapSide.values,
+                  itemBuilder: (side) => side.name.toTitle,
+                  onChanged: (value) {
+                    if (value != null) {
+                      onSettingsChanged(settings.copyWith(minimapSide: value));
+                    }
+                  },
+                ),
+              ),
+              const SizedBox(width: 16),
+              Expanded(
+                child: SettingsSwitchTile(
+                  title: 'Render Characters',
+                  subtitle: 'Show actual characters in minimap',
+                  value: settings.minimapRenderCharacters,
+                  onChanged: (value) {
+                    onSettingsChanged(
+                      settings.copyWith(
+                        minimapRenderCharacters: value,
+                      ),
+                    );
+                  },
+                ),
+              ),
+            ],
+          ),
+        ],
+      ],
+    );
+  }
+
+  Widget _buildOtherDisplayOptions(BuildContext context) {
+    return Column(
+      children: [
+        SettingsSwitchTile(
+          title: 'Show Indent Guides',
+          subtitle: 'Display vertical lines to show indentation',
+          value: settings.showIndentGuides,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(showIndentGuides: value));
+          },
+        ),
+        const SizedBox(height: 16),
+        SettingsDropdownField<RenderWhitespace>(
+          label: 'Render Whitespace',
+          value: settings.renderWhitespace,
+          items: RenderWhitespace.values,
+          itemBuilder: (ws) => ws.name.toTitle,
+          onChanged: (value) {
+            if (value != null) {
+              onSettingsChanged(settings.copyWith(renderWhitespace: value));
+            }
+          },
+        ),
+        const SizedBox(height: 16),
+        SettingsSwitchTile(
+          title: 'Bracket Pair Colorization',
+          subtitle: 'Color matching brackets with different colors',
+          value: settings.bracketPairColorization,
+          onChanged: (value) {
+            onSettingsChanged(
+              settings.copyWith(bracketPairColorization: value),
+            );
+          },
+        ),
+      ],
+    );
+  }
+}
+
+/// Widget for displaying themes grouped by category
+class ThemeCategorySection extends StatelessWidget {
+  const ThemeCategorySection({
+    required this.category,
+    required this.themes,
+    required this.selectedTheme,
+    required this.onThemeSelected,
+    super.key,
+  });
+
+  final ThemeCategory category;
+  final List<EditorTheme> themes;
+  final String selectedTheme;
+  final ValueChanged<String> onThemeSelected;
+
+  @override
+  Widget build(BuildContext context) {
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Text(
+          _getCategoryName(),
+          style: context.labelLarge?.copyWith(
+            fontWeight: FontWeight.w600,
+            color: context.onSurface.addOpacity(0.8),
+          ),
+        ),
+        const SizedBox(height: 12),
+        Wrap(
+          spacing: 12,
+          runSpacing: 12,
+          children: themes.map((theme) {
+            return ThemePreviewCard(
+              theme: theme,
+              isSelected: selectedTheme == theme.id,
+              onTap: () => onThemeSelected(theme.id),
+            );
+          }).toList(),
+        ),
+      ],
+    );
+  }
+
+  String _getCategoryName() {
+    switch (category) {
+      case ThemeCategory.light:
+        return 'Light Themes';
+      case ThemeCategory.dark:
+        return 'Dark Themes';
+      case ThemeCategory.highContrast:
+        return 'High Contrast';
+      case ThemeCategory.custom:
+        return 'Custom Themes';
+    }
+  }
+}
+
+/// Theme preview card widget
+class ThemePreviewCard extends StatelessWidget {
+  const ThemePreviewCard({
+    required this.theme,
+    required this.isSelected,
+    required this.onTap,
+    super.key,
+  });
+
+  final EditorTheme theme;
+  final bool isSelected;
+  final VoidCallback onTap;
+
+  @override
+  Widget build(BuildContext context) {
+    final previewColors = ThemeManager.getThemePreviewColors(theme);
+
+    return InkWell(
+      onTap: onTap,
+      borderRadius: BorderRadius.circular(8),
+      child: Container(
+        width: 120,
+        height: 80,
+        decoration: BoxDecoration(
+          borderRadius: BorderRadius.circular(8),
+          border: Border.all(
+            color: isSelected
+                ? context.primary
+                : context.onSurface.addOpacity(0.2),
+            width: isSelected ? 2 : 1,
+          ),
+        ),
+        child: Stack(
+          children: [
+            _buildThemePreview(context, previewColors),
+            if (isSelected) _buildSelectionIndicator(context),
+          ],
+        ),
+      ),
+    );
+  }
+
+  Widget _buildThemePreview(
+    BuildContext context,
+    Map<String, String> previewColors,
+  ) {
+    return Container(
+      decoration: BoxDecoration(
+        borderRadius: BorderRadius.circular(7),
+        color: Color(
+          int.parse(
+            previewColors['background']!.replaceFirst('#', '0xFF'),
+          ),
+        ),
+      ),
+      child: Column(
+        children: [
+          Container(
+            height: 20,
+            decoration: BoxDecoration(
+              color: Color(
+                int.parse(
+                  previewColors['accent']!.replaceFirst('#', '0xFF'),
+                ),
+              ).addOpacity(0.1),
+              borderRadius: const BorderRadiusDirectional.only(
+                topStart: Radius.circular(7),
+                topEnd: Radius.circular(7),
+              ),
+            ),
+          ),
+          Expanded(
+            child: Padding(
+              padding: const EdgeInsetsDirectional.all(8),
+              child: Row(
+                children: [
+                  Container(
+                    width: 8,
+                    decoration: BoxDecoration(
+                      color: Color(
+                        int.parse(
+                          previewColors['lineNumber']!.replaceFirst(
+                            '#',
+                            '0xFF',
+                          ),
+                        ),
+                      ),
+                      borderRadius: BorderRadius.circular(1),
+                    ),
+                  ),
+                  const SizedBox(width: 4),
+                  Expanded(
+                    child: Column(
+                      crossAxisAlignment: CrossAxisAlignment.start,
+                      children: [
+                        Container(
+                          height: 2,
+                          width: double.infinity,
+                          color: Color(
+                            int.parse(
+                              previewColors['foreground']!.replaceFirst(
+                                '#',
+                                '0xFF',
+                              ),
+                            ),
+                          ),
+                        ),
+                        const SizedBox(height: 2),
+                        Container(
+                          height: 2,
+                          width: 40,
+                          color: Color(
+                            int.parse(
+                              previewColors['accent']!.replaceFirst(
+                                '#',
+                                '0xFF',
+                              ),
+                            ),
+                          ),
+                        ),
+                        const SizedBox(height: 2),
+                        Container(
+                          height: 2,
+                          width: 60,
+                          color: Color(
+                            int.parse(
+                              previewColors['foreground']!.replaceFirst(
+                                '#',
+                                '0xFF',
+                              ),
+                            ),
+                          ).addOpacity(0.7),
+                        ),
+                      ],
+                    ),
+                  ),
+                ],
+              ),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildSelectionIndicator(BuildContext context) {
+    return PositionedDirectional(
+      top: 4,
+      end: 4,
+      child: Container(
+        width: 16,
+        height: 16,
+        decoration: BoxDecoration(
+          color: context.primary,
+          shape: BoxShape.circle,
+        ),
+        child: Icon(
+          Icons.check,
+          size: 12,
+          color: context.onPrimary,
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/editor_tab.dart b/lib/src/features/editor/ui/dialogs/tabs/editor_tab.dart
new file mode 100644
index 0000000..6f06cde
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/editor_tab.dart
@@ -0,0 +1,211 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Editor behavior settings tab
+class EditorTab extends StatelessWidget {
+  const EditorTab({
+    required this.settings,
+    required this.tabSizeController,
+    required this.wordWrapColumnController,
+    required this.tabSizeFocus,
+    required this.wordWrapColumnFocus,
+    required this.onSettingsChanged,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final TextEditingController tabSizeController;
+  final TextEditingController wordWrapColumnController;
+  final FocusNode tabSizeFocus;
+  final FocusNode wordWrapColumnFocus;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+
+  @override
+  Widget build(BuildContext context) {
+    return SingleChildScrollView(
+      padding: const EdgeInsetsDirectional.all(24),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const SettingsSectionHeader(title: 'Text Editing'),
+          const SizedBox(height: 16),
+          _buildTextEditingOptions(context),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Auto Features'),
+          const SizedBox(height: 16),
+          _buildAutoFeatures(context),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Code Intelligence'),
+          const SizedBox(height: 16),
+          _buildCodeIntelligence(context),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Cursor & Selection'),
+          const SizedBox(height: 16),
+          _buildCursorOptions(context),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildTextEditingOptions(BuildContext context) {
+    return Column(
+      children: [
+        SettingsDropdownField<WordWrap>(
+          label: 'Word Wrap',
+          value: settings.wordWrap,
+          items: WordWrap.values,
+          itemBuilder: (wrap) => wrap.name.toTitle,
+          onChanged: (value) {
+            if (value != null) {
+              onSettingsChanged(settings.copyWith(wordWrap: value));
+            }
+          },
+        ),
+        if (settings.wordWrap == WordWrap.wordWrapColumn) ...[
+          const SizedBox(height: 16),
+          SettingsNumberField(
+            label: 'Word Wrap Column',
+            controller: wordWrapColumnController,
+            min: 40,
+            max: 200,
+            onChanged: (value) {
+              if (value != null) {
+                onSettingsChanged(
+                  settings.copyWith(wordWrapColumn: value.toInt()),
+                );
+              }
+            },
+          ),
+        ],
+        const SizedBox(height: 16),
+        Row(
+          children: [
+            Expanded(
+              child: SettingsNumberField(
+                label: 'Tab Size',
+                controller: tabSizeController,
+                min: EditorConstants.minTabSize.toDouble(),
+                max: EditorConstants.maxTabSize.toDouble(),
+                onChanged: (value) {
+                  if (value != null) {
+                    onSettingsChanged(
+                      settings.copyWith(tabSize: value.toInt()),
+                    );
+                  }
+                },
+              ),
+            ),
+            const SizedBox(width: 16),
+            Expanded(
+              child: SettingsSwitchTile(
+                title: 'Insert Spaces',
+                subtitle: 'Use spaces instead of tabs',
+                value: settings.insertSpaces,
+                onChanged: (value) {
+                  onSettingsChanged(settings.copyWith(insertSpaces: value));
+                },
+              ),
+            ),
+          ],
+        ),
+      ],
+    );
+  }
+
+  Widget _buildAutoFeatures(BuildContext context) {
+    return Column(
+      children: [
+        SettingsSwitchTile(
+          title: 'Format on Save',
+          subtitle: 'Automatically format code when saving',
+          value: settings.formatOnSave,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(formatOnSave: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Format on Paste',
+          subtitle: 'Automatically format pasted code',
+          value: settings.formatOnPaste,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(formatOnPaste: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Format on Type',
+          subtitle: 'Format code as you type',
+          value: settings.formatOnType,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(formatOnType: value));
+          },
+        ),
+      ],
+    );
+  }
+
+  Widget _buildCodeIntelligence(BuildContext context) {
+    return Column(
+      children: [
+        SettingsSwitchTile(
+          title: 'Quick Suggestions',
+          subtitle: 'Show auto-completion suggestions',
+          value: settings.quickSuggestions,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(quickSuggestions: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Parameter Hints',
+          subtitle: 'Show parameter hints for functions',
+          value: settings.parameterHints,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(parameterHints: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Hover Information',
+          subtitle: 'Show hover information for symbols',
+          value: settings.hover,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(hover: value));
+          },
+        ),
+      ],
+    );
+  }
+
+  Widget _buildCursorOptions(BuildContext context) {
+    return Row(
+      children: [
+        Expanded(
+          child: SettingsDropdownField<CursorBlinking>(
+            label: 'Cursor Blinking',
+            value: settings.cursorBlinking,
+            items: CursorBlinking.values,
+            itemBuilder: (blinking) => blinking.name.toTitle,
+            onChanged: (value) {
+              if (value != null) {
+                onSettingsChanged(settings.copyWith(cursorBlinking: value));
+              }
+            },
+          ),
+        ),
+        const SizedBox(width: 16),
+        Expanded(
+          child: SettingsDropdownField<CursorStyle>(
+            label: 'Cursor Style',
+            value: settings.cursorStyle,
+            items: CursorStyle.values,
+            itemBuilder: (style) => style.name.toTitle,
+            onChanged: (value) {
+              if (value != null) {
+                onSettingsChanged(settings.copyWith(cursorStyle: value));
+              }
+            },
+          ),
+        ),
+      ],
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/general_tab.dart b/lib/src/features/editor/ui/dialogs/tabs/general_tab.dart
new file mode 100644
index 0000000..baba017
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/general_tab.dart
@@ -0,0 +1,207 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// General settings tab for the editor settings dialog
+class GeneralTab extends StatelessWidget {
+  const GeneralTab({
+    required this.settings,
+    required this.fontSizeController,
+    required this.lineHeightController,
+    required this.letterSpacingController,
+    required this.fontSizeFocus,
+    required this.lineHeightFocus,
+    required this.letterSpacingFocus,
+    required this.onSettingsChanged,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final TextEditingController fontSizeController;
+  final TextEditingController lineHeightController;
+  final TextEditingController letterSpacingController;
+  final FocusNode fontSizeFocus;
+  final FocusNode lineHeightFocus;
+  final FocusNode letterSpacingFocus;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+
+  @override
+  Widget build(BuildContext context) {
+    return SingleChildScrollView(
+      padding: const EdgeInsetsDirectional.all(24),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const SettingsSectionHeader(title: 'Font & Typography'),
+          const SizedBox(height: 16),
+          _buildFontFamilyDropdown(context),
+          const SizedBox(height: 16),
+          _buildFontControls(context),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Basic Options'),
+          const SizedBox(height: 16),
+          _buildBasicOptions(context),
+          const SizedBox(height: 32),
+          _buildPreviewSection(context),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildFontFamilyDropdown(BuildContext context) {
+    return SettingsDropdownField<String>(
+      label: 'Font Family',
+      value: settings.fontFamily,
+      items: EditorConstants.fontFamilies,
+      onChanged: (value) {
+        if (value != null) {
+          onSettingsChanged(settings.copyWith(fontFamily: value));
+        }
+      },
+      helperText: 'Select font family',
+    );
+  }
+
+  Widget _buildFontControls(BuildContext context) {
+    return Row(
+      children: [
+        Expanded(
+          child: SettingsNumberField(
+            label: 'Font Size',
+            controller: fontSizeController,
+            min: EditorConstants.minFontSize,
+            max: EditorConstants.maxFontSize,
+            suffix: 'px',
+            onChanged: (value) {
+              if (value != null) {
+                onSettingsChanged(settings.copyWith(fontSize: value));
+              }
+            },
+          ),
+        ),
+        const SizedBox(width: 16),
+        Expanded(
+          child: SettingsNumberField(
+            label: 'Line Height',
+            controller: lineHeightController,
+            min: 1,
+            max: 3,
+            decimals: 1,
+            onChanged: (value) {
+              if (value != null) {
+                onSettingsChanged(settings.copyWith(lineHeight: value));
+              }
+            },
+          ),
+        ),
+        const SizedBox(width: 16),
+        Expanded(
+          child: SettingsNumberField(
+            label: 'Letter Spacing',
+            controller: letterSpacingController,
+            min: -2,
+            max: 5,
+            decimals: 1,
+            suffix: 'px',
+            onChanged: (value) {
+              if (value != null) {
+                onSettingsChanged(settings.copyWith(letterSpacing: value));
+              }
+            },
+          ),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildBasicOptions(BuildContext context) {
+    return Column(
+      children: [
+        SettingsSwitchTile(
+          title: 'Read Only',
+          subtitle: 'Make editor read-only (view mode)',
+          value: settings.readOnly,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(readOnly: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Automatic Layout',
+          subtitle: 'Automatically adjust editor size',
+          value: settings.automaticLayout,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(automaticLayout: value));
+          },
+        ),
+        SettingsSwitchTile(
+          title: 'Mouse Wheel Zoom',
+          subtitle: 'Enable zooming with Ctrl+Mouse wheel',
+          value: settings.mouseWheelZoom,
+          onChanged: (value) {
+            onSettingsChanged(settings.copyWith(mouseWheelZoom: value));
+          },
+        ),
+      ],
+    );
+  }
+
+  Widget _buildPreviewSection(BuildContext context) {
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        const SettingsSectionHeader(title: 'Preview'),
+        const SizedBox(height: 16),
+        Container(
+          padding: const EdgeInsetsDirectional.all(16),
+          decoration: BoxDecoration(
+            color: context.isDark
+                ? Colors.black.addOpacity(0.3)
+                : Colors.grey.shade100,
+            borderRadius: BorderRadius.circular(8),
+            border: Border.all(
+              color: context.onSurface.addOpacity(0.1),
+            ),
+          ),
+          child: Row(
+            children: [
+              if (settings.showLineNumbers) ...[
+                Text(
+                  '1\n2\n3',
+                  style: TextStyle(
+                    fontFamily: settings.fontFamily.split(',').first.trim(),
+                    fontSize: settings.fontSize * 0.9,
+                    height: settings.lineHeight,
+                    letterSpacing: settings.letterSpacing,
+                    color: context.onSurfaceVariant.addOpacity(0.4),
+                  ),
+                ),
+                Container(
+                  width: 1,
+                  height: 50,
+                  margin: const EdgeInsetsDirectional.symmetric(horizontal: 12),
+                  color: context.onSurface.addOpacity(0.1),
+                ),
+              ],
+              Expanded(
+                child: Text(
+                  'Sample code preview\nfunc main() {\n    print("Hello, World!")\n}',
+                  style: TextStyle(
+                    fontFamily: settings.fontFamily.split(',').first.trim(),
+                    fontSize: settings.fontSize,
+                    height: settings.lineHeight,
+                    letterSpacing: settings.letterSpacing,
+                    color: context.onSurface,
+                  ),
+                  softWrap: settings.wordWrap != WordWrap.off,
+                  overflow: settings.wordWrap != WordWrap.off
+                      ? TextOverflow.visible
+                      : TextOverflow.ellipsis,
+                ),
+              ),
+            ],
+          ),
+        ),
+      ],
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/keybindings_tab.dart b/lib/src/features/editor/ui/dialogs/tabs/keybindings_tab.dart
new file mode 100644
index 0000000..dc28751
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/keybindings_tab.dart
@@ -0,0 +1,187 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Keybindings settings tab
+class KeybindingsTab extends StatelessWidget {
+  const KeybindingsTab({
+    required this.settings,
+    required this.onSettingsChanged,
+    required this.customKeybindingPresets,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+  final List<KeybindingPreset> customKeybindingPresets;
+
+  @override
+  Widget build(BuildContext context) {
+    final allPresets = KeybindingManager.getAllPresets(
+      customPresets: customKeybindingPresets,
+    );
+
+    return SingleChildScrollView(
+      padding: const EdgeInsetsDirectional.all(24),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const SettingsSectionHeader(title: 'Keybinding Preset'),
+          const SizedBox(height: 16),
+          _buildPresetSelection(context, allPresets),
+          const SizedBox(height: 32),
+          const SettingsSectionHeader(title: 'Popular Shortcuts'),
+          const SizedBox(height: 16),
+          _buildShortcutsPreview(context),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildPresetSelection(
+    BuildContext context,
+    List<KeybindingPreset> allPresets,
+  ) {
+    return Container(
+      padding: const EdgeInsetsDirectional.all(16),
+      decoration: BoxDecoration(
+        color: context.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(
+          color: context.onSurface.addOpacity(0.1),
+        ),
+      ),
+      child: Column(
+        children: [
+          for (final preset in allPresets) ...[
+            RadioListTile<KeybindingPresetEnum>(
+              title: Text(
+                preset.name,
+                style: context.bodyLarge?.copyWith(
+                  fontWeight: FontWeight.w500,
+                ),
+              ),
+              subtitle: preset.description != null
+                  ? Text(
+                      preset.description!,
+                      style: context.bodySmall?.copyWith(
+                        color: context.onSurface.addOpacity(0.6),
+                      ),
+                    )
+                  : null,
+              value: KeybindingPresetEnum.values.firstWhere(
+                (p) => p.name == preset.id,
+                orElse: () => KeybindingPresetEnum.custom,
+              ),
+              groupValue: settings.keybindingPreset,
+              onChanged: (value) {
+                if (value != null) {
+                  onSettingsChanged(settings.copyWith(keybindingPreset: value));
+                }
+              },
+              activeColor: context.primary,
+            ),
+            if (preset != allPresets.last)
+              Divider(
+                color: context.onSurface.addOpacity(0.1),
+                height: 1,
+              ),
+          ],
+        ],
+      ),
+    );
+  }
+
+  Widget _buildShortcutsPreview(BuildContext context) {
+    final preset = KeybindingManager.findPresetById(
+      settings.keybindingPreset.name,
+    );
+    if (preset == null) return const SizedBox.shrink();
+
+    final popularShortcuts = preset.keybindings.take(10).toList();
+
+    return Container(
+      padding: const EdgeInsetsDirectional.all(16),
+      decoration: BoxDecoration(
+        color: context.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(
+          color: context.onSurface.addOpacity(0.1),
+        ),
+      ),
+      child: Column(
+        children: [
+          for (final shortcut in popularShortcuts) ...[
+            ShortcutRow(
+              description: shortcut.description ?? shortcut.command,
+              keyBinding: shortcut.key,
+            ),
+            if (shortcut != popularShortcuts.last)
+              Divider(
+                color: context.onSurface.addOpacity(0.1),
+                height: 16,
+              ),
+          ],
+        ],
+      ),
+    );
+  }
+}
+
+/// Widget for displaying a single keyboard shortcut
+class ShortcutRow extends StatelessWidget {
+  const ShortcutRow({
+    required this.description,
+    required this.keyBinding,
+    super.key,
+  });
+
+  final String description;
+  final String keyBinding;
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      children: [
+        Expanded(
+          child: Text(
+            description,
+            style: context.bodyMedium,
+          ),
+        ),
+        KeyBindingChip(keyBinding: keyBinding),
+      ],
+    );
+  }
+}
+
+/// Widget for displaying a keyboard shortcut in a chip
+class KeyBindingChip extends StatelessWidget {
+  const KeyBindingChip({
+    required this.keyBinding,
+    super.key,
+  });
+
+  final String keyBinding;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsetsDirectional.symmetric(
+        horizontal: 8,
+        vertical: 4,
+      ),
+      decoration: BoxDecoration(
+        color: context.onSurface.addOpacity(0.1),
+        borderRadius: BorderRadius.circular(4),
+      ),
+      child: Text(
+        keyBinding,
+        style: context.labelSmall?.copyWith(
+          fontFamily: 'monospace',
+          fontWeight: FontWeight.w600,
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/languages_tab.dart b/lib/src/features/editor/ui/dialogs/tabs/languages_tab.dart
new file mode 100644
index 0000000..aade744
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/languages_tab.dart
@@ -0,0 +1,234 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Languages settings tab
+class LanguagesTab extends StatelessWidget {
+  const LanguagesTab({
+    required this.settings,
+    required this.onSettingsChanged,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+
+  @override
+  Widget build(BuildContext context) {
+    return SingleChildScrollView(
+      padding: const EdgeInsetsDirectional.all(24),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const SettingsSectionHeader(
+            title: 'Language-Specific Settings',
+            subtitle:
+                'Configure settings that apply only to specific programming languages.',
+          ),
+          const SizedBox(height: 24),
+          _buildLanguageConfigsList(context),
+          const SizedBox(height: 24),
+          Center(
+            child: OutlinedButton.icon(
+              onPressed: () => _showLanguageSettingsDialog(context),
+              icon: const Icon(Icons.add),
+              label: const Text('Add Language Configuration'),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildLanguageConfigsList(BuildContext context) {
+    final entries = settings.languageConfigs.entries.toList();
+    if (entries.isEmpty) {
+      return EmptyLanguageConfigs(
+        onAddPressed: () => _showLanguageSettingsDialog(context),
+      );
+    }
+
+    return ListView.separated(
+      shrinkWrap: true,
+      physics: const NeverScrollableScrollPhysics(),
+      itemCount: entries.length,
+      separatorBuilder: (context, index) => Divider(
+        color: context.onSurface.addOpacity(0.1),
+        height: 1,
+      ),
+      itemBuilder: (context, index) {
+        final entry = entries[index];
+        return LanguageConfigTile(
+          languageKey: entry.key,
+          config: entry.value,
+          onEdit: () => _showLanguageSettingsDialog(
+            context,
+            language: entry.key,
+          ),
+          onRemove: () => _removeLanguageConfig(context, entry.key),
+        );
+      },
+    );
+  }
+
+  void _removeLanguageConfig(BuildContext context, String language) {
+    settings.languageConfigs.remove(language);
+    onSettingsChanged(
+      settings.copyWith(
+        languageConfigs: Map.from(settings.languageConfigs),
+      ),
+    );
+    ScaffoldMessenger.of(context).showSnackBar(
+      SnackBar(
+        content: Text('Removed configuration for $language'),
+        backgroundColor: context.error,
+        behavior: SnackBarBehavior.floating,
+      ),
+    );
+  }
+
+  Future<void> _showLanguageSettingsDialog(
+    BuildContext context, {
+    String? language,
+  }) async {
+    final result = await showDialog<MapEntry<String, LanguageConfig>?>(
+      context: context,
+      barrierDismissible: false,
+      builder: (_) => LanguageSettingsDialog(
+        currentConfigs: settings.languageConfigs,
+        language: language,
+        initialConfig: language != null
+            ? settings.languageConfigs[language]
+            : null,
+      ),
+    );
+
+    if (result != null) {
+      final newConfigs = Map<String, LanguageConfig>.from(
+        settings.languageConfigs,
+      );
+      newConfigs[result.key] = result.value;
+      onSettingsChanged(settings.copyWith(languageConfigs: newConfigs));
+    }
+  }
+}
+
+/// Empty state widget for language configurations
+class EmptyLanguageConfigs extends StatelessWidget {
+  const EmptyLanguageConfigs({
+    required this.onAddPressed,
+    super.key,
+  });
+
+  final VoidCallback onAddPressed;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsetsDirectional.all(24),
+      decoration: BoxDecoration(
+        color: context.surfaceContainerHighest.addOpacity(0.3),
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(
+          color: context.onSurface.addOpacity(0.1),
+        ),
+      ),
+      child: Column(
+        children: [
+          Icon(
+            Icons.code_off_outlined,
+            size: 48,
+            color: context.onSurface.addOpacity(0.4),
+          ),
+          const SizedBox(height: 16),
+          Text(
+            'No Language-Specific Configurations',
+            style: context.titleMedium?.copyWith(
+              fontWeight: FontWeight.w600,
+            ),
+          ),
+          const SizedBox(height: 8),
+          Text(
+            'Click "Add Language Configuration" to define custom settings for specific languages.',
+            textAlign: TextAlign.center,
+            style: context.bodyMedium?.copyWith(
+              color: context.onSurface.addOpacity(0.6),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+}
+
+/// Tile widget for displaying a language configuration
+class LanguageConfigTile extends StatelessWidget {
+  const LanguageConfigTile({
+    required this.languageKey,
+    required this.config,
+    required this.onEdit,
+    required this.onRemove,
+    super.key,
+  });
+
+  final String languageKey;
+  final LanguageConfig config;
+  final VoidCallback onEdit;
+  final VoidCallback onRemove;
+
+  @override
+  Widget build(BuildContext context) {
+    final languageName = EditorConstants.languages[languageKey] ?? languageKey;
+
+    return ListTile(
+      contentPadding: const EdgeInsetsDirectional.symmetric(
+        horizontal: 16,
+        vertical: 8,
+      ),
+      leading: Icon(Icons.language, color: context.primary),
+      title: Text(languageName, style: context.bodyLarge),
+      subtitle: Text(
+        _getConfigSummary(config),
+        style: context.bodySmall?.copyWith(
+          color: context.onSurface.addOpacity(0.6),
+        ),
+        maxLines: 1,
+        overflow: TextOverflow.ellipsis,
+      ),
+      trailing: Row(
+        mainAxisSize: MainAxisSize.min,
+        children: [
+          IconButton(
+            icon: Icon(
+              Icons.edit_outlined,
+              color: context.onSurface.addOpacity(0.7),
+            ),
+            tooltip: 'Edit',
+            onPressed: onEdit,
+          ),
+          IconButton(
+            icon: Icon(Icons.delete_outline, color: context.error),
+            tooltip: 'Remove',
+            onPressed: onRemove,
+          ),
+        ],
+      ),
+      onTap: onEdit,
+    );
+  }
+
+  String _getConfigSummary(LanguageConfig config) {
+    final parts = <String>[];
+    if (config.tabSize != null) parts.add('Tab Size: ${config.tabSize}');
+    if (config.insertSpaces != null) {
+      parts.add(config.insertSpaces! ? 'Use Spaces' : 'Use Tabs');
+    }
+    if (config.wordWrap != null && config.wordWrap != WordWrap.off) {
+      parts.add('Word Wrap: ${config.wordWrap!.name.toTitle}');
+    }
+    if (config.formatOnSave != null && config.formatOnSave!) {
+      parts.add('Format on Save');
+    }
+    return parts.isNotEmpty ? parts.join(', ') : 'Default settings';
+  }
+}
diff --git a/lib/src/features/editor/ui/dialogs/tabs/tabs.dart b/lib/src/features/editor/ui/dialogs/tabs/tabs.dart
new file mode 100644
index 0000000..805a9b4
--- /dev/null
+++ b/lib/src/features/editor/ui/dialogs/tabs/tabs.dart
@@ -0,0 +1,7 @@
+// Barrel export for all settings dialog tabs
+export 'advanced_tab.dart';
+export 'appearance_tab.dart';
+export 'editor_tab.dart';
+export 'general_tab.dart';
+export 'keybindings_tab.dart';
+export 'languages_tab.dart';
diff --git a/lib/src/features/editor/ui/screens/editor_screen.dart b/lib/src/features/editor/ui/screens/editor_screen.dart
new file mode 100644
index 0000000..8c1087e
--- /dev/null
+++ b/lib/src/features/editor/ui/screens/editor_screen.dart
@@ -0,0 +1,530 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:context_collector/src/shared/widgets/shared_drop_zone.dart';
+import 'package:enefty_icons/enefty_icons.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:shared_preferences/shared_preferences.dart';
+
+/// Refactored editor screen with production-ready ResizableSplitter(startPanel: startPanel, endPanel: endPanel)
+class EditorScreen extends ConsumerStatefulWidget {
+  const EditorScreen({super.key});
+
+  @override
+  ConsumerState<EditorScreen> createState() => _EditorScreenState();
+}
+
+class _EditorScreenState extends ConsumerState<EditorScreen>
+    with SingleTickerProviderStateMixin {
+  // Animation controllers for sidebar
+  late AnimationController _sidebarAnimationController;
+  late Animation<double> _sidebarAnimation;
+  bool _isSidebarExpanded = false;
+
+  // Settings state
+  EditorSettings _editorSettings = const EditorSettings();
+  bool _hasAppliedInitialSettings = false;
+
+  // Sidebar dimensions
+  static const double _expandedSidebarWidth = DsDimensions.sidebarWidth;
+
+  // Splitter controller - now using the new SplitterController
+  SplitterController? _splitterController;
+  bool _isSplitterInitialized = false;
+  static const String _splitRatioKey = 'editor_split_ratio';
+
+  @override
+  void initState() {
+    super.initState();
+
+    // Initialize splitter controller with saved ratio
+    _initializeSplitter();
+
+    // Initialize animations
+    _sidebarAnimationController = AnimationController(
+      duration: DesignSystem.durationMedium,
+      vsync: this,
+    );
+    _sidebarAnimation = CurvedAnimation(
+      parent: _sidebarAnimationController,
+      curve: Curves.easeInOutCubic,
+    );
+
+    // Load saved editor settings
+    _loadEditorSettings();
+  }
+
+  Future<void> _initializeSplitter() async {
+    final prefs = await SharedPreferences.getInstance();
+    final savedRatio = prefs.getDouble(_splitRatioKey) ?? 0.35;
+    if (mounted) {
+      setState(() {
+        _splitterController = SplitterController(initialRatio: savedRatio);
+        _isSplitterInitialized = true;
+      });
+    }
+  }
+
+  @override
+  void dispose() {
+    _sidebarAnimationController.dispose();
+    _splitterController?.dispose();
+    super.dispose();
+  }
+
+  Future<void> _saveSplitRatio(double ratio) async {
+    final prefs = await SharedPreferences.getInstance();
+    await prefs.setDouble(_splitRatioKey, ratio);
+  }
+
+  Future<void> _loadEditorSettings() async {
+    final settings = await EditorSettingsServiceHelper.load();
+    if (mounted) {
+      setState(() {
+        _editorSettings = settings;
+      });
+    }
+  }
+
+  Future<void> _applySettingsToEditor() async {
+    final editorService = ref.read(monacoEditorServiceProvider);
+    await editorService.updateSettings(_editorSettings);
+  }
+
+  Future<void> _saveAndApplySettings(EditorSettings newSettings) async {
+    setState(() {
+      _editorSettings = newSettings;
+    });
+    await EditorSettingsServiceHelper.save(newSettings);
+    await _applySettingsToEditor();
+  }
+
+  void _toggleSidebar() {
+    setState(() {
+      _isSidebarExpanded = !_isSidebarExpanded;
+      if (_isSidebarExpanded) {
+        _sidebarAnimationController.forward();
+      } else {
+        _sidebarAnimationController.reverse();
+      }
+    });
+  }
+
+  Future<void> _increaseFontSize() async {
+    if (_editorSettings.fontSize < EditorConstants.maxFontSize) {
+      final newSettings = _editorSettings.copyWith(
+        fontSize: _editorSettings.fontSize + 1,
+      );
+      await _saveAndApplySettings(newSettings);
+    }
+  }
+
+  Future<void> _decreaseFontSize() async {
+    if (_editorSettings.fontSize > EditorConstants.minFontSize) {
+      final newSettings = _editorSettings.copyWith(
+        fontSize: _editorSettings.fontSize - 1,
+      );
+      await _saveAndApplySettings(newSettings);
+    }
+  }
+
+  Future<void> _toggleWordWrap() async {
+    final newWrap = _editorSettings.wordWrap == WordWrap.off
+        ? WordWrap.on
+        : WordWrap.off;
+    final newSettings = _editorSettings.copyWith(wordWrap: newWrap);
+    await _saveAndApplySettings(newSettings);
+  }
+
+  Future<void> _showEnhancedEditorSettings(BuildContext context) async {
+    final newSettings = await EditorSettingsDialog.show(
+      context,
+      _editorSettings,
+      customThemes: [],
+      customKeybindingPresets: [],
+    );
+    if (newSettings != null && mounted) {
+      await _saveAndApplySettings(newSettings);
+    }
+  }
+
+  void _copyToClipboard(BuildContext context, String content) {
+    Clipboard.setData(ClipboardData(text: content))
+        .then((_) => context.showOk('Content copied to clipboard!'))
+        .catchError(
+          (dynamic error) =>
+              context.showErr('Error copying to clipboard: $error'),
+        );
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final selectionState = ref.watch(selectionProvider);
+    final selectionNotifier = ref.read(selectionProvider.notifier);
+    final editorStatus = ref.watch(monacoEditorStatusProvider);
+
+    // Listen for editor ready state to apply initial settings
+    ref.listen<EditorStatus>(monacoEditorStatusProvider, (previous, next) {
+      if (!_hasAppliedInitialSettings && next.isReady) {
+        _hasAppliedInitialSettings = true;
+        _applySettingsToEditor();
+      }
+    });
+
+    return Scaffold(
+      backgroundColor: context.surface,
+      appBar: AppBar(
+        // Compact height for desktop
+        toolbarHeight: 56,
+
+        // Left side - Primary actions
+        leading: Padding(
+          padding: const EdgeInsets.only(left: 12),
+          child: Row(
+            mainAxisSize: MainAxisSize.min,
+            children: [
+              // Single Add button with dropdown
+              PopupMenuButton<String>(
+                tooltip: 'Add files or folder',
+                position: PopupMenuPosition.under,
+                shape: RoundedRectangleBorder(
+                  borderRadius: BorderRadius.circular(8),
+                ),
+                onSelected: (value) {
+                  if (value == 'files') {
+                    selectionNotifier.pickFiles(context);
+                  } else if (value == 'folder') {
+                    selectionNotifier.pickDirectory(context);
+                  }
+                },
+                itemBuilder: (context) => [
+                  const PopupMenuItem(
+                    value: 'files',
+                    child: ListTile(
+                      dense: true,
+                      leading: Icon(Icons.insert_drive_file_outlined, size: 20),
+                      title: Text('Add Files'),
+                    ),
+                  ),
+                  const PopupMenuItem(
+                    value: 'folder',
+                    child: ListTile(
+                      dense: true,
+                      leading: Icon(Icons.folder_outlined, size: 20),
+                      title: Text('Add Folder'),
+                    ),
+                  ),
+                ],
+                child: FilledButton.tonalIcon(
+                  icon: const Icon(Icons.add_rounded, size: 18),
+                  label: const Text('Add'),
+                  onPressed: null, // Button is just for display
+                  style: FilledButton.styleFrom(
+                    padding: const EdgeInsets.symmetric(horizontal: 12),
+                    visualDensity: VisualDensity.compact,
+                  ),
+                ),
+              ),
+
+              const SizedBox(width: 8),
+
+              // Save action
+              FilledButton.icon(
+                icon: const Icon(Icons.save_alt_rounded, size: 18),
+                label: const Text('Save'),
+                onPressed: selectionState.hasSelectedFiles
+                    ? selectionNotifier.saveToFile
+                    : null,
+                style: FilledButton.styleFrom(
+                  padding: const EdgeInsets.symmetric(horizontal: 12),
+                  visualDensity: VisualDensity.compact,
+                ),
+              ),
+            ],
+          ),
+        ),
+        leadingWidth: 280,
+
+        // Centered title
+        title: Row(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            Container(
+              padding: const EdgeInsets.all(8),
+              decoration: BoxDecoration(
+                gradient: LinearGradient(
+                  colors: [
+                    context.primary,
+                    context.primary.addOpacity(0.8),
+                  ],
+                ),
+                borderRadius: BorderRadius.circular(10),
+              ),
+              child: const Icon(
+                Icons.collections_bookmark_rounded,
+                color: Colors.white,
+                size: 20,
+              ),
+            ),
+            const SizedBox(width: 12),
+            const Text('Context Collector'),
+          ],
+        ),
+        centerTitle: true,
+
+        actions: [
+          // Right side - App-level actions
+          IconButton(
+            icon: Icon(
+              Icons.clear_all_rounded,
+              size: 20,
+              color: selectionState.hasFiles
+                  ? context.error.addOpacity(0.8)
+                  : null,
+            ),
+            onPressed: selectionState.hasFiles
+                ? selectionNotifier.clearFiles
+                : null,
+            tooltip: 'Clear All Files',
+          ),
+
+          const SizedBox(width: 4),
+
+          IconButton(
+            icon: const Icon(Icons.settings_outlined, size: 20),
+            onPressed: () {
+              Navigator.push(
+                context,
+                MaterialPageRoute<void>(
+                  builder: (context) => const SettingsScreen(),
+                ),
+              );
+            },
+            tooltip: 'Settings',
+          ),
+
+          const SizedBox(width: 16),
+        ],
+      ),
+      body: DropZone(
+        child: Column(
+          children: [
+            // Main editor area with production ResizableSplitter
+            Expanded(
+              child: _isSplitterInitialized && _splitterController != null
+                  ? ResizableSplitter(
+                      controller: _splitterController,
+                      minRatio: 0.2,
+                      maxRatio: 0.6,
+                      minPanelSize: 300,
+                      onRatioChanged: _saveSplitRatio,
+                      dividerThickness: 12,
+                      enableKeyboard: true,
+                      semanticsLabel:
+                          'Editor panels splitter. Drag to resize or use arrow keys.',
+                      startPanel: Column(
+                        children: [
+                          const Expanded(child: FileListScreen()),
+                          if (selectionState.isProcessing)
+                            const LinearProgressIndicator(),
+                        ],
+                      ),
+                      endPanel: Stack(
+                        children: [
+                          // Monaco Editor
+                          const MonacoEditorContainer(
+                            key: Key('editor-screen-monaco'),
+                          ),
+
+                          // Animated Sidebar (INSIDE Monaco editor area)
+                          AnimatedBuilder(
+                            animation: _sidebarAnimation,
+                            builder: (context, child) {
+                              final width =
+                                  _expandedSidebarWidth *
+                                  _sidebarAnimation.value;
+
+                              return Positioned(
+                                left: 0,
+                                top: 0,
+                                bottom: 0,
+                                child: SizedBox(
+                                  width: width,
+                                  child: width > 0
+                                      ? ClipRect(
+                                          child: Container(
+                                            decoration: BoxDecoration(
+                                              color: context
+                                                  .surfaceContainerHighest,
+                                              border: BorderDirectional(
+                                                end: BorderSide(
+                                                  color: context.outline
+                                                      .addOpacity(
+                                                        0.2,
+                                                      ),
+                                                ),
+                                              ),
+                                              boxShadow: [
+                                                BoxShadow(
+                                                  color: context.shadow
+                                                      .addOpacity(
+                                                        0.05,
+                                                      ),
+                                                  offset: const Offset(2, 0),
+                                                  blurRadius: 4,
+                                                ),
+                                              ],
+                                            ),
+                                            child: QuickSidebar(
+                                              settings: _editorSettings,
+                                              selectionState: selectionState,
+                                              onSettingsChanged:
+                                                  _saveAndApplySettings,
+                                              onWordWrapToggle: _toggleWordWrap,
+                                              onIncreaseFontSize:
+                                                  _increaseFontSize,
+                                              onDecreaseFontSize:
+                                                  _decreaseFontSize,
+                                              onShowAllSettings: () =>
+                                                  _showEnhancedEditorSettings(
+                                                    context,
+                                                  ),
+                                              onCopyContent: () =>
+                                                  _copyToClipboard(
+                                                    context,
+                                                    selectionState
+                                                        .combinedContent,
+                                                  ),
+                                            ),
+                                          ),
+                                        )
+                                      : null,
+                                ),
+                              );
+                            },
+                          ),
+
+                          // Floating Toggle Button (positioned in editor area)
+                          Positioned(
+                            left: _isSidebarExpanded
+                                ? _expandedSidebarWidth - 20
+                                : 8,
+                            top: 16,
+                            child: AnimatedBuilder(
+                              animation: _sidebarAnimation,
+                              builder: (context, child) {
+                                return Material(
+                                  color: _isSidebarExpanded
+                                      ? context.surfaceContainerHighest
+                                      : context.surface,
+                                  elevation: 4,
+                                  shape: const CircleBorder(),
+                                  child: InkWell(
+                                    onTap: _toggleSidebar,
+                                    customBorder: const CircleBorder(),
+                                    splashColor: Colors.transparent,
+                                    highlightColor: Colors.transparent,
+                                    hoverColor: context.onSurface.addOpacity(
+                                      0.04,
+                                    ),
+                                    child: Container(
+                                      width: 36,
+                                      height: 36,
+                                      decoration: BoxDecoration(
+                                        shape: BoxShape.circle,
+                                        border: Border.all(
+                                          color: context.outline.addOpacity(
+                                            0.2,
+                                          ),
+                                        ),
+                                      ),
+                                      child: Icon(
+                                        _isSidebarExpanded
+                                            ? Icons.chevron_left
+                                            : EneftyIcons.setting_3_outline,
+                                        size: 20,
+                                        color: context.onSurfaceVariant,
+                                      ),
+                                    ),
+                                  ),
+                                );
+                              },
+                            ),
+                          ),
+
+                          // Keyboard hint (shows when editor is loading)
+                          Positioned(
+                            bottom: 8,
+                            right: 8,
+                            child: AnimatedOpacity(
+                              opacity: editorStatus.isReady ? 0.0 : 1.0,
+                              duration: DesignSystem.durationMedium,
+                              child: Container(
+                                padding: const EdgeInsets.symmetric(
+                                  horizontal: 12,
+                                  vertical: 6,
+                                ),
+                                decoration: BoxDecoration(
+                                  color: context.surface.addOpacity(0.9),
+                                  borderRadius: BorderRadius.circular(16),
+                                  border: Border.all(
+                                    color: context.outline.addOpacity(0.2),
+                                  ),
+                                ),
+                                child: Row(
+                                  mainAxisSize: MainAxisSize.min,
+                                  children: [
+                                    Icon(
+                                      Icons.keyboard_rounded,
+                                      size: 14,
+                                      color: context.onSurfaceVariant,
+                                    ),
+                                    const SizedBox(width: 6),
+                                    Text(
+                                      'Tab to focus splitter ‚Ä¢ ‚Üê‚Üí to resize',
+                                      style: context.textTheme.bodySmall
+                                          ?.copyWith(
+                                            color: context.onSurfaceVariant,
+                                          ),
+                                    ),
+                                  ],
+                                ),
+                              ),
+                            ),
+                          ),
+                        ],
+                      ),
+                    )
+                  : Center(
+                      child: Column(
+                        mainAxisAlignment: MainAxisAlignment.center,
+                        children: [
+                          CircularProgressIndicator(
+                            color: context.primary,
+                          ),
+                          const SizedBox(height: 16),
+                          Text(
+                            'Loading layout...',
+                            style: context.textTheme.bodyMedium?.copyWith(
+                              color: context.onSurfaceVariant,
+                            ),
+                          ),
+                        ],
+                      ),
+                    ),
+            ),
+
+            // Bottom info bar
+            if (editorStatus.isReady)
+              MonacoEditorInfoBar(
+                bridge: ref.read(monacoEditorServiceProvider).bridge,
+                onCopy: () =>
+                    _copyToClipboard(context, selectionState.combinedContent),
+              ),
+          ],
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/info_bar/info_bar.dart b/lib/src/features/editor/ui/widgets/info_bar/info_bar.dart
new file mode 100644
index 0000000..637f0e6
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/info_bar/info_bar.dart
@@ -0,0 +1,132 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:enefty_icons/enefty_icons.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+/// Refactored info bar with extracted components
+class MonacoEditorInfoBar extends ConsumerWidget {
+  const MonacoEditorInfoBar({
+    required this.bridge,
+    required this.onCopy,
+    super.key,
+  });
+
+  final MonacoBridgePlatform bridge;
+  final VoidCallback onCopy;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    return ListenableBuilder(
+      listenable: bridge,
+      builder: (context, _) {
+        return FutureBuilder<void>(
+          future: bridge.onReady.future,
+          builder: (context, snapshot) {
+            if (!snapshot.hasData &&
+                snapshot.connectionState != ConnectionState.done) {
+              return _LoadingIndicator();
+            }
+
+            return Container(
+              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
+              decoration: BoxDecoration(
+                border: Border(
+                  top: BorderSide(color: context.outline.addOpacity(0.2)),
+                ),
+              ),
+              child: Row(
+                children: [
+                  // Stats Display
+                  ValueListenableBuilder<LiveStats>(
+                    valueListenable: bridge.liveStats,
+                    builder: (context, stats, _) {
+                      return StatsRow(
+                        stats: stats,
+                        content: bridge.content,
+                      );
+                    },
+                  ),
+                  const SizedBox(width: 12),
+
+                  // Language Selector
+                  LanguageSelector(
+                    currentLanguage: bridge.language,
+                    onLanguageChanged: bridge.setLanguage,
+                  ),
+
+                  const Spacer(),
+
+                  // Action Buttons
+                  ..._buildActionButtons(context),
+                ],
+              ),
+            );
+          },
+        );
+      },
+    );
+  }
+
+  List<Widget> _buildActionButtons(BuildContext context) {
+    return [
+      IconButton(
+        icon: const Icon(EneftyIcons.arrow_circle_up_outline, size: 20),
+        tooltip: 'Scroll to Top',
+        onPressed: bridge.scrollToTop,
+      ),
+      IconButton(
+        icon: const Icon(EneftyIcons.arrow_circle_down_outline, size: 20),
+        tooltip: 'Scroll to Bottom',
+        onPressed: bridge.scrollToBottom,
+      ),
+      const VerticalDivider(width: 1, indent: 8, endIndent: 8),
+      IconButton(
+        icon: const Icon(EneftyIcons.textalign_justifyleft_outline, size: 20),
+        tooltip: 'Format Content',
+        onPressed: bridge.format,
+      ),
+      IconButton(
+        icon: const Icon(EneftyIcons.copy_outline, size: 20),
+        tooltip: 'Copy Content',
+        onPressed: onCopy,
+      ),
+    ];
+  }
+}
+
+/// Loading indicator widget
+class _LoadingIndicator extends StatelessWidget {
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
+      decoration: BoxDecoration(
+        color: context.surfaceContainerHighest,
+        border: Border(
+          top: BorderSide(color: context.outline.addOpacity(0.2)),
+        ),
+      ),
+      child: Row(
+        mainAxisSize: MainAxisSize.min,
+        children: [
+          SizedBox(
+            width: 16,
+            height: 16,
+            child: CircularProgressIndicator(
+              strokeWidth: 2,
+              valueColor: AlwaysStoppedAnimation<Color>(context.primary),
+            ),
+          ),
+          const SizedBox(width: 12),
+          Text(
+            'Initializing Monaco Editor...',
+            style: context.labelMedium?.copyWith(
+              color: context.onSurfaceVariant,
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/info_bar/info_bar_widgets.dart b/lib/src/features/editor/ui/widgets/info_bar/info_bar_widgets.dart
new file mode 100644
index 0000000..d4527d7
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/info_bar/info_bar_widgets.dart
@@ -0,0 +1,5 @@
+// Barrel export for info bar widgets
+export 'info_bar.dart';
+export 'language_selector.dart';
+export 'stats_row.dart';
+export 'token_chip.dart';
diff --git a/lib/src/features/editor/ui/widgets/info_bar/language_selector.dart b/lib/src/features/editor/ui/widgets/info_bar/language_selector.dart
new file mode 100644
index 0000000..3fbbf1a
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/info_bar/language_selector.dart
@@ -0,0 +1,71 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Language selector dropdown for the info bar
+class LanguageSelector extends StatelessWidget {
+  const LanguageSelector({
+    required this.currentLanguage,
+    required this.onLanguageChanged,
+    super.key,
+  });
+
+  final String currentLanguage;
+  final ValueChanged<String> onLanguageChanged;
+
+  @override
+  Widget build(BuildContext context) {
+    return PopupMenuButton<String>(
+      tooltip: 'Select Language',
+      onSelected: onLanguageChanged,
+      offset: const Offset(0, -300),
+      itemBuilder: (_) => EditorConstants.languages.entries.map((entry) {
+        final isSelected = currentLanguage == entry.key;
+        return PopupMenuItem<String>(
+          value: entry.key,
+          child: Row(
+            children: [
+              Icon(
+                Icons.check,
+                size: 16,
+                color: isSelected ? context.primary : Colors.transparent,
+              ),
+              const SizedBox(width: 8),
+              Text(entry.value),
+            ],
+          ),
+        );
+      }).toList(),
+      child: Container(
+        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
+        decoration: BoxDecoration(
+          color: context.surfaceContainerHighest,
+          borderRadius: BorderRadius.circular(6),
+          border: Border.all(
+            color: context.outlineVariant.addOpacity(0.5),
+            width: 0.5,
+          ),
+        ),
+        child: Row(
+          children: [
+            Icon(Icons.translate, size: 16, color: context.primary),
+            const SizedBox(width: 6),
+            Text(
+              EditorConstants.languages[currentLanguage] ??
+                  currentLanguage.toUpperCase(),
+              style: context.labelSmall?.copyWith(
+                fontWeight: FontWeight.w500,
+              ),
+            ),
+            const SizedBox(width: 4),
+            Icon(
+              Icons.arrow_drop_down,
+              size: 18,
+              color: context.onSurfaceVariant,
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/info_bar/stats_row.dart b/lib/src/features/editor/ui/widgets/info_bar/stats_row.dart
new file mode 100644
index 0000000..ca96f2e
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/info_bar/stats_row.dart
@@ -0,0 +1,70 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+
+/// Row displaying editor statistics
+class StatsRow extends StatelessWidget {
+  const StatsRow({
+    required this.stats,
+    required this.content,
+    super.key,
+  });
+
+  final LiveStats stats;
+  final String content;
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      mainAxisSize: MainAxisSize.min,
+      children: [
+        StatItem(
+          label: stats.lineCount.label,
+          value: stats.lineCount.value,
+        ),
+        StatItem(
+          label: stats.charCount.label,
+          value: stats.charCount.value,
+        ),
+        if (stats.hasSelection) ...[
+          StatItem(
+            label: stats.selectedLines.label,
+            value: stats.selectedLines.value,
+          ),
+          StatItem(
+            label: stats.selectedCharacters.label,
+            value: stats.selectedCharacters.value,
+          ),
+        ],
+        if (stats.caretCount.value > 1)
+          StatItem(
+            label: stats.caretCount.label,
+            value: stats.caretCount.value,
+          ),
+        if (stats.charCount.value > 0) TokenCountChip(content: content),
+      ],
+    );
+  }
+}
+
+/// Individual stat item widget
+class StatItem extends StatelessWidget {
+  const StatItem({
+    required this.label,
+    required this.value,
+    super.key,
+  });
+
+  final String label;
+  final int value;
+
+  @override
+  Widget build(BuildContext context) {
+    return Padding(
+      padding: const EdgeInsets.symmetric(horizontal: 6),
+      child: Text(
+        '$label: $value',
+        style: context.labelSmall?.copyWith(color: context.onSurfaceVariant),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/info_bar/token_chip.dart b/lib/src/features/editor/ui/widgets/info_bar/token_chip.dart
new file mode 100644
index 0000000..e1e6708
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/info_bar/token_chip.dart
@@ -0,0 +1,229 @@
+import 'package:ai_token_calculator/ai_token_calculator.dart';
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+/// A chip that displays the estimated token count and allows changing the AI model
+class TokenCountChip extends ConsumerWidget {
+  const TokenCountChip({
+    required this.content,
+    super.key,
+  });
+
+  final String content;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final calculator = ref.watch(tokenCalculatorProvider);
+    final selectedModel = ref.watch(selectedAIModelProvider);
+    final estimate = calculator.estimateTokens(
+      content,
+      model: selectedModel,
+    );
+
+    final usage =
+        estimate.tokens /
+        AITokenCalculator.modelSpecs[selectedModel]!.contextWindow;
+
+    return Theme(
+      data: Theme.of(context).copyWith(
+        tooltipTheme: TooltipThemeData(
+          decoration: BoxDecoration(
+            color: context.brightness == Brightness.dark
+                ? context.surface
+                : context.surfaceContainerHighest,
+            borderRadius: BorderRadius.circular(8),
+            border: Border.all(
+              color: context.outlineVariant.addOpacity(0.3),
+              width: 1,
+            ),
+            boxShadow: [
+              BoxShadow(
+                color: Colors.black.addOpacity(0.15),
+                blurRadius: 8,
+                offset: const Offset(0, 2),
+              ),
+            ],
+          ),
+          textStyle: context.labelMedium,
+        ),
+      ),
+      child: Tooltip(
+        richMessage: WidgetSpan(
+          child: _buildTooltipContent(context, selectedModel, estimate, usage),
+        ),
+        child: DsChip(
+          label: '~${estimate.tokens.compact()} ‚ÜØ',
+          backgroundColor: context.primaryContainer.addOpacity(0.3),
+          textColor: _getTokenColor(context, usage),
+          onTap: () => _showModelMenu(context, ref, calculator),
+          dense: true,
+        ),
+      ),
+    );
+  }
+
+  Widget _buildTooltipContent(
+    BuildContext context,
+    AIModel selectedModel,
+    TokenEstimate estimate,
+    double usage,
+  ) {
+    return Container(
+      padding: const EdgeInsets.all(12),
+      constraints: const BoxConstraints(maxWidth: 250),
+      decoration: BoxDecoration(
+        color: context.brightness == Brightness.dark
+            ? context.surface
+            : context.surfaceContainerHighest,
+        borderRadius: BorderRadius.circular(8),
+      ),
+      child: Column(
+        mainAxisSize: MainAxisSize.min,
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Text(
+            AITokenCalculator.modelSpecs[selectedModel]!.displayName,
+            style: context.titleSmall?.copyWith(
+              fontWeight: FontWeight.bold,
+              color: context.onSurface,
+            ),
+          ),
+          context.ds.spaceHeight(DesignSystem.space8),
+          Text(
+            '~${(estimate as dynamic).tokens} tokens',
+            style: context.bodySmall?.copyWith(
+              color: context.onSurface,
+            ),
+          ),
+          context.ds.spaceHeight(DesignSystem.space12),
+          ClipRRect(
+            borderRadius: BorderRadius.circular(4),
+            child: LinearProgressIndicator(
+              value: usage.clamp(0.0, 1.0),
+              backgroundColor: context.surfaceContainerHighest,
+              valueColor: AlwaysStoppedAnimation<Color>(
+                _getUsageColor(usage),
+              ),
+              minHeight: 6,
+            ),
+          ),
+          context.ds.spaceHeight(6),
+          Text(
+            '${(usage * 100).toStringAsFixed(1)}% of context window',
+            style: context.labelSmall?.copyWith(
+              color: context.onSurfaceVariant,
+            ),
+          ),
+          context.ds.spaceHeight(DesignSystem.space12),
+          Divider(
+            color: context.outlineVariant,
+            height: 1,
+          ),
+          context.ds.spaceHeight(DesignSystem.space8),
+          Text(
+            'Click to compare models',
+            style: context.labelSmall?.copyWith(
+              color: context.primary,
+              fontWeight: FontWeight.w500,
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  void _showModelMenu(
+    BuildContext context,
+    WidgetRef ref,
+    AITokenCalculator calculator,
+  ) {
+    final RenderBox button = context.findRenderObject()! as RenderBox;
+    final overlay =
+        Overlay.of(context).context.findRenderObject()! as RenderBox;
+    final position = RelativeRect.fromRect(
+      Rect.fromPoints(
+        button.localToGlobal(Offset.zero, ancestor: overlay),
+        button.localToGlobal(
+          button.size.bottomRight(Offset.zero),
+          ancestor: overlay,
+        ),
+      ),
+      Offset.zero & overlay.size,
+    );
+
+    final popularModels = [
+      AIModel.claudeSonnet,
+      AIModel.claudeOpus,
+      AIModel.gpt4,
+      AIModel.gpt35Turbo,
+      AIModel.geminiPro,
+      AIModel.grok,
+    ];
+
+    showMenu<AIModel>(
+      context: context,
+      position: position,
+      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
+      items: popularModels.map((model) {
+        return PopupMenuItem<AIModel>(
+          value: model,
+          child: _buildModelMenuItem(context, ref, calculator, model),
+        );
+      }).toList(),
+    ).then((selectedModel) {
+      if (selectedModel != null) {
+        ref.read(selectedAIModelProvider.notifier).state = selectedModel;
+      }
+    });
+  }
+
+  Widget _buildModelMenuItem(
+    BuildContext context,
+    WidgetRef ref,
+    AITokenCalculator calculator,
+    AIModel model,
+  ) {
+    final currentSelectedModel = ref.watch(selectedAIModelProvider);
+    final isSelected = model == currentSelectedModel;
+    final estimate = calculator.estimateTokens(content, model: model);
+    final spec = AITokenCalculator.modelSpecs[model]!;
+
+    return Row(
+      children: [
+        Icon(
+          Icons.check,
+          size: 16,
+          color: isSelected ? context.primary : Colors.transparent,
+        ),
+        const SizedBox(width: 8),
+        Expanded(
+          child: Text(
+            spec.displayName,
+            style: context.labelMedium?.copyWith(
+              fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
+            ),
+          ),
+        ),
+        const SizedBox(width: 8),
+        Text(
+          '~${estimate.tokens.compact()}',
+          style: context.labelSmall?.copyWith(color: context.onSurfaceVariant),
+        ),
+      ],
+    );
+  }
+
+  Color _getUsageColor(double usage) {
+    if (usage > 0.9) return Colors.red;
+    if (usage > 0.75) return Colors.orange;
+    return Colors.green;
+  }
+
+  Color _getTokenColor(BuildContext context, double usage) {
+    if (usage > 0.9) return context.error;
+    if (usage > 0.75) return Colors.orange;
+    return context.primary;
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/monaco_container.dart b/lib/src/features/editor/ui/widgets/monaco_container.dart
new file mode 100644
index 0000000..f7bcee6
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/monaco_container.dart
@@ -0,0 +1,81 @@
+// lib/src/features/editor/presentation/ui/global_monaco_container.dart
+import 'dart:async';
+
+import 'package:context_collector/src/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+/// Global container with layered architecture.
+/// This widget is the main controller that orchestrates the visibility of the UI
+/// and the flow of data between the file selection and the editor service.
+class GlobalMonacoContainer extends ConsumerStatefulWidget {
+  const GlobalMonacoContainer({
+    required this.child, // This will be the HomeScreen
+    super.key,
+  });
+
+  final Widget child;
+
+  @override
+  ConsumerState<GlobalMonacoContainer> createState() =>
+      _GlobalMonacoContainerState();
+}
+
+class _GlobalMonacoContainerState extends ConsumerState<GlobalMonacoContainer> {
+  Timer? _debounceTimer;
+
+  @override
+  void dispose() {
+    _debounceTimer?.cancel();
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    // Listen for changes in the selection state to update the editor.
+    // This listener lives here, in a widget that is ALWAYS in the tree,
+    // so it will never miss an update. This is the core fix.
+    ref.listen<SelectionState>(selectionProvider, (previous, next) {
+      if (previous?.combinedContent != next.combinedContent) {
+        // Cancel any pending updates
+        _debounceTimer?.cancel();
+
+        // Debounce the update by 100ms to avoid rapid updates
+        _debounceTimer = Timer(const Duration(milliseconds: 100), () {
+          if (mounted) {
+            final editorService = ref.read(monacoProvider.notifier);
+            debugPrint(
+              '[GlobalListener] Updating editor content after debounce...',
+            );
+            editorService.updateContent(next.combinedContent);
+          }
+        });
+      }
+    });
+
+    // Determine if the HomeScreen overlay should be visible.
+    final selectionState = ref.watch(selectionProvider);
+    final showHomeOverlay = selectionState.fileMap.isEmpty;
+
+    return Material(
+      child: Stack(
+        children: [
+          // BOTTOM LAYER: The EditorScreen is always present in the background,
+          // fulfilling the "always-ready" requirement.
+          const EditorScreen(),
+
+          // TOP LAYER: The HomeScreen drop zone, which fades in or out.
+          AnimatedSwitcher(
+            duration: const Duration(milliseconds: 300),
+            switchInCurve: Curves.easeIn,
+            switchOutCurve: Curves.easeOut,
+            child: showHomeOverlay
+                ? widget
+                      .child // Show the HomeScreen
+                : const SizedBox.shrink(key: ValueKey('hidden')), // Hide it
+          ),
+        ],
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/monaco_editor_container.dart b/lib/src/features/editor/ui/widgets/monaco_editor_container.dart
new file mode 100644
index 0000000..213fbe9
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/monaco_editor_container.dart
@@ -0,0 +1,17 @@
+import 'package:context_collector/src/features/editor/ui/widgets/monaco_editor_integrated.dart';
+import 'package:flutter/material.dart';
+
+/// A simple, stateless container whose only job is to render the
+/// self-contained [MonacoEditorIntegrated] widget.
+///
+/// All logic for listening to state changes has been moved up to the
+/// [GlobalMonacoContainer] for better reliability.
+class MonacoEditorContainer extends StatelessWidget {
+  const MonacoEditorContainer({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    // This widget now has only one responsibility: build the editor UI.
+    return const MonacoEditorIntegrated();
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/monaco_editor_integrated.dart b/lib/src/features/editor/ui/widgets/monaco_editor_integrated.dart
new file mode 100644
index 0000000..266f42f
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/monaco_editor_integrated.dart
@@ -0,0 +1,143 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+/// A stateless, declarative UI widget that displays the Monaco Editor.
+///
+/// This widget listens to the [monacoProvider] and renders the appropriate
+/// UI for the current editor state (loading, ready, or error). It holds no
+/// internal state or complex logic, delegating all of that to the service.
+class MonacoEditorIntegrated extends ConsumerWidget {
+  const MonacoEditorIntegrated({super.key});
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    // Watch the single source of truth for the editor's status.
+    final editorStatus = ref.watch(monacoProvider);
+
+    // The entire UI is built declaratively based on the service's state.
+    return AnimatedSwitcher(
+      duration: const Duration(milliseconds: 300),
+      child: _buildContentForStatus(context, ref, editorStatus),
+    );
+  }
+
+  /// Selects the correct view to display based on the EditorStatus.
+  Widget _buildContentForStatus(
+    BuildContext context,
+    WidgetRef ref,
+    EditorStatus status,
+  ) {
+    final service = ref.read(monacoProvider.notifier);
+    // Each state has a unique key to ensure AnimatedSwitcher transitions correctly.
+    return switch (status.lifecycle) {
+      EditorLifecycle.ready =>
+        // HAPPY PATH: The editor is ready. Get the pre-configured webview widget
+        // directly from the service and display it.
+        SizedBox.expand(
+          key: const ValueKey('monaco_ready'),
+          child: service.webviewWidget,
+        ),
+      EditorLifecycle.error =>
+        // ERROR STATE: Something went wrong. Show an informative error view.
+        _ErrorView(
+          key: const ValueKey('monaco_error'),
+          error: status.error,
+          onRetry: service.initialize,
+        ),
+      _ =>
+        // LOADING STATES: For all other states (initial, loading assets, etc.),
+        // show a consistent loading view with the current status message.
+        _LoadingView(
+          key: const ValueKey('monaco_loading'),
+          message: status.message,
+        ),
+    };
+  }
+}
+
+/// A private helper widget for displaying the loading state.
+class _LoadingView extends StatelessWidget {
+  const _LoadingView({required this.message, super.key});
+
+  final String message;
+
+  @override
+  Widget build(BuildContext context) {
+    return ColoredBox(
+      color: context.isDark ? const Color(0xFF1E1E1E) : Colors.white,
+      child: Center(
+        child: Column(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            const CircularProgressIndicator(),
+            const SizedBox(height: 24),
+            Text(
+              'Starting Monaco Editor...',
+              style: context.bodyMedium?.copyWith(
+                color: context.onSurface.addOpacity(0.8),
+              ),
+            ),
+            const SizedBox(height: 8),
+            Text(
+              message,
+              style: context.bodySmall?.copyWith(
+                color: context.onSurface.addOpacity(0.6),
+              ),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+}
+
+/// A private helper widget for displaying the error state.
+class _ErrorView extends StatelessWidget {
+  const _ErrorView({this.error, required this.onRetry, super.key});
+
+  final String? error;
+  final VoidCallback onRetry;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsets.all(32),
+      child: Center(
+        child: Column(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            Icon(Icons.error_outline, size: 64, color: context.error),
+            const SizedBox(height: 16),
+            Text(
+              'Monaco Editor Error',
+              style: context.titleLarge?.copyWith(color: context.error),
+            ),
+            const SizedBox(height: 16),
+            Container(
+              padding: const EdgeInsets.all(16),
+              decoration: BoxDecoration(
+                color: context.errorContainer,
+                borderRadius: BorderRadius.circular(8),
+              ),
+              child: Text(
+                error ?? 'An unknown error occurred during initialization.',
+                textAlign: TextAlign.center,
+                style: context.bodyMedium?.copyWith(
+                  color: context.onErrorContainer,
+                ),
+              ),
+            ),
+            const SizedBox(height: 24),
+            ElevatedButton.icon(
+              onPressed: onRetry,
+              icon: const Icon(Icons.refresh),
+              label: const Text('Retry Initialization'),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/quick_sidebar/font_size_control.dart b/lib/src/features/editor/ui/widgets/quick_sidebar/font_size_control.dart
new file mode 100644
index 0000000..b827e3c
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/quick_sidebar/font_size_control.dart
@@ -0,0 +1,72 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Font size control widget with increase/decrease buttons
+class FontSizeControl extends StatelessWidget {
+  const FontSizeControl({
+    required this.fontSize,
+    required this.onIncrease,
+    required this.onDecrease,
+    super.key,
+  });
+
+  final double fontSize;
+  final VoidCallback onIncrease;
+  final VoidCallback onDecrease;
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      children: [
+        IconButton(
+          onPressed: fontSize > EditorConstants.minFontSize ? onDecrease : null,
+          icon: Icon(
+            Icons.remove,
+            color: context.onSurfaceVariant,
+          ),
+          iconSize: 18,
+          style: IconButton.styleFrom(
+            minimumSize: const Size(32, 32),
+          ),
+          splashRadius: 0.1,
+          highlightColor: Colors.transparent,
+          splashColor: Colors.transparent,
+          hoverColor: context.onSurface.addOpacity(0.04),
+        ),
+        Expanded(
+          child: Container(
+            height: 32,
+            decoration: BoxDecoration(
+              color: context.surface,
+              borderRadius: BorderRadius.circular(8),
+            ),
+            child: Center(
+              child: Text(
+                '${fontSize.round()}px',
+                style: context.labelLarge?.copyWith(
+                  fontWeight: FontWeight.w600,
+                ),
+              ),
+            ),
+          ),
+        ),
+        IconButton(
+          onPressed: fontSize < EditorConstants.maxFontSize ? onIncrease : null,
+          icon: Icon(
+            Icons.add,
+            color: context.onSurfaceVariant,
+          ),
+          iconSize: 18,
+          style: IconButton.styleFrom(
+            minimumSize: const Size(32, 32),
+          ),
+          splashRadius: 0.1,
+          highlightColor: Colors.transparent,
+          splashColor: Colors.transparent,
+          hoverColor: context.onSurface.addOpacity(0.04),
+        ),
+      ],
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/quick_sidebar/quick_sidebar.dart b/lib/src/features/editor/ui/widgets/quick_sidebar/quick_sidebar.dart
new file mode 100644
index 0000000..cc21a44
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/quick_sidebar/quick_sidebar.dart
@@ -0,0 +1,300 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+/// Quick sidebar for editor settings
+class QuickSidebar extends StatelessWidget {
+  const QuickSidebar({
+    required this.settings,
+    required this.selectionState,
+    required this.onSettingsChanged,
+    required this.onWordWrapToggle,
+    required this.onIncreaseFontSize,
+    required this.onDecreaseFontSize,
+    required this.onShowAllSettings,
+    required this.onCopyContent,
+    super.key,
+  });
+
+  final EditorSettings settings;
+  final SelectionState selectionState;
+  final ValueChanged<EditorSettings> onSettingsChanged;
+  final VoidCallback onWordWrapToggle;
+  final VoidCallback onIncreaseFontSize;
+  final VoidCallback onDecreaseFontSize;
+  final VoidCallback onShowAllSettings;
+  final VoidCallback onCopyContent;
+
+  @override
+  Widget build(BuildContext context) {
+    return SingleChildScrollView(
+      padding: const EdgeInsets.all(16),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          // Header with some spacing for the floating button
+          const SizedBox(height: 28),
+          _buildHeader(context),
+          const SizedBox(height: 20),
+
+          // File Count Badge
+          if (selectionState.selectedFilesCount > 0) ...[
+            FileCountBadge(count: selectionState.selectedFilesCount),
+            const SizedBox(height: 16),
+          ],
+
+          // Font Size Section
+          const SectionTitle(title: 'Font Size'),
+          const SizedBox(height: 8),
+          FontSizeControl(
+            fontSize: settings.fontSize,
+            onIncrease: onIncreaseFontSize,
+            onDecrease: onDecreaseFontSize,
+          ),
+
+          const SizedBox(height: 20),
+
+          // Quick Toggles
+          const SectionTitle(title: 'Editor Options'),
+          const SizedBox(height: 8),
+
+          ToggleTile(
+            icon: Icons.wrap_text,
+            title: 'Word Wrap',
+            value: settings.wordWrap != WordWrap.off,
+            onChanged: (_) => onWordWrapToggle(),
+          ),
+
+          ToggleTile(
+            icon: Icons.format_list_numbered,
+            title: 'Line Numbers',
+            value: settings.showLineNumbers,
+            onChanged: (value) {
+              onSettingsChanged(settings.copyWith(showLineNumbers: value));
+            },
+          ),
+
+          ToggleTile(
+            icon: Icons.map_outlined,
+            title: 'Minimap',
+            value: settings.showMinimap,
+            onChanged: (value) {
+              onSettingsChanged(settings.copyWith(showMinimap: value));
+            },
+          ),
+
+          ToggleTile(
+            icon: settings.readOnly ? Icons.edit_off : Icons.edit,
+            title: 'Edit Mode',
+            value: !settings.readOnly,
+            onChanged: (isEditable) {
+              onSettingsChanged(settings.copyWith(readOnly: !isEditable));
+            },
+          ),
+
+          const SizedBox(height: 20),
+
+          // Theme Quick Select
+          _buildThemeSection(context),
+
+          const SizedBox(height: 24),
+
+          // Action Buttons
+          FilledButton.icon(
+            icon: const Icon(Icons.settings, size: 18),
+            label: const Text('All Settings'),
+            onPressed: onShowAllSettings,
+            style: FilledButton.styleFrom(
+              minimumSize: const Size(double.infinity, 40),
+            ),
+          ),
+
+          const SizedBox(height: 12),
+
+          OutlinedButton.icon(
+            icon: const Icon(Icons.copy, size: 18),
+            label: const Text('Copy Content'),
+            onPressed: selectionState.combinedContent.isNotEmpty
+                ? onCopyContent
+                : null,
+            style: OutlinedButton.styleFrom(
+              minimumSize: const Size(double.infinity, 40),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildHeader(BuildContext context) {
+    return Row(
+      children: [
+        Icon(
+          Icons.tune,
+          size: 20,
+          color: context.primary,
+        ),
+        const SizedBox(width: 8),
+        Text(
+          'Quick Settings',
+          style: context.titleSmall?.copyWith(
+            fontWeight: FontWeight.w600,
+          ),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildThemeSection(BuildContext context) {
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Row(
+          children: [
+            Icon(
+              Icons.palette_outlined,
+              size: 16,
+              color: context.onSurfaceVariant,
+            ),
+            const SizedBox(width: 8),
+            const SectionTitle(title: 'Theme'),
+          ],
+        ),
+        const SizedBox(height: 8),
+        ThemeDropdown(
+          currentTheme: settings.theme,
+          onThemeChanged: (theme) {
+            onSettingsChanged(settings.copyWith(theme: theme));
+          },
+        ),
+      ],
+    );
+  }
+}
+
+/// Section title widget
+class SectionTitle extends StatelessWidget {
+  const SectionTitle({
+    required this.title,
+    super.key,
+  });
+
+  final String title;
+
+  @override
+  Widget build(BuildContext context) {
+    return Text(
+      title,
+      style: context.labelMedium?.copyWith(
+        fontWeight: FontWeight.w600,
+        color: context.onSurfaceVariant,
+      ),
+    );
+  }
+}
+
+/// File count badge widget
+class FileCountBadge extends StatelessWidget {
+  const FileCountBadge({
+    required this.count,
+    super.key,
+  });
+
+  final int count;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: const EdgeInsets.symmetric(
+        horizontal: 12,
+        vertical: 8,
+      ),
+      decoration: BoxDecoration(
+        color: context.primary.addOpacity(0.1),
+        borderRadius: BorderRadius.circular(8),
+        border: Border.all(
+          color: context.primary.addOpacity(0.3),
+        ),
+      ),
+      child: Row(
+        children: [
+          Icon(
+            Icons.description_outlined,
+            size: 16,
+            color: context.primary,
+          ),
+          const SizedBox(width: 8),
+          Text(
+            '$count files selected',
+            style: context.labelMedium?.copyWith(
+              color: context.primary,
+              fontWeight: FontWeight.w500,
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+}
+
+/// Theme dropdown widget
+class ThemeDropdown extends StatelessWidget {
+  const ThemeDropdown({
+    required this.currentTheme,
+    required this.onThemeChanged,
+    super.key,
+  });
+
+  final String currentTheme;
+  final ValueChanged<String> onThemeChanged;
+
+  @override
+  Widget build(BuildContext context) {
+    return Theme(
+      data: Theme.of(context).copyWith(
+        popupMenuTheme: PopupMenuThemeData(
+          color: context.surface,
+          elevation: 8,
+          shape: RoundedRectangleBorder(
+            borderRadius: BorderRadius.circular(8),
+          ),
+        ),
+      ),
+      child: Container(
+        decoration: BoxDecoration(
+          color: context.surface,
+          borderRadius: BorderRadius.circular(8),
+        ),
+        child: DropdownButtonHideUnderline(
+          child: DropdownButton<String>(
+            isExpanded: true,
+            value: currentTheme,
+            padding: const EdgeInsets.symmetric(
+              horizontal: 12,
+              vertical: 4,
+            ),
+            borderRadius: BorderRadius.circular(8),
+            dropdownColor: context.surface,
+            menuMaxHeight: 300,
+            items: EditorConstants.themeNames.entries
+                .map(
+                  (entry) => DropdownMenuItem(
+                    value: entry.key,
+                    child: Text(
+                      entry.value,
+                      style: context.bodyMedium,
+                    ),
+                  ),
+                )
+                .toList(),
+            onChanged: (value) {
+              if (value != null) {
+                onThemeChanged(value);
+              }
+            },
+          ),
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/quick_sidebar/quick_sidebar_widgets.dart b/lib/src/features/editor/ui/widgets/quick_sidebar/quick_sidebar_widgets.dart
new file mode 100644
index 0000000..f250a88
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/quick_sidebar/quick_sidebar_widgets.dart
@@ -0,0 +1,4 @@
+// Barrel export for quick sidebar widgets
+export 'font_size_control.dart';
+export 'quick_sidebar.dart';
+export 'toggle_tile.dart';
diff --git a/lib/src/features/editor/ui/widgets/quick_sidebar/toggle_tile.dart b/lib/src/features/editor/ui/widgets/quick_sidebar/toggle_tile.dart
new file mode 100644
index 0000000..7ff8d76
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/quick_sidebar/toggle_tile.dart
@@ -0,0 +1,38 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+
+/// Reusable toggle tile widget for settings
+class ToggleTile extends StatelessWidget {
+  const ToggleTile({
+    required this.icon,
+    required this.title,
+    required this.value,
+    required this.onChanged,
+    super.key,
+  });
+
+  final IconData icon;
+  final String title;
+  final bool value;
+  final ValueChanged<bool> onChanged;
+
+  @override
+  Widget build(BuildContext context) {
+    return Padding(
+      padding: const EdgeInsets.only(bottom: DesignSystem.space8),
+      child: DsTile(
+        leading: Icon(
+          icon,
+          size: DesignSystem.iconSizeSmall + 2,
+          color: value ? context.primary : context.onSurfaceVariant,
+        ),
+        title: Text(title),
+        trailing: DsSwitch(
+          value: value,
+          onChanged: onChanged,
+        ),
+        onTap: () => onChanged(!value),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/settings/form_fields.dart b/lib/src/features/editor/ui/widgets/settings/form_fields.dart
new file mode 100644
index 0000000..5bd4164
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/settings/form_fields.dart
@@ -0,0 +1,166 @@
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+
+/// Reusable switch tile for settings
+class SettingsSwitchTile extends StatelessWidget {
+  const SettingsSwitchTile({
+    required this.title,
+    required this.value,
+    required this.onChanged,
+    super.key,
+    this.subtitle,
+    this.activeColor,
+  });
+
+  final String title;
+  final String? subtitle;
+  final bool value;
+  final ValueChanged<bool> onChanged;
+  final Color? activeColor;
+
+  @override
+  Widget build(BuildContext context) {
+    return SwitchListTile(
+      title: Text(title),
+      subtitle: subtitle != null ? Text(subtitle!) : null,
+      value: value,
+      onChanged: onChanged,
+      activeColor: activeColor ?? Theme.of(context).colorScheme.primary,
+    );
+  }
+}
+
+/// Reusable number field for settings
+class SettingsNumberField extends StatelessWidget {
+  const SettingsNumberField({
+    required this.label,
+    required this.controller,
+    required this.onChanged,
+    super.key,
+    this.min,
+    this.max,
+    this.decimals = 0,
+    this.suffix,
+    this.helperText,
+  });
+
+  final String label;
+  final TextEditingController controller;
+  final ValueChanged<double?> onChanged;
+  final double? min;
+  final double? max;
+  final int decimals;
+  final String? suffix;
+  final String? helperText;
+
+  @override
+  Widget build(BuildContext context) {
+    return TextFormField(
+      controller: controller,
+      decoration: InputDecoration(
+        labelText: label,
+        helperText: helperText,
+        suffix: suffix != null ? Text(suffix!) : null,
+        border: const OutlineInputBorder(),
+      ),
+      keyboardType: TextInputType.numberWithOptions(decimal: decimals > 0),
+      inputFormatters: [
+        if (decimals > 0)
+          FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d*'))
+        else
+          FilteringTextInputFormatter.digitsOnly,
+      ],
+      onChanged: (value) {
+        final parsed = double.tryParse(value);
+        if (parsed != null) {
+          if (min != null && parsed < min!) {
+            controller.text = min!.toString();
+            onChanged(min);
+          } else if (max != null && parsed > max!) {
+            controller.text = max!.toString();
+            onChanged(max);
+          } else {
+            onChanged(parsed);
+          }
+        } else {
+          onChanged(null);
+        }
+      },
+    );
+  }
+}
+
+/// Reusable dropdown field for settings
+class SettingsDropdownField<T> extends StatelessWidget {
+  const SettingsDropdownField({
+    required this.label,
+    required this.value,
+    required this.items,
+    required this.onChanged,
+    super.key,
+    this.itemBuilder,
+    this.helperText,
+  });
+
+  final String label;
+  final T value;
+  final List<T> items;
+  final ValueChanged<T?> onChanged;
+  final String Function(T)? itemBuilder;
+  final String? helperText;
+
+  @override
+  Widget build(BuildContext context) {
+    return DropdownButtonFormField<T>(
+      decoration: InputDecoration(
+        labelText: label,
+        helperText: helperText,
+        border: const OutlineInputBorder(),
+      ),
+      value: value,
+      items: items.map((item) {
+        return DropdownMenuItem<T>(
+          value: item,
+          child: Text(itemBuilder?.call(item) ?? item.toString()),
+        );
+      }).toList(),
+      onChanged: onChanged,
+    );
+  }
+}
+
+/// Reusable section header for settings
+class SettingsSectionHeader extends StatelessWidget {
+  const SettingsSectionHeader({
+    required this.title,
+    super.key,
+    this.subtitle,
+  });
+
+  final String title;
+  final String? subtitle;
+
+  @override
+  Widget build(BuildContext context) {
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        Text(
+          title,
+          style: Theme.of(context).textTheme.titleMedium?.copyWith(
+            fontWeight: FontWeight.w600,
+          ),
+        ),
+        if (subtitle != null) ...[
+          const SizedBox(height: 4),
+          Text(
+            subtitle!,
+            style: Theme.of(context).textTheme.bodySmall?.copyWith(
+              color: Theme.of(context).colorScheme.onSurfaceVariant,
+            ),
+          ),
+        ],
+      ],
+    );
+  }
+}
diff --git a/lib/src/features/editor/ui/widgets/settings/settings_widgets.dart b/lib/src/features/editor/ui/widgets/settings/settings_widgets.dart
new file mode 100644
index 0000000..d099d30
--- /dev/null
+++ b/lib/src/features/editor/ui/widgets/settings/settings_widgets.dart
@@ -0,0 +1,2 @@
+// Export all settings widgets
+export 'form_fields.dart';
diff --git a/lib/src/features/editor/utils/webview_debug_helper.dart b/lib/src/features/editor/utils/webview_debug_helper.dart
deleted file mode 100644
index 09c51fc..0000000
--- a/lib/src/features/editor/utils/webview_debug_helper.dart
+++ /dev/null
@@ -1,135 +0,0 @@
-// lib/src/features/editor/utils/webview_debug_helper.dart
-import 'dart:io';
-
-import 'package:flutter/foundation.dart';
-import 'package:webview_windows/webview_windows.dart';
-
-/// Debug helper for WebView issues
-class WebViewDebugHelper {
-  /// Test basic WebView2 functionality
-  static Future<void> testWebView2Basic() async {
-    if (!Platform.isWindows) {
-      debugPrint('[WebViewDebugHelper] Not on Windows, skipping test');
-      return;
-    }
-
-    debugPrint('[WebViewDebugHelper] Testing basic WebView2...');
-
-    try {
-      // Check version
-      final version = await WebviewController.getWebViewVersion();
-      debugPrint('[WebViewDebugHelper] WebView2 Version: $version');
-
-      // Create a test controller
-      final controller = WebviewController();
-      await controller.initialize();
-
-      // Load simple HTML
-      await controller.loadStringContent('''
-        <!DOCTYPE html>
-        <html>
-        <body>
-          <h1>WebView2 Test</h1>
-          <p>If you see this, WebView2 is working!</p>
-          <script>
-            console.log('WebView2 JavaScript is working!');
-          </script>
-        </body>
-        </html>
-      ''');
-
-      debugPrint('[WebViewDebugHelper] Basic test completed successfully');
-
-      // Clean up
-      await controller.dispose();
-    } catch (e) {
-      debugPrint('[WebViewDebugHelper] Basic test failed: $e');
-    }
-  }
-
-  /// Test Monaco loading
-  static Future<void> testMonacoLoading(String assetPath) async {
-    debugPrint('[WebViewDebugHelper] Testing Monaco loading...');
-    debugPrint('[WebViewDebugHelper] Asset path: $assetPath');
-
-    // Check if VS directory exists
-    final vsDir = Directory('$assetPath/monaco-editor/min/vs');
-    if (!vsDir.existsSync()) {
-      debugPrint(
-          '[WebViewDebugHelper] ERROR: VS directory not found at: ${vsDir.path}');
-      return;
-    }
-
-    debugPrint('[WebViewDebugHelper] VS directory exists');
-
-    // Check essential files
-    final essentialFiles = [
-      'loader.js',
-      'editor/editor.main.js',
-      'editor/editor.main.css',
-    ];
-
-    for (final file in essentialFiles) {
-      final filePath = '${vsDir.path}/$file';
-      final fileObj = File(filePath);
-
-      if (fileObj.existsSync()) {
-        final size = await fileObj.length();
-        debugPrint('[WebViewDebugHelper] ‚úì $file ($size bytes)');
-      } else {
-        debugPrint('[WebViewDebugHelper] ‚úó $file NOT FOUND');
-      }
-    }
-  }
-
-  /// Test file:/// URL access
-  static Future<void> testFileUrlAccess(String assetPath) async {
-    if (!Platform.isWindows) {
-      debugPrint('[WebViewDebugHelper] Not on Windows, skipping test');
-      return;
-    }
-
-    debugPrint('[WebViewDebugHelper] Testing file:/// URL access...');
-
-    try {
-      final controller = WebviewController();
-      await controller.initialize();
-
-      // Try loading a file URL
-      final testFile = File('$assetPath/monaco-editor/min/vs/loader.js');
-      if (!testFile.existsSync()) {
-        debugPrint('[WebViewDebugHelper] Test file not found');
-        return;
-      }
-
-      final fileUrl = 'file:///${testFile.path.replaceAll(r'\', '/')}';
-      debugPrint('[WebViewDebugHelper] Testing URL: $fileUrl');
-
-      await controller.loadUrl(fileUrl);
-
-      debugPrint('[WebViewDebugHelper] File URL loaded successfully');
-
-      await controller.dispose();
-    } catch (e) {
-      debugPrint('[WebViewDebugHelper] File URL test failed: $e');
-    }
-  }
-
-  /// Get current editor state summary
-  static Map<String, dynamic> getEditorStateSummary({
-    required String editorState,
-    required bool isVisible,
-    required bool hasContent,
-    required double progress,
-    String? error,
-  }) {
-    return {
-      'state': editorState,
-      'isVisible': isVisible,
-      'hasContent': hasContent,
-      'progress': '${(progress * 100).toInt()}%',
-      'error': error,
-      'timestamp': DateTime.now().toIso8601String(),
-    };
-  }
-}
diff --git a/lib/src/features/merge/merge.dart b/lib/src/features/merge/merge.dart
deleted file mode 100644
index d1dcb6d..0000000
--- a/lib/src/features/merge/merge.dart
+++ /dev/null
@@ -1,2 +0,0 @@
-// Merge feature exports
-export 'three_way_merger.dart';
diff --git a/lib/src/features/merge/three_way_merger.dart b/lib/src/features/merge/three_way_merger.dart
deleted file mode 100644
index 4046554..0000000
--- a/lib/src/features/merge/three_way_merger.dart
+++ /dev/null
@@ -1,62 +0,0 @@
-import 'dart:isolate';
-
-import 'package:diff_match_patch/diff_match_patch.dart';
-
-class ThreeWayMerger {
-  factory ThreeWayMerger() => _instance;
-  ThreeWayMerger._internal();
-  static final _instance = ThreeWayMerger._internal();
-
-  final _dmp = DiffMatchPatch(); // OO wrapper
-
-  Future<(String, bool)> merge({
-    required String base,
-    required String local,
-    required String remote,
-  }) async {
-    // fast outs
-    if (base == local) return (remote, false);
-    if (base == remote) return (local, false);
-    if (local == remote) return (local, false);
-
-    base = base.replaceAll('\r\n', '\n');
-    local = local.replaceAll('\r\n', '\n');
-    remote = remote.replaceAll('\r\n', '\n');
-
-    // Run in isolate for large files, otherwise run directly
-    if ([base, local, remote].any((t) => t.length > 300000)) {
-      return Isolate.run<(String, bool)>(
-        () => _inner(base, local, remote),
-      );
-    } else {
-      return _inner(base, local, remote);
-    }
-  }
-
-  Future<bool> wouldHaveConflicts({
-    required String base,
-    required String local,
-    required String remote,
-  }) async =>
-      (await merge(base: base, local: local, remote: remote)).$2;
-
-  // ------------------------------------------------------------------
-
-  (String, bool) _inner(String base, String local, String remote) {
-    try {
-      final localPatches = _dmp.patch(base, local); // <-- wrapper call
-      final localApplied = _dmp.patch_apply(localPatches, base);
-      var merged = localApplied[0] as String;
-
-      final remotePatches = _dmp.patch(base, remote); // <-- wrapper call
-      final remoteApplied = _dmp.patch_apply(remotePatches, merged);
-      merged = remoteApplied[0] as String;
-      final hadConflicts = (remoteApplied[1] as List<bool>).contains(false);
-
-      return (merged, hadConflicts);
-    } catch (_) {
-      // any unexpected failure ‚áí keep user text, flag conflict
-      return (local, true);
-    }
-  }
-}
diff --git a/lib/src/features/scan/data/content_assembler.dart b/lib/src/features/scan/data/content_assembler.dart
deleted file mode 100644
index f38931c..0000000
--- a/lib/src/features/scan/data/content_assembler.dart
+++ /dev/null
@@ -1,133 +0,0 @@
-import 'package:context_collector/src/features/scan/domain/scanned_file.dart';
-import 'package:context_collector/src/shared/utils/language_mapper.dart';
-
-/// Service responsible for assembling content from multiple files into a combined format
-/// This separates disk I/O concerns from UI state management
-class ContentAssembler {
-  /// Build a combined markdown-formatted string from selected files
-  Future<String> buildMerged(List<ScannedFile> selectedFiles) async {
-    final buffer = StringBuffer()
-      ..writeln('# Context Collection')
-      ..writeln();
-
-    // Sort files by path for better organization
-    final sortedFiles = List<ScannedFile>.from(selectedFiles)
-      ..sort((a, b) => a.fullPath.compareTo(b.fullPath));
-
-    for (final file in sortedFiles) {
-      // Get the language identifier for syntax highlighting
-      final language = LanguageMapper.getLanguageForFile(file.fullPath);
-
-      buffer
-        ..writeln('## ${file.name}')
-        ..writeln(file.generateReference())
-        ..writeln();
-
-      if (file.content != null) {
-        // Add code block with language identifier for syntax highlighting
-        buffer
-          ..writeln('```$language')
-          ..writeln(file.content)
-          ..writeln('```')
-          ..writeln('\n---\n');
-      } else if (file.error != null) {
-        buffer.writeln('```\nERROR: ${file.error}\n```');
-      } else {
-        buffer.writeln('```\nPENDING: Content not loaded\n```');
-      }
-
-      buffer
-        ..writeln()
-        ..writeln();
-    }
-
-    // Clean up excessive whitespace before returning
-    return _cleanupWhitespace(buffer.toString());
-  }
-
-  /// Remove multiple consecutive empty lines and replace with single empty line
-  String _cleanupWhitespace(String content) {
-    // Replace 3 or more consecutive newlines with just 2 newlines (1 empty line)
-    return content
-        // First, normalize different line endings to \n
-        .replaceAll('\r\n', '\n')
-        .replaceAll('\r', '\n')
-        // Remove multiple consecutive empty lines (3+ newlines become 2)
-        .replaceAll(RegExp(r'\n{3,}'), '\n\n')
-        // Clean up any trailing whitespace at the end of lines
-        .replaceAll(RegExp(r'[ \t]+$', multiLine: true), '')
-        // Remove excessive whitespace at the very end of the document
-        .replaceAll(RegExp(r'\n+$'), '\n');
-  }
-
-  /// Get content statistics
-  ContentStats getStats(List<ScannedFile> files) {
-    var totalSize = 0;
-    var totalLines = 0;
-    var totalCharacters = 0;
-    var loadedFiles = 0;
-    var errorFiles = 0;
-
-    for (final file in files) {
-      totalSize += file.size;
-
-      if (file.content != null) {
-        loadedFiles++;
-        totalLines += file.content!.split('\n').length;
-        totalCharacters += file.content!.length;
-      } else if (file.error != null) {
-        errorFiles++;
-      }
-    }
-
-    return ContentStats(
-      totalFiles: files.length,
-      loadedFiles: loadedFiles,
-      errorFiles: errorFiles,
-      pendingFiles: files.length - loadedFiles - errorFiles,
-      totalSize: totalSize,
-      totalLines: totalLines,
-      totalCharacters: totalCharacters,
-    );
-  }
-}
-
-/// Statistics about content collection
-class ContentStats {
-  const ContentStats({
-    required this.totalFiles,
-    required this.loadedFiles,
-    required this.errorFiles,
-    required this.pendingFiles,
-    required this.totalSize,
-    required this.totalLines,
-    required this.totalCharacters,
-  });
-
-  final int totalFiles;
-  final int loadedFiles;
-  final int errorFiles;
-  final int pendingFiles;
-  final int totalSize;
-  final int totalLines;
-  final int totalCharacters;
-
-  String get formattedSize {
-    if (totalSize < 1024) return '${totalSize}B';
-    if (totalSize < 1024 * 1024) {
-      return '${(totalSize / 1024).toStringAsFixed(1)}KB';
-    }
-    if (totalSize < 1024 * 1024 * 1024) {
-      return '${(totalSize / (1024 * 1024)).toStringAsFixed(1)}MB';
-    }
-    return '${(totalSize / (1024 * 1024 * 1024)).toStringAsFixed(1)}GB';
-  }
-
-  String get formattedCharacters {
-    if (totalCharacters < 1000) return totalCharacters.toString();
-    if (totalCharacters < 1000000) {
-      return '${(totalCharacters / 1000).toStringAsFixed(1)}K';
-    }
-    return '${(totalCharacters / 1000000).toStringAsFixed(1)}M';
-  }
-}
diff --git a/lib/src/features/scan/data/file_scanner.dart b/lib/src/features/scan/data/file_scanner.dart
deleted file mode 100644
index 52b5bf9..0000000
--- a/lib/src/features/scan/data/file_scanner.dart
+++ /dev/null
@@ -1,131 +0,0 @@
-import 'dart:io';
-
-import 'package:context_collector/src/features/scan/domain/scanned_file.dart';
-import 'package:context_collector/src/shared/utils/drop_file_resolver.dart';
-import 'package:context_collector/src/shared/utils/extension_catalog.dart';
-import 'package:path/path.dart' as path;
-
-/// Service responsible for scanning directories and finding supported files
-class FileScanner {
-  /// Scan a directory for supported files
-  Future<List<ScannedFile>> scanDirectory(
-    String directoryPath,
-    Map<String, FileCategory> supportedExtensions,
-  ) async {
-    final directory = Directory(directoryPath);
-    if (!directory.existsSync()) {
-      throw FileSystemException('Directory not found: $directoryPath');
-    }
-
-    final foundFiles = <ScannedFile>[];
-
-    await for (final entity
-        in directory.list(recursive: true, followLinks: false)) {
-      if (entity is File) {
-        var extension = path.extension(entity.path).toLowerCase();
-
-        // For temporary drop files without extensions, try to resolve the actual extension
-        if (extension.isEmpty &&
-            DropFileResolver.isTemporaryDropFile(entity.path)) {
-          final fileInfo = DropFileResolver.resolveFileInfo(entity.path);
-          extension = fileInfo['extension'] ?? '';
-        }
-
-        // Include files with supported extensions OR files without extensions
-        // (which might be text files from desktop_drop temporary directory)
-        // Skip hidden files that start with a dot (like .DS_Store)
-        final fileName = path.basename(entity.path);
-        final isHiddenFile = fileName.startsWith('.') && extension.isEmpty;
-
-        if (supportedExtensions.containsKey(extension) ||
-            (extension.isEmpty && !isHiddenFile)) {
-          try {
-            final scannedFile = ScannedFile.fromFile(entity);
-            foundFiles.add(scannedFile);
-          } catch (e) {
-            // Skip files that can't be accessed
-            continue;
-          }
-        }
-      }
-    }
-
-    return foundFiles;
-  }
-
-  /// Load content for a single file
-  Future<ScannedFile> loadFileContent(
-    ScannedFile file,
-    Map<String, FileCategory> supportedExtensions,
-  ) async {
-    // Special handling for files without extensions (e.g., from desktop_drop temporary files)
-    if (file.extension.isEmpty) {
-      try {
-        final fileEntity = File(file.fullPath);
-        if (!fileEntity.existsSync()) {
-          return file.copyWith(error: 'File not found');
-        }
-
-        // For temporary drop files, try to resolve the actual extension
-        String? resolvedExtension;
-        if (DropFileResolver.isTemporaryDropFile(file.fullPath)) {
-          final fileInfo = DropFileResolver.resolveFileInfo(file.fullPath);
-          resolvedExtension = fileInfo['extension'];
-
-          // If we resolved an extension, check if it's supported
-          if (resolvedExtension != null && resolvedExtension.isNotEmpty) {
-            if (!supportedExtensions.containsKey(resolvedExtension)) {
-              return file.copyWith(
-                error: 'Resolved file type $resolvedExtension is not supported',
-              );
-            }
-          }
-        }
-
-        // Try to read as text - if it's a text file, it should work
-        final content = await fileEntity.readAsString();
-        // If we successfully read it as text, return with content
-        return file.copyWith(content: content);
-      } catch (e) {
-        return file.copyWith(
-          error: 'Cannot read file: possibly binary or unsupported format',
-        );
-      }
-    }
-
-    if (!file.supportsText(supportedExtensions)) {
-      return file.copyWith(
-        error: 'File type not supported for text extraction',
-      );
-    }
-
-    try {
-      final fileEntity = File(file.fullPath);
-      if (!fileEntity.existsSync()) {
-        return file.copyWith(error: 'File not found');
-      }
-
-      final content = await fileEntity.readAsString();
-      return file.copyWith(content: content);
-    } catch (e) {
-      return file.copyWith(
-        error: 'Error reading file: $e',
-      );
-    }
-  }
-
-  /// Load content for multiple files
-  Future<List<ScannedFile>> loadMultipleFileContents(
-    List<ScannedFile> files,
-    Map<String, FileCategory> supportedExtensions,
-  ) async {
-    final results = <ScannedFile>[];
-
-    for (final file in files) {
-      final result = await loadFileContent(file, supportedExtensions);
-      results.add(result);
-    }
-
-    return results;
-  }
-}
diff --git a/lib/src/features/scan/domain/scanned_file.dart b/lib/src/features/scan/domain/scanned_file.dart
deleted file mode 100644
index da466f5..0000000
--- a/lib/src/features/scan/domain/scanned_file.dart
+++ /dev/null
@@ -1,131 +0,0 @@
-import 'dart:io';
-
-import 'package:context_collector/src/shared/utils/extension_catalog.dart';
-import 'package:context_collector/src/shared/utils/language_mapper.dart';
-import 'package:flutter/foundation.dart';
-import 'package:path/path.dart' as path;
-
-/// Represents a file that has been scanned from the filesystem
-/// This is an immutable value object that only holds data
-@immutable
-class ScannedFile {
-  const ScannedFile({
-    required this.name,
-    required this.fullPath,
-    required this.extension,
-    required this.size,
-    required this.lastModified,
-    this.content,
-    this.error,
-    this.displayPath,
-  });
-
-  /// Create a ScannedFile from a File system object
-  factory ScannedFile.fromFile(File file) {
-    final stat = file.statSync();
-    final filePath = file.path;
-    final fileName = path.basename(filePath);
-
-    // For VS Code temp files, use just the filename as display path
-    String? displayPath;
-    if (filePath.contains('/tmp/Drops/')) {
-      displayPath = fileName;
-    }
-
-    return ScannedFile(
-      name: fileName,
-      fullPath: filePath,
-      extension: path.extension(filePath).toLowerCase(),
-      size: stat.size,
-      lastModified: stat.modified,
-      displayPath: displayPath,
-    );
-  }
-
-  final String name;
-  final String fullPath;
-  final String extension;
-  final int size;
-  final DateTime lastModified;
-  final String? content;
-  final String? error;
-
-  /// Optional display path (for VS Code drops where the temp path isn't meaningful)
-  final String? displayPath;
-
-  /// Check if this file was dropped from VS Code (temporary file)
-  bool get isVSCodeDrop => fullPath.contains('/tmp/Drops/');
-
-  /// Human-readable file size
-  String get sizeFormatted {
-    if (size < 1024) return '${size}B';
-    if (size < 1024 * 1024) return '${(size / 1024).toStringAsFixed(1)}KB';
-    if (size < 1024 * 1024 * 1024) {
-      return '${(size / (1024 * 1024)).toStringAsFixed(1)}MB';
-    }
-    return '${(size / (1024 * 1024 * 1024)).toStringAsFixed(1)}GB';
-  }
-
-  /// Check if this file supports text extraction
-  bool supportsText([Map<String, FileCategory>? customExtensions]) {
-    return supportsTextHelper(extension, customExtensions);
-  }
-
-  /// Get the category for this file
-  FileCategory? getCategory([Map<String, FileCategory>? customExtensions]) {
-    return getExtensionCategory(extension, customExtensions);
-  }
-
-  /// Get the language identifier for syntax highlighting
-  String get language {
-    return LanguageMapper.getLanguageForFile(fullPath);
-  }
-
-  /// Get the line count of the file content
-  int get lineCount {
-    if (content == null) return 0;
-    return content!.split('\n').length;
-  }
-
-  /// Generate metadata reference for the combined content
-  String generateReference() {
-    // Use display path if available (for VS Code drops)
-    final pathToShow = displayPath ?? fullPath;
-    return '> **Path:** $pathToShow  \n';
-  }
-
-  /// Create a copy with updated fields
-  ScannedFile copyWith({
-    String? name,
-    String? fullPath,
-    String? extension,
-    int? size,
-    DateTime? lastModified,
-    String? content,
-    String? error,
-    String? displayPath,
-  }) {
-    return ScannedFile(
-      name: name ?? this.name,
-      fullPath: fullPath ?? this.fullPath,
-      extension: extension ?? this.extension,
-      size: size ?? this.size,
-      lastModified: lastModified ?? this.lastModified,
-      content: content ?? this.content,
-      error: error ?? this.error,
-      displayPath: displayPath ?? this.displayPath,
-    );
-  }
-
-  @override
-  bool operator ==(Object other) {
-    if (identical(this, other)) return true;
-    return other is ScannedFile && other.fullPath == fullPath;
-  }
-
-  @override
-  int get hashCode => fullPath.hashCode;
-
-  @override
-  String toString() => 'ScannedFile(path: $fullPath, size: $sizeFormatted)';
-}
diff --git a/lib/src/features/scan/models/file_category.dart b/lib/src/features/scan/models/file_category.dart
new file mode 100644
index 0000000..a692622
--- /dev/null
+++ b/lib/src/features/scan/models/file_category.dart
@@ -0,0 +1,19 @@
+import 'package:flutter/material.dart';
+
+/// Minimal FileCategory enum to support settings
+/// In the simplified scan feature, we don't actually filter by extensions
+enum FileCategory {
+  programming('Programming Languages', Icons.code),
+  web('Web Technologies', Icons.web),
+  data('Data & Config', Icons.data_object),
+  script('Scripts', Icons.terminal),
+  documentation('Documentation', Icons.description),
+  database('Database', Icons.storage),
+  devops('DevOps & Build', Icons.build_circle),
+  other('Other', Icons.insert_drive_file);
+
+  const FileCategory(this.displayName, this.icon);
+
+  final String displayName;
+  final IconData icon;
+}
diff --git a/lib/src/features/scan/models/scan_result.dart b/lib/src/features/scan/models/scan_result.dart
new file mode 100644
index 0000000..4181065
--- /dev/null
+++ b/lib/src/features/scan/models/scan_result.dart
@@ -0,0 +1,29 @@
+import 'package:flutter/foundation.dart';
+import 'scanned_file.dart';
+
+/// Represents the source of a scan operation
+enum ScanSource { drop, browse, paste, manual }
+
+/// Metadata about a scan operation
+@immutable
+class ScanMetadata {
+  const ScanMetadata({
+    required this.sourcePaths,
+    required this.timestamp,
+    required this.source,
+  });
+  final List<String> sourcePaths;
+  final DateTime timestamp;
+  final ScanSource source;
+}
+
+/// Result of a scan operation, containing files and metadata
+@immutable
+class ScanResult {
+  const ScanResult({
+    required this.files,
+    required this.metadata,
+  });
+  final List<ScannedFile> files;
+  final ScanMetadata metadata;
+}
diff --git a/lib/src/features/scan/models/scanned_file.dart b/lib/src/features/scan/models/scanned_file.dart
new file mode 100644
index 0000000..cabcf0a
--- /dev/null
+++ b/lib/src/features/scan/models/scanned_file.dart
@@ -0,0 +1,128 @@
+import 'dart:io';
+
+import 'package:flutter/foundation.dart';
+import 'package:path/path.dart' as path;
+
+import 'scan_result.dart';
+
+/// Simplified ScannedFile model - same API, cleaner implementation
+@immutable
+class ScannedFile {
+  const ScannedFile({
+    required this.id,
+    required this.name,
+    required this.fullPath,
+    required this.extension,
+    required this.size,
+    required this.lastModified,
+    required this.source,
+    required this.isVirtual,
+    this.relativePath,
+    this.content,
+    this.virtualContent,
+    this.editedContent,
+    this.error,
+    this.displayPath,
+  });
+
+  factory ScannedFile.fromFile(
+    File file, {
+    String? relativePath,
+    ScanSource source = ScanSource.browse,
+  }) {
+    final filePath = file.path;
+    final fileName = path.basename(filePath);
+    final stat = file.statSync();
+
+    // VS Code temp file handling - simplified
+    final displayPath = filePath.contains('/tmp/Drops/') ? fileName : null;
+
+    // Generate deterministic ID based on the normalized full path
+    // This ensures the same file always gets the same ID
+    final normalizedPath = path.normalize(filePath);
+    final id =
+        'file_${normalizedPath.hashCode.toUnsigned(32).toRadixString(16)}_${stat.size}';
+
+    return ScannedFile(
+      id: id,
+      name: fileName,
+      fullPath: filePath,
+      extension: path.extension(filePath).toLowerCase(),
+      size: stat.size,
+      lastModified: stat.modified,
+      source: source,
+      isVirtual: false,
+      relativePath: relativePath,
+      displayPath: displayPath,
+    );
+  }
+
+  final String id;
+  final String name;
+  final String fullPath;
+  final String extension;
+  final int size;
+  final DateTime lastModified;
+  final ScanSource source;
+  final bool isVirtual;
+  final String? relativePath;
+  final String? content;
+  final String? virtualContent;
+  final String? editedContent;
+  final String? error;
+  final String? displayPath;
+
+  /// Computed properties
+  bool get isDirty => editedContent != null && editedContent != content;
+  String get effectiveContent =>
+      editedContent ?? virtualContent ?? content ?? '';
+
+  /// Simplified text support check - just try to read it
+  bool get supportsText => true; // We'll try to read any file as text
+
+  /// Generate reference for markdown
+  String generateReference() {
+    return '> **Path:** $fullPath';
+  }
+
+  ScannedFile copyWith({
+    String? id,
+    String? name,
+    String? fullPath,
+    String? extension,
+    int? size,
+    DateTime? lastModified,
+    ScanSource? source,
+    bool? isVirtual,
+    String? relativePath,
+    String? content,
+    String? virtualContent,
+    String? editedContent,
+    String? error,
+    String? displayPath,
+  }) {
+    return ScannedFile(
+      id: id ?? this.id,
+      name: name ?? this.name,
+      fullPath: fullPath ?? this.fullPath,
+      extension: extension ?? this.extension,
+      size: size ?? this.size,
+      lastModified: lastModified ?? this.lastModified,
+      source: source ?? this.source,
+      isVirtual: isVirtual ?? this.isVirtual,
+      relativePath: relativePath ?? this.relativePath,
+      content: content ?? this.content,
+      virtualContent: virtualContent ?? this.virtualContent,
+      editedContent: editedContent ?? this.editedContent,
+      error: error ?? this.error,
+      displayPath: displayPath ?? this.displayPath,
+    );
+  }
+
+  @override
+  bool operator ==(Object other) =>
+      identical(this, other) || other is ScannedFile && other.id == id;
+
+  @override
+  int get hashCode => id.hashCode;
+}
diff --git a/lib/src/features/scan/presentation/state/selection_notifier.dart b/lib/src/features/scan/presentation/state/selection_notifier.dart
deleted file mode 100644
index 066d515..0000000
--- a/lib/src/features/scan/presentation/state/selection_notifier.dart
+++ /dev/null
@@ -1,377 +0,0 @@
-import 'dart:io';
-
-import 'package:context_collector/context_collector.dart';
-import 'package:file_selector/file_selector.dart';
-import 'package:flutter/foundation.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-// State class
-@immutable
-class SelectionState {
-  const SelectionState({
-    this.allFiles = const [],
-    this.selectedFilePaths = const {},
-    this.isProcessing = false,
-    this.error,
-    this.combinedContent = '',
-    this.supportedExtensions,
-  });
-  final List<ScannedFile> allFiles;
-  final Set<String> selectedFilePaths;
-  final bool isProcessing;
-  final String? error;
-  final String combinedContent;
-  final Map<String, FileCategory>? supportedExtensions;
-
-  SelectionState copyWith({
-    List<ScannedFile>? allFiles,
-    Set<String>? selectedFilePaths,
-    bool? isProcessing,
-    String? error,
-    bool clearError = false, // Special flag to clear error
-    String? combinedContent,
-    Map<String, FileCategory>? supportedExtensions,
-  }) {
-    return SelectionState(
-      allFiles: allFiles ?? this.allFiles,
-      selectedFilePaths: selectedFilePaths ?? this.selectedFilePaths,
-      isProcessing: isProcessing ?? this.isProcessing,
-      error: clearError ? null : error ?? this.error,
-      combinedContent: combinedContent ?? this.combinedContent,
-      supportedExtensions: supportedExtensions ?? this.supportedExtensions,
-    );
-  }
-
-  // Getters (derived state)
-  List<ScannedFile> get selectedFiles => allFiles
-      .where((file) => selectedFilePaths.contains(file.fullPath))
-      .toList();
-  int get selectedFilesCount => selectedFiles.length;
-  int get totalFilesCount => allFiles.length;
-  bool get hasFiles => allFiles.isNotEmpty;
-  bool get hasSelectedFiles => selectedFiles.isNotEmpty;
-}
-
-// Provider
-final selectionProvider =
-    StateNotifierProvider<SelectionNotifier, SelectionState>((ref) {
-  // If FileScanner and ContentAssembler were also Riverpod providers,
-  // we would use ref.watch or ref.read here.
-  // For now, we instantiate them directly as in the original Cubit.
-  return SelectionNotifier(
-    fileScanner: FileScanner(),
-    contentAssembler: ContentAssembler(),
-    ref:
-        ref, // Pass ref for potential future use (e.g., reading other providers)
-  );
-});
-
-// Notifier
-class SelectionNotifier extends StateNotifier<SelectionState> {
-  // Keep ref for potential future use
-
-  SelectionNotifier({
-    required FileScanner fileScanner,
-    required ContentAssembler contentAssembler,
-    required Ref ref,
-  })  : _fileScanner = fileScanner,
-        _contentAssembler = contentAssembler,
-        _ref = ref,
-        super(const SelectionState());
-  final FileScanner _fileScanner;
-  final ContentAssembler _contentAssembler;
-  // ignore: unused_field
-  final Ref _ref;
-
-  void setSupportedExtensions(Map<String, FileCategory> extensions) {
-    state = state.copyWith(supportedExtensions: extensions);
-    _updateCombinedContent();
-  }
-
-  Future<void> addFiles(List<String> filePaths) async {
-    var newFilesAdded = false;
-    final currentFiles = List<ScannedFile>.from(state.allFiles);
-    final currentSelectedPaths = Set<String>.from(state.selectedFilePaths);
-
-    for (final filePath in filePaths) {
-      final file = File(filePath);
-      if (file.existsSync()) {
-        final scannedFile = ScannedFile.fromFile(file);
-        if (!currentFiles.any((f) => f.fullPath == scannedFile.fullPath)) {
-          currentFiles.add(scannedFile);
-          currentSelectedPaths.add(scannedFile.fullPath);
-          newFilesAdded = true;
-        }
-      }
-    }
-
-    if (newFilesAdded) {
-      // First update state with new files (showing loading state)
-      state = state.copyWith(
-        allFiles: currentFiles,
-        selectedFilePaths: currentSelectedPaths,
-        clearError: true,
-        isProcessing: true, // Show processing state
-      );
-
-      // Load file contents (this will also update combined content and set isProcessing to false)
-      await loadFileContents();
-    } else {
-      state = state.copyWith(clearError: true); // Still clear error if any
-    }
-  }
-
-  Future<void> addDirectory(String directoryPath) async {
-    state = state.copyWith(isProcessing: true, clearError: true);
-    try {
-      final effectiveSupportedExtensions =
-          state.supportedExtensions ?? ExtensionCatalog.extensionCategories;
-      final foundFiles = await _fileScanner.scanDirectory(
-          directoryPath, effectiveSupportedExtensions);
-
-      var newFilesAdded = false;
-      final currentFiles = List<ScannedFile>.from(state.allFiles);
-      final currentSelectedPaths = Set<String>.from(state.selectedFilePaths);
-
-      for (final file in foundFiles) {
-        if (!currentFiles.any((f) => f.fullPath == file.fullPath)) {
-          currentFiles.add(file);
-          currentSelectedPaths.add(file.fullPath);
-          newFilesAdded = true;
-        }
-      }
-
-      state = state.copyWith(
-          allFiles: currentFiles, selectedFilePaths: currentSelectedPaths);
-      if (newFilesAdded) {
-        await _updateCombinedContent();
-        await loadFileContents();
-      }
-    } catch (e) {
-      state = state.copyWith(error: 'Error scanning directory: $e');
-    } finally {
-      state = state.copyWith(isProcessing: false);
-    }
-  }
-
-  void removeFile(ScannedFile file) {
-    final currentFiles = List<ScannedFile>.from(state.allFiles)
-      ..removeWhere((f) => f.fullPath == file.fullPath);
-    final currentSelectedPaths = Set<String>.from(state.selectedFilePaths)
-      ..remove(file.fullPath);
-    state = state.copyWith(
-        allFiles: currentFiles, selectedFilePaths: currentSelectedPaths);
-    _updateCombinedContent();
-  }
-
-  void clearFiles() {
-    state = state.copyWith(
-      allFiles: [],
-      selectedFilePaths: {},
-      combinedContent: '',
-      clearError: true,
-    );
-  }
-
-  void toggleFileSelection(ScannedFile file) {
-    final currentSelectedPaths = Set<String>.from(state.selectedFilePaths);
-    if (currentSelectedPaths.contains(file.fullPath)) {
-      currentSelectedPaths.remove(file.fullPath);
-    } else {
-      currentSelectedPaths.add(file.fullPath);
-    }
-    state = state.copyWith(selectedFilePaths: currentSelectedPaths);
-    _updateCombinedContent();
-  }
-
-  void selectAll() {
-    final allPaths = state.allFiles.map((f) => f.fullPath).toSet();
-    state = state.copyWith(selectedFilePaths: allPaths);
-    _updateCombinedContent();
-  }
-
-  void deselectAll() {
-    state = state.copyWith(selectedFilePaths: {});
-    _updateCombinedContent();
-  }
-
-  Future<void> loadFileContents() async {
-    final filesToLoad = state.selectedFiles
-        .where((f) => f.content == null && f.error == null)
-        .toList();
-
-    if (filesToLoad.isEmpty) return;
-
-    state = state.copyWith(isProcessing: true, clearError: true);
-    try {
-      final effectiveSupportedExtensions =
-          state.supportedExtensions ?? ExtensionCatalog.extensionCategories;
-
-      final currentFiles = List<ScannedFile>.from(state.allFiles);
-      var changed = false;
-
-      for (final file in filesToLoad) {
-        final index =
-            currentFiles.indexWhere((f) => f.fullPath == file.fullPath);
-        if (index != -1) {
-          final updatedFile = await _fileScanner.loadFileContent(
-              file, effectiveSupportedExtensions);
-          currentFiles[index] = updatedFile;
-          changed = true;
-        }
-      }
-      if (changed) {
-        state = state.copyWith(
-            allFiles: currentFiles); // Update state once after loop
-      }
-      await _updateCombinedContent(); // This will also update state with new combined content
-    } catch (e) {
-      state = state.copyWith(error: 'Error loading files: $e');
-    } finally {
-      state = state.copyWith(isProcessing: false);
-    }
-  }
-
-  Future<void> copyToClipboard() async {
-    var contentToCopy = state.combinedContent;
-    if (contentToCopy.isEmpty && state.hasSelectedFiles) {
-      state = state.copyWith(isProcessing: true);
-      await loadFileContents(); // This will update state.combinedContent via _updateCombinedContent
-      contentToCopy =
-          state.combinedContent; // Re-fetch potentially updated content
-      state = state.copyWith(isProcessing: false);
-    }
-    if (contentToCopy.isEmpty && !state.hasSelectedFiles) {
-      state = state.copyWith(error: 'No files selected to copy.');
-      return;
-    }
-
-    try {
-      await Clipboard.setData(ClipboardData(text: contentToCopy));
-    } catch (e) {
-      state = state.copyWith(error: 'Error copying to clipboard: $e');
-    }
-  }
-
-  Future<void> saveToFile() async {
-    var contentToSave = state.combinedContent;
-    if (contentToSave.isEmpty && state.hasSelectedFiles) {
-      state = state.copyWith(isProcessing: true);
-      await loadFileContents();
-      contentToSave = state.combinedContent;
-      state = state.copyWith(isProcessing: false);
-    }
-    if (contentToSave.isEmpty && !state.hasSelectedFiles) {
-      state = state.copyWith(error: 'No files selected to save.');
-      return;
-    }
-
-    try {
-      final fileName =
-          'context_collection_${DateTime.now().millisecondsSinceEpoch}.txt';
-      final filePath = await getSaveLocation(
-        suggestedName: fileName,
-        acceptedTypeGroups: [
-          const XTypeGroup(label: 'Text files', extensions: ['txt']),
-        ],
-      );
-
-      if (filePath != null) {
-        final file = File(filePath.path);
-        await file.writeAsString(contentToSave);
-      }
-    } catch (e) {
-      state = state.copyWith(error: 'Error saving file: $e');
-    }
-  }
-
-  Future<void> pickFiles() async {
-    state = state.copyWith(isProcessing: true, clearError: true);
-    try {
-      final files = await openFiles(
-        acceptedTypeGroups: [
-          const XTypeGroup(
-            label: 'Text files',
-            extensions: <String>[
-              'txt',
-              'dart',
-              'py',
-              'js',
-              'ts',
-              'jsx',
-              'tsx',
-              'java',
-              'kt',
-              'swift',
-              'cpp',
-              'c',
-              'h',
-              'hpp',
-              'cs',
-              'php',
-              'rb',
-              'go',
-              'rs',
-              'html',
-              'css',
-              'scss',
-              'json',
-              'xml',
-              'yaml',
-              'yml',
-              'md',
-              'sql'
-            ],
-          ),
-          const XTypeGroup(label: 'All files'),
-        ],
-      );
-
-      if (files.isNotEmpty) {
-        final filePaths = files.map((file) => file.path).toList();
-        // addFiles will set processing to false after it's done with its own loading.
-        // So, no need to set isProcessing to false here explicitly.
-        await addFiles(filePaths);
-      } else {
-        state = state.copyWith(isProcessing: false);
-      }
-    } catch (e) {
-      state =
-          state.copyWith(error: 'Error picking files: $e', isProcessing: false);
-    }
-  }
-
-  Future<void> pickDirectory() async {
-    state = state.copyWith(isProcessing: true, clearError: true);
-    try {
-      final directoryPath = await getDirectoryPath();
-      if (directoryPath != null) {
-        // addDirectory will set processing to false.
-        await addDirectory(directoryPath);
-      } else {
-        state = state.copyWith(isProcessing: false);
-      }
-    } catch (e) {
-      state = state.copyWith(
-          error: 'Error picking directory: $e', isProcessing: false);
-    }
-  }
-
-  void clearError() {
-    state = state.copyWith(clearError: true);
-  }
-
-  // isFileSelected can be a getter on the state or a method here.
-  // For consistency with UI, usually it's part of state or derived from it.
-  // Let's assume UI will use state.selectedFilePaths.contains(file.fullPath)
-
-  // Private method to update combined content
-  // Note: This now updates the state directly.
-  Future<void> _updateCombinedContent() async {
-    final content = await _contentAssembler.buildMerged(state.selectedFiles);
-    // Check if the notifier is still mounted before updating state
-    if (!mounted) return;
-    state = state.copyWith(combinedContent: content);
-  }
-}
diff --git a/lib/src/features/scan/presentation/ui/action_buttons_widget.dart b/lib/src/features/scan/presentation/ui/action_buttons_widget.dart
deleted file mode 100644
index caab9b6..0000000
--- a/lib/src/features/scan/presentation/ui/action_buttons_widget.dart
+++ /dev/null
@@ -1,189 +0,0 @@
-import 'package:context_collector/context_collector.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-class ActionButtonsWidget extends ConsumerWidget {
-  const ActionButtonsWidget({super.key});
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final selectionState = ref.watch(selectionProvider);
-    final selectionNotifier = ref.read(selectionProvider.notifier);
-
-    return Container(
-      padding: const EdgeInsetsDirectional.fromSTEB(12, 8, 12, 8),
-      decoration: BoxDecoration(
-        color: context.background,
-        border: BorderDirectional(
-          bottom: BorderSide(
-            color: context.outline.addOpacity(0.2),
-          ),
-        ),
-      ),
-      child: Column(
-        children: [
-          // File selection controls
-          Container(
-            padding: const EdgeInsetsDirectional.symmetric(
-              horizontal: 16,
-              vertical: 12,
-            ),
-            decoration: BoxDecoration(
-              color: context.surface,
-              borderRadius: BorderRadius.circular(12),
-              border: Border.all(
-                color: context.outline.addOpacity(0.2),
-              ),
-            ),
-            child: Row(
-              children: [
-                Row(
-                  children: [
-                    Icon(
-                      Icons.folder_copy_rounded,
-                      size: 20,
-                      color: context.primary,
-                    ),
-                    const SizedBox(width: 12),
-                    Text(
-                      'Files',
-                      style: context.titleMedium?.copyWith(
-                        fontWeight: FontWeight.w700,
-                      ),
-                    ),
-                    const SizedBox(width: 8),
-                    Container(
-                      padding: const EdgeInsetsDirectional.symmetric(
-                        horizontal: 10,
-                        vertical: 4,
-                      ),
-                      decoration: BoxDecoration(
-                        color: context.primary.addOpacity(0.1),
-                        borderRadius: BorderRadius.circular(20),
-                      ),
-                      child: Text(
-                        '${selectionState.selectedFilesCount} / ${selectionState.totalFilesCount}',
-                        style: context.labelSmall?.copyWith(
-                          color: context.primary,
-                          fontWeight: FontWeight.w600,
-                        ),
-                      ),
-                    ),
-                  ],
-                ),
-                const Spacer(),
-                Container(
-                  decoration: BoxDecoration(
-                    color: context.surfaceContainerHighest,
-                    borderRadius: BorderRadius.circular(8),
-                  ),
-                  child: Row(
-                    children: [
-                      Material(
-                        color: Colors.transparent,
-                        borderRadius: const BorderRadiusDirectional.only(
-                          topStart: Radius.circular(8),
-                          bottomStart: Radius.circular(8),
-                        ),
-                        child: InkWell(
-                          onTap: selectionState.totalFilesCount > 0
-                              ? selectionNotifier.selectAll
-                              : null,
-                          borderRadius: const BorderRadius.only(
-                            topLeft: Radius.circular(8),
-                            bottomLeft: Radius.circular(8),
-                          ),
-                          splashColor: Colors.transparent,
-                          highlightColor: Colors.transparent,
-                          hoverColor: context.primary.addOpacity(0.04),
-                          child: Container(
-                            padding: const EdgeInsetsDirectional.symmetric(
-                              horizontal: 12,
-                              vertical: 6,
-                            ),
-                            child: Row(
-                              children: [
-                                Icon(
-                                  Icons.done_all_rounded,
-                                  size: 16,
-                                  color: selectionState.totalFilesCount > 0
-                                      ? context.primary
-                                      : context.onSurface.addOpacity(0.3),
-                                ),
-                                const SizedBox(width: 4),
-                                Text(
-                                  'All',
-                                  style: context.labelMedium?.copyWith(
-                                    color: selectionState.totalFilesCount > 0
-                                        ? context.primary
-                                        : context.onSurface.addOpacity(0.3),
-                                    fontWeight: FontWeight.w600,
-                                  ),
-                                ),
-                              ],
-                            ),
-                          ),
-                        ),
-                      ),
-                      Container(
-                        width: 1,
-                        height: 24,
-                        color: context.outline.addOpacity(0.2),
-                      ),
-                      Material(
-                        color: Colors.transparent,
-                        borderRadius: const BorderRadiusDirectional.only(
-                          topEnd: Radius.circular(8),
-                          bottomEnd: Radius.circular(8),
-                        ),
-                        child: InkWell(
-                          onTap: selectionState.selectedFilesCount > 0
-                              ? selectionNotifier.deselectAll
-                              : null,
-                          borderRadius: const BorderRadius.only(
-                            topRight: Radius.circular(8),
-                            bottomRight: Radius.circular(8),
-                          ),
-                          splashColor: Colors.transparent,
-                          highlightColor: Colors.transparent,
-                          hoverColor: context.onSurface.addOpacity(0.04),
-                          child: Container(
-                            padding: const EdgeInsetsDirectional.symmetric(
-                              horizontal: 12,
-                              vertical: 6,
-                            ),
-                            child: Row(
-                              children: [
-                                Icon(
-                                  Icons.remove_done_rounded,
-                                  size: 16,
-                                  color: selectionState.selectedFilesCount > 0
-                                      ? context.onSurface.addOpacity(0.6)
-                                      : context.onSurface.addOpacity(0.3),
-                                ),
-                                const SizedBox(width: 4),
-                                Text(
-                                  'None',
-                                  style: context.labelMedium?.copyWith(
-                                    color: selectionState.selectedFilesCount > 0
-                                        ? context.onSurface.addOpacity(0.6)
-                                        : context.onSurface.addOpacity(0.3),
-                                    fontWeight: FontWeight.w600,
-                                  ),
-                                ),
-                              ],
-                            ),
-                          ),
-                        ),
-                      ),
-                    ],
-                  ),
-                ),
-              ],
-            ),
-          ),
-        ],
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/scan/presentation/ui/drop_zone_widget.dart b/lib/src/features/scan/presentation/ui/drop_zone_widget.dart
deleted file mode 100644
index 275fc9b..0000000
--- a/lib/src/features/scan/presentation/ui/drop_zone_widget.dart
+++ /dev/null
@@ -1,357 +0,0 @@
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:context_collector/src/shared/utils/extension_catalog.dart';
-import 'package:flutter/material.dart';
-
-class DropZoneWidget extends StatelessWidget {
-  const DropZoneWidget({super.key});
-
-  @override
-  Widget build(BuildContext context) {
-    return Center(
-      child: Container(
-        margin: const EdgeInsetsDirectional.all(32),
-        padding: const EdgeInsetsDirectional.all(64),
-        child: ConstrainedBox(
-          constraints: const BoxConstraints(
-            maxWidth: 600,
-          ),
-          child: SingleChildScrollView(
-            child: Column(
-              mainAxisSize: MainAxisSize.min,
-              children: [
-                // Icon container with gradient background
-                Container(
-                  width: 120,
-                  height: 120,
-                  decoration: BoxDecoration(
-                    gradient: LinearGradient(
-                      colors: [
-                        context.primary.addOpacity(0.1),
-                        context.primary.addOpacity(0.05),
-                      ],
-                      begin: AlignmentDirectional.topStart,
-                      end: AlignmentDirectional.bottomEnd,
-                    ),
-                    borderRadius: BorderRadius.circular(30),
-                  ),
-                  child: Icon(
-                    Icons.folder_open_rounded,
-                    size: 56,
-                    color: context.primary,
-                  ),
-                ),
-                const SizedBox(height: 32),
-                Text(
-                  'Drop Your Files or Directories Here',
-                  textAlign: TextAlign.center,
-                  style: context.displaySmall?.copyWith(
-                    color: context.onSurface,
-                    fontWeight: FontWeight.w800,
-                    letterSpacing: -1,
-                  ),
-                ),
-                const SizedBox(height: 16),
-                Text(
-                  'Drag and drop files or directories to combine their content\ninto a single, organized collection',
-                  textAlign: TextAlign.center,
-                  style: context.bodyLarge?.copyWith(
-                    color: context.onSurface.addOpacity(0.6),
-                    height: 1.5,
-                  ),
-                ),
-                const SizedBox(height: 40),
-                _buildSecondaryButton(context),
-                const SizedBox(height: 48),
-                _buildFeatureGrid(context),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildSecondaryButton(BuildContext context) {
-    return OutlinedButton.icon(
-      onPressed: () => _showSupportedFormats(context),
-      icon: const Icon(Icons.help_outline_rounded),
-      label: const Text('Supported Formats'),
-      style: OutlinedButton.styleFrom(
-        padding: const EdgeInsetsDirectional.symmetric(
-          horizontal: 24,
-          vertical: 16,
-        ),
-        textStyle: const TextStyle(
-          fontSize: 16,
-          fontWeight: FontWeight.w600,
-        ),
-      ),
-    );
-  }
-
-  Widget _buildFeatureGrid(BuildContext context) {
-    final features = [
-      (
-        icon: Icons.code_rounded,
-        title: 'All Text Files',
-        description:
-            'Support for ${ExtensionCatalog.supportedExtensions.length}+ file types',
-      ),
-      (
-        icon: Icons.link_rounded,
-        title: 'File References',
-        description: 'Includes path & metadata',
-      ),
-      (
-        icon: Icons.content_copy_rounded,
-        title: 'Quick Copy',
-        description: 'One-click clipboard copy',
-      ),
-      (
-        icon: Icons.edit_note_rounded,
-        title: 'Code Editor',
-        description: 'View and edit content in real-time',
-      ),
-    ];
-
-    return Wrap(
-      spacing: 16,
-      runSpacing: 16,
-      children: features
-          .map((feature) => SizedBox(
-                width: 280,
-                child: Row(
-                  children: [
-                    Container(
-                      padding: const EdgeInsetsDirectional.all(12),
-                      decoration: BoxDecoration(
-                        color: context.primary.addOpacity(0.08),
-                        borderRadius: BorderRadius.circular(12),
-                      ),
-                      child: Icon(
-                        feature.icon,
-                        size: 24,
-                        color: context.primary,
-                      ),
-                    ),
-                    const SizedBox(width: 16),
-                    Expanded(
-                      child: Column(
-                        crossAxisAlignment: CrossAxisAlignment.start,
-                        children: [
-                          Text(
-                            feature.title,
-                            style: context.titleSmall?.copyWith(
-                              fontWeight: FontWeight.w700,
-                            ),
-                          ),
-                          const SizedBox(height: 2),
-                          Text(
-                            feature.description,
-                            style: context.bodySmall?.copyWith(
-                              color: context.onSurface.addOpacity(0.6),
-                            ),
-                          ),
-                        ],
-                      ),
-                    ),
-                  ],
-                ),
-              ))
-          .toList(),
-    );
-  }
-
-  Future<void> _showSupportedFormats(BuildContext context) async {
-    final groupedExtensions = ExtensionCatalog.getGroupedExtensions();
-    await showDialog<void>(
-      context: context,
-      builder: (context) => Dialog(
-        shape: RoundedRectangleBorder(
-          borderRadius: BorderRadius.circular(20),
-        ),
-        child: Container(
-          constraints: const BoxConstraints(
-            maxWidth: 600,
-            maxHeight: 700,
-          ),
-          child: Column(
-            mainAxisSize: MainAxisSize.min,
-            children: [
-              Container(
-                padding: const EdgeInsetsDirectional.all(24),
-                decoration: BoxDecoration(
-                  color: context.primary.addOpacity(0.05),
-                  borderRadius: const BorderRadiusDirectional.only(
-                    topStart: Radius.circular(20),
-                    topEnd: Radius.circular(20),
-                  ),
-                ),
-                child: Row(
-                  children: [
-                    Icon(
-                      Icons.file_present_rounded,
-                      color: context.primary,
-                      size: 28,
-                    ),
-                    const SizedBox(width: 12),
-                    Text(
-                      'Supported File Formats',
-                      style: context.headlineSmall?.copyWith(
-                        fontWeight: FontWeight.w700,
-                        color: context.onSurface,
-                      ),
-                    ),
-                    const Spacer(),
-                    IconButton(
-                      onPressed: () => Navigator.of(context).pop(),
-                      icon: Icon(
-                        Icons.close_rounded,
-                        color: context.onSurface.addOpacity(0.6),
-                      ),
-                      style: IconButton.styleFrom(
-                        backgroundColor: context.surface,
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-              Flexible(
-                child: SingleChildScrollView(
-                  padding: const EdgeInsetsDirectional.all(24),
-                  child: Column(
-                    crossAxisAlignment: CrossAxisAlignment.start,
-                    children: [
-                      for (final entry in groupedExtensions.entries) ...[
-                        _buildFormatCategory(
-                          context,
-                          entry.key,
-                          entry.value,
-                        ),
-                        if (entry.key != groupedExtensions.keys.last)
-                          const SizedBox(height: 20),
-                      ],
-                    ],
-                  ),
-                ),
-              ),
-              Container(
-                padding: const EdgeInsetsDirectional.all(16),
-                decoration: BoxDecoration(
-                  color: context.surface,
-                  borderRadius: const BorderRadiusDirectional.only(
-                    bottomStart: Radius.circular(20),
-                    bottomEnd: Radius.circular(20),
-                  ),
-                ),
-                child: Row(
-                  children: [
-                    Icon(
-                      Icons.info_outline_rounded,
-                      size: 16,
-                      color: context.onSurface.addOpacity(0.6),
-                    ),
-                    const SizedBox(width: 8),
-                    Expanded(
-                      child: Text(
-                        '${ExtensionCatalog.supportedExtensions.length} file types supported',
-                        style: context.bodySmall?.copyWith(
-                          color: context.onSurface.addOpacity(0.6),
-                        ),
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-            ],
-          ),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildFormatCategory(
-      BuildContext context, FileCategory category, List<String> extensions) {
-    return Container(
-      padding: const EdgeInsetsDirectional.all(16),
-      decoration: BoxDecoration(
-        color: context.surface,
-        borderRadius: BorderRadius.circular(12),
-        border: Border.all(
-          color: context.outline.addOpacity(0.2),
-        ),
-      ),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          Row(
-            children: [
-              Container(
-                padding: const EdgeInsetsDirectional.all(8),
-                decoration: BoxDecoration(
-                  color: context.primary.addOpacity(0.1),
-                  borderRadius: BorderRadius.circular(8),
-                ),
-                child: Icon(
-                  category.icon,
-                  size: 20,
-                  color: context.primary,
-                ),
-              ),
-              const SizedBox(width: 12),
-              Text(
-                category.displayName,
-                style: context.titleSmall?.copyWith(
-                  fontWeight: FontWeight.w700,
-                  color: context.onSurface,
-                ),
-              ),
-              const Spacer(),
-              Container(
-                padding: const EdgeInsetsDirectional.symmetric(
-                  horizontal: 8,
-                  vertical: 4,
-                ),
-                decoration: BoxDecoration(
-                  color: context.primary.addOpacity(0.1),
-                  borderRadius: BorderRadius.circular(12),
-                ),
-                child: Text(
-                  '${extensions.length}',
-                  style: context.labelSmall?.copyWith(
-                    color: context.primary,
-                    fontWeight: FontWeight.w600,
-                  ),
-                ),
-              ),
-            ],
-          ),
-          const SizedBox(height: 12),
-          Wrap(
-            spacing: 6,
-            runSpacing: 6,
-            children: extensions
-                .map((ext) => Container(
-                      padding: const EdgeInsetsDirectional.symmetric(
-                        horizontal: 10,
-                        vertical: 4,
-                      ),
-                      decoration: BoxDecoration(
-                        color: context.surfaceContainerHighest,
-                        borderRadius: BorderRadius.circular(8),
-                      ),
-                      child: Text(
-                        ext,
-                        style: context.labelSmall?.copyWith(
-                          fontFamily: 'monospace',
-                          fontSize: 12,
-                        ),
-                      ),
-                    ))
-                .toList(),
-          ),
-        ],
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/scan/presentation/ui/file_list_widget.dart b/lib/src/features/scan/presentation/ui/file_list_widget.dart
deleted file mode 100644
index fccdc44..0000000
--- a/lib/src/features/scan/presentation/ui/file_list_widget.dart
+++ /dev/null
@@ -1,805 +0,0 @@
-import 'package:context_collector/context_collector.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-
-class FileListWidget extends ConsumerWidget {
-  const FileListWidget({super.key});
-
-  @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final selectionState = ref.watch(selectionProvider);
-    final prefsState = ref.watch(preferencesProvider);
-
-    if (selectionState.allFiles.isEmpty) {
-      return const Center(
-        child: Text('No files added yet'),
-      );
-    }
-
-    return ListView.builder(
-      itemCount: selectionState.allFiles.length,
-      itemBuilder: (context, index) {
-        final file = selectionState.allFiles[index];
-        return _FileListItem(
-          file: file,
-          isSelected: selectionState.selectedFilePaths.contains(file.fullPath),
-          activeExtensions: prefsState.prefs.activeExtensions,
-          onToggle: () =>
-              ref.read(selectionProvider.notifier).toggleFileSelection(file),
-          onRemove: () => ref.read(selectionProvider.notifier).removeFile(file),
-        );
-      },
-    );
-  }
-}
-
-class _FileListItem extends StatelessWidget {
-  const _FileListItem({
-    required this.file,
-    required this.isSelected,
-    required this.activeExtensions,
-    required this.onToggle,
-    required this.onRemove,
-  });
-
-  final ScannedFile file;
-  final bool isSelected;
-  final Map<String, FileCategory> activeExtensions;
-  final VoidCallback onToggle;
-  final VoidCallback onRemove;
-
-  @override
-  Widget build(BuildContext context) {
-    return AnimatedContainer(
-      duration: const Duration(milliseconds: 200),
-      margin: const EdgeInsetsDirectional.symmetric(
-        horizontal: 12,
-        vertical: 6,
-      ),
-      decoration: BoxDecoration(
-        color: isSelected ? context.primary.addOpacity(0.05) : context.surface,
-        borderRadius: BorderRadius.circular(16),
-        border: Border.all(
-          color: isSelected
-              ? context.primary.addOpacity(0.3)
-              : context.outline.addOpacity(0.2),
-          width: isSelected ? 1.5 : 1,
-        ),
-      ),
-      child: Material(
-        color: Colors.transparent,
-        borderRadius: BorderRadius.circular(16),
-        child: InkWell(
-          onTap: onToggle,
-          borderRadius: BorderRadius.circular(16),
-          splashColor: Colors.transparent,
-          highlightColor: Colors.transparent,
-          hoverColor: isSelected
-              ? context.primary.addOpacity(0.02)
-              : context.onSurface.addOpacity(0.02),
-          child: Padding(
-            padding: const EdgeInsetsDirectional.all(16),
-            child: Row(
-              children: [
-                _buildLeading(context),
-                const SizedBox(width: 16),
-                Expanded(
-                  child: _buildContent(context),
-                ),
-                const SizedBox(width: 12),
-                _buildTrailing(context),
-              ],
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-
-  Widget _buildLeading(BuildContext context) {
-    return Row(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        AnimatedContainer(
-          duration: const Duration(milliseconds: 200),
-          width: 24,
-          height: 24,
-          decoration: BoxDecoration(
-            color: isSelected ? context.primary : context.surface,
-            borderRadius: BorderRadius.circular(8),
-            border: Border.all(
-              color: isSelected
-                  ? context.primary
-                  : context.outline.addOpacity(0.5),
-              width: 2,
-            ),
-          ),
-          child: isSelected
-              ? const Icon(
-                  Icons.check_rounded,
-                  size: 14,
-                  color: Colors.white,
-                )
-              : null,
-        ),
-        const SizedBox(width: 12),
-        _buildFileIcon(context),
-      ],
-    );
-  }
-
-  Widget _buildContent(BuildContext context) {
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        Text(
-          file.name,
-          style: context.titleSmall?.copyWith(
-            fontWeight: FontWeight.w600,
-            color: context.onSurface,
-          ),
-          maxLines: 1,
-          overflow: TextOverflow.ellipsis,
-        ),
-        const SizedBox(height: 4),
-        Row(
-          children: [
-            if (file.isVSCodeDrop) ...[
-              Tooltip(
-                message: 'Dragged from VS Code',
-                child: Icon(
-                  Icons.code_rounded,
-                  size: 12,
-                  color: context.onSurface.addOpacity(0.5),
-                ),
-              ),
-              const SizedBox(width: 4),
-            ],
-            Expanded(
-              child: Text(
-                file.displayPath ?? file.fullPath,
-                style: context.bodySmall?.copyWith(
-                  color: context.onSurface.addOpacity(0.5),
-                  fontFamily: 'monospace',
-                  fontSize: 11,
-                ),
-                maxLines: 1,
-                overflow: TextOverflow.ellipsis,
-              ),
-            ),
-          ],
-        ),
-        const SizedBox(height: 8),
-        SingleChildScrollView(
-          scrollDirection: Axis.horizontal,
-          child: Row(
-            children: [
-              _buildStatusChip(context),
-              const SizedBox(width: 8),
-              Container(
-                padding: const EdgeInsetsDirectional.symmetric(
-                  horizontal: 8,
-                  vertical: 2,
-                ),
-                decoration: BoxDecoration(
-                  color: context.surfaceContainerHighest,
-                  borderRadius: BorderRadius.circular(6),
-                ),
-                child: Text(
-                  file.sizeFormatted,
-                  style: context.labelSmall?.copyWith(
-                    fontSize: 11,
-                    color: context.onSurface.addOpacity(0.6),
-                  ),
-                ),
-              ),
-              if (file.getCategory(activeExtensions) != null) ...[
-                const SizedBox(width: 8),
-                Container(
-                  padding: const EdgeInsetsDirectional.symmetric(
-                    horizontal: 8,
-                    vertical: 2,
-                  ),
-                  decoration: BoxDecoration(
-                    color: context.primary.addOpacity(0.1),
-                    borderRadius: BorderRadius.circular(6),
-                  ),
-                  child: Text(
-                    file.extension,
-                    style: context.labelSmall?.copyWith(
-                      fontSize: 11,
-                      fontFamily: 'monospace',
-                      color: context.primary,
-                      fontWeight: FontWeight.w600,
-                    ),
-                  ),
-                ),
-              ],
-            ],
-          ),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildTrailing(BuildContext context) {
-    return Row(
-      mainAxisSize: MainAxisSize.min,
-      children: [
-        if (file.error != null)
-          IconButton(
-            icon: Icon(
-              Icons.error_outline_rounded,
-              color: context.error,
-            ),
-            onPressed: () => _showErrorDialog(context),
-            tooltip: 'Show error',
-            style: IconButton.styleFrom(
-              backgroundColor: context.error.addOpacity(0.1),
-            ),
-            splashRadius: 0.1,
-            highlightColor: Colors.transparent,
-            splashColor: Colors.transparent,
-            hoverColor: context.error.addOpacity(0.05),
-          ),
-        const SizedBox(width: 8),
-        IconButton(
-          icon: const Icon(Icons.close_rounded),
-          onPressed: onRemove,
-          tooltip: 'Remove file',
-          style: IconButton.styleFrom(
-            foregroundColor: context.error,
-            backgroundColor: context.error.addOpacity(0.1),
-          ),
-          splashRadius: 0.1,
-          highlightColor: Colors.transparent,
-          splashColor: Colors.transparent,
-          hoverColor: context.error.addOpacity(0.05),
-        ),
-      ],
-    );
-  }
-
-  Widget _buildFileIcon(BuildContext context) {
-    final category = file.getCategory(activeExtensions);
-    final isSupported = file.supportsText(activeExtensions);
-
-    if (!isSupported || category == null) {
-      return Container(
-        width: 40,
-        height: 40,
-        decoration: BoxDecoration(
-          color: context.surfaceContainerHighest,
-          borderRadius: BorderRadius.circular(10),
-        ),
-        child: Icon(
-          Icons.insert_drive_file_outlined,
-          color: context.onSurface.addOpacity(0.5),
-          size: 20,
-        ),
-      );
-    }
-
-    // Default values from category
-    var iconData = category.icon;
-    var iconColor = context.primary;
-    var bgColor = context.primary.addOpacity(0.1);
-
-    // Enhanced file type detection with proper branding
-    final extension = file.extension.toLowerCase();
-    final fileName = file.name.toLowerCase();
-
-    // Special filename cases first
-    if (_getSpecialFilenameIcon(fileName) case final result?) {
-      iconData = result.icon;
-      iconColor = result.color;
-      bgColor = result.backgroundColor ?? result.color.addOpacity(0.1);
-    } else {
-      // Extension-based detection
-      switch (extension) {
-        // Dart & Flutter (your favorite!)
-        case '.dart':
-          iconData = Icons.flutter_dash;
-          iconColor = const Color(0xFF0175C2);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.g.dart':
-        case '.freezed.dart':
-        case '.chopper.dart':
-          iconData = Icons.auto_fix_high_rounded;
-          iconColor = const Color(0xFF0175C2);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Scripting Languages (your other favorites!)
-        case '.py':
-        case '.pyw':
-        case '.pyx':
-        case '.pyi':
-          iconData = Icons.psychology_rounded;
-          iconColor = const Color(0xFF3776AB);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.sh':
-        case '.bash':
-        case '.zsh':
-        case '.fish':
-          iconData = Icons.terminal_rounded;
-          iconColor = const Color(0xFF4EAA25);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.ps1':
-        case '.psm1':
-        case '.psd1':
-          iconData = Icons.terminal_rounded;
-          iconColor = const Color(0xFF012456);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // JavaScript Ecosystem
-        case '.js':
-        case '.mjs':
-        case '.cjs':
-          iconData = Icons.javascript_rounded;
-          iconColor = const Color(0xFFF7DF1E);
-          bgColor = const Color(0xFF323330);
-        case '.ts':
-        case '.tsx':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF3178C6);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Web Technologies
-        case '.html':
-        case '.htm':
-        case '.xhtml':
-          iconData = Icons.html_rounded;
-          iconColor = const Color(0xFFE34F26);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.css':
-          iconData = Icons.css_rounded;
-          iconColor = const Color(0xFF1572B6);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.scss':
-        case '.sass':
-          iconData = Icons.css_rounded;
-          iconColor = const Color(0xFFCF649A);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.less':
-          iconData = Icons.css_rounded;
-          iconColor = const Color(0xFF1D365D);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.vue':
-          iconData = Icons.web_rounded;
-          iconColor = const Color(0xFF4FC08D);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.svelte':
-          iconData = Icons.web_rounded;
-          iconColor = const Color(0xFFFF3E00);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Systems Programming
-        case '.c':
-        case '.h':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF00599C);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.cpp':
-        case '.cc':
-        case '.cxx':
-        case '.hpp':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF00599C);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.rs':
-          iconData = Icons.settings_rounded;
-          iconColor = const Color(0xFFCE422B);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.go':
-          iconData = Icons.speed_rounded;
-          iconColor = const Color(0xFF00ADD8);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.swift':
-          iconData = Icons.speed_rounded;
-          iconColor = const Color(0xFFFA7343);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // JVM Languages
-        case '.java':
-          iconData = Icons.coffee_rounded;
-          iconColor = const Color(0xFFED8B00);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.kt':
-        case '.kts':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF7F52FF);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.scala':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFFDC322F);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.groovy':
-        case '.gradle':
-          iconData = Icons.build_rounded;
-          iconColor = const Color(0xFF4298B8);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Other Scripting & Dynamic Languages
-        case '.rb':
-        case '.erb':
-        case '.gemspec':
-          iconData = Icons.diamond_rounded;
-          iconColor = const Color(0xFFCC342D);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.php':
-        case '.phtml':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF777BB4);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.pl':
-        case '.pm':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF39457E);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.lua':
-          iconData = Icons.nights_stay_rounded;
-          iconColor = const Color(0xFF000080);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Data & Configuration
-        case '.json':
-        case '.jsonl':
-        case '.json5':
-          iconData = Icons.data_object_rounded;
-          iconColor = const Color(0xFF000000);
-          bgColor = const Color(0xFFF5F5F5);
-        case '.yaml':
-        case '.yml':
-          iconData = Icons.settings_rounded;
-          iconColor = const Color(0xFFCB171E);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.xml':
-        case '.xsl':
-        case '.xslt':
-          iconData = Icons.code_rounded;
-          iconColor = const Color(0xFF0060AC);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.toml':
-          iconData = Icons.settings_rounded;
-          iconColor = const Color(0xFF9C4221);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.ini':
-        case '.cfg':
-        case '.conf':
-          iconData = Icons.tune_rounded;
-          iconColor = context.onSurface.addOpacity(0.7);
-          bgColor = context.surfaceContainerHighest;
-        case '.env':
-        case '.dotenv':
-          iconData = Icons.lock_rounded;
-          iconColor = const Color(0xFFECD53F);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Documentation
-        case '.md':
-        case '.markdown':
-          iconData = Icons.article_rounded;
-          iconColor = const Color(0xFF083FA1);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.rst':
-          iconData = Icons.article_rounded;
-          iconColor = const Color(0xFF3776AB);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.tex':
-        case '.latex':
-          iconData = Icons.article_rounded;
-          iconColor = const Color(0xFF008080);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Database
-        case '.sql':
-        case '.mysql':
-        case '.pgsql':
-          iconData = Icons.storage_rounded;
-          iconColor = const Color(0xFF336791);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Container & DevOps
-        case '.dockerfile':
-          iconData = Icons.directions_boat_rounded;
-          iconColor = const Color(0xFF2496ED);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.tf':
-        case '.tfvars':
-          iconData = Icons.cloud_rounded;
-          iconColor = const Color(0xFF623CE4);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Build & Package Management
-        case '.make':
-        case '.makefile':
-          iconData = Icons.build_rounded;
-          iconColor = const Color(0xFF427819);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.cmake':
-          iconData = Icons.build_rounded;
-          iconColor = const Color(0xFF064F8C);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Mobile Development
-        case '.m':
-        case '.mm':
-          iconData = Icons.phone_iphone_rounded;
-          iconColor = const Color(0xFF000000);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Functional Languages
-        case '.hs':
-        case '.lhs':
-          iconData = Icons.functions_rounded;
-          iconColor = const Color(0xFF5D4F85);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.clj':
-        case '.cljs':
-          iconData = Icons.functions_rounded;
-          iconColor = const Color(0xFF5881D8);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.ex':
-        case '.exs':
-          iconData = Icons.bolt_rounded;
-          iconColor = const Color(0xFF4B275F);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.erl':
-          iconData = Icons.memory_rounded;
-          iconColor = const Color(0xFFA90533);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Game Development & Graphics
-        case '.cs':
-          iconData = Icons.videogame_asset_rounded;
-          iconColor = const Color(0xFF239120);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.glsl':
-        case '.vert':
-        case '.frag':
-          iconData = Icons.gradient_rounded;
-          iconColor = const Color(0xFF5586A4);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Productivity Tools Extensions (since you love productive tools!)
-        case '.applescript':
-        case '.scpt':
-          iconData = Icons.apple_rounded;
-          iconColor = const Color(0xFF000000);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.awk':
-          iconData = Icons.text_snippet_rounded;
-          iconColor = const Color(0xFF4EAA25);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.sed':
-          iconData = Icons.find_replace_rounded;
-          iconColor = const Color(0xFF4EAA25);
-          bgColor = iconColor.addOpacity(0.1);
-        case '.jq':
-          iconData = Icons.filter_list_rounded;
-          iconColor = const Color(0xFF000000);
-          bgColor = iconColor.addOpacity(0.1);
-
-        // Default case - use category defaults
-        default:
-          // Keep the defaults from category
-          break;
-      }
-    }
-
-    return Container(
-      width: 40,
-      height: 40,
-      decoration: BoxDecoration(
-        color: bgColor,
-        borderRadius: BorderRadius.circular(10),
-        border: Border.all(
-          color: iconColor.addOpacity(0.1),
-          width: 0.5,
-        ),
-      ),
-      child: Icon(
-        iconData,
-        color: iconColor,
-        size: 22,
-      ),
-    );
-  }
-
-// Helper method for special filename detection
-  ({IconData icon, Color color, Color? backgroundColor})?
-      _getSpecialFilenameIcon(String fileName) {
-    return switch (fileName) {
-      // Dart/Flutter specific
-      'pubspec.yaml' || 'pubspec.yml' => (
-          icon: Icons.flutter_dash,
-          color: const Color(0xFF0175C2),
-          backgroundColor: null,
-        ),
-      'analysis_options.yaml' => (
-          icon: Icons.analytics_rounded,
-          color: const Color(0xFF0175C2),
-          backgroundColor: null,
-        ),
-
-      // Build files
-      'dockerfile' => (
-          icon: Icons.directions_boat_rounded,
-          color: const Color(0xFF2496ED),
-          backgroundColor: null,
-        ),
-      'makefile' || 'gnumakefile' => (
-          icon: Icons.build_rounded,
-          color: const Color(0xFF427819),
-          backgroundColor: null,
-        ),
-      'cmakelists.txt' => (
-          icon: Icons.build_rounded,
-          color: const Color(0xFF064F8C),
-          backgroundColor: null,
-        ),
-
-      // Package management
-      'package.json' => (
-          icon: Icons.inventory_2_rounded,
-          color: const Color(0xFFCB3837),
-          backgroundColor: null,
-        ),
-      'package-lock.json' => (
-          icon: Icons.lock_rounded,
-          color: const Color(0xFFCB3837),
-          backgroundColor: null,
-        ),
-      'cargo.toml' => (
-          icon: Icons.inventory_2_rounded,
-          color: const Color(0xFFCE422B),
-          backgroundColor: null,
-        ),
-      'go.mod' => (
-          icon: Icons.inventory_2_rounded,
-          color: const Color(0xFF00ADD8),
-          backgroundColor: null,
-        ),
-      'requirements.txt' => (
-          icon: Icons.inventory_2_rounded,
-          color: const Color(0xFF3776AB),
-          backgroundColor: null,
-        ),
-      'pipfile' => (
-          icon: Icons.inventory_2_rounded,
-          color: const Color(0xFF3776AB),
-          backgroundColor: null,
-        ),
-
-      // Configuration files
-      '.gitignore' => (
-          icon: Icons.visibility_off_rounded,
-          color: const Color(0xFFF05032),
-          backgroundColor: null,
-        ),
-      '.gitattributes' => (
-          icon: Icons.settings_rounded,
-          color: const Color(0xFFF05032),
-          backgroundColor: null,
-        ),
-      '.editorconfig' => (
-          icon: Icons.edit_rounded,
-          color: const Color(0xFF000000),
-          backgroundColor: null,
-        ),
-      '.eslintrc' || '.eslintrc.json' => (
-          icon: Icons.check_circle_rounded,
-          color: const Color(0xFF4B32C3),
-          backgroundColor: null,
-        ),
-      '.prettierrc' || '.prettierrc.json' => (
-          icon: Icons.auto_fix_high_rounded,
-          color: const Color(0xFFF7B93E),
-          backgroundColor: null,
-        ),
-
-      // CI/CD
-      '.travis.yml' => (
-          icon: Icons.build_circle_rounded,
-          color: const Color(0xFF3EAAAF),
-          backgroundColor: null,
-        ),
-      'docker-compose.yml' || 'docker-compose.yaml' => (
-          icon: Icons.view_module_rounded,
-          color: const Color(0xFF2496ED),
-          backgroundColor: null,
-        ),
-      _ => null,
-    };
-  }
-
-  Widget _buildStatusChip(BuildContext context) {
-    if (file.error != null) {
-      return Chip(
-        label: const Text('Error'),
-        labelStyle: context.labelSmall?.copyWith(
-          color: context.error,
-        ),
-        backgroundColor: context.error.addOpacity(0.1),
-        side: BorderSide.none,
-        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
-        visualDensity: VisualDensity.compact,
-      );
-    }
-
-    if (file.content != null) {
-      return Chip(
-        label: const Text('Loaded'),
-        labelStyle: context.labelSmall?.copyWith(
-          color: context.primary,
-        ),
-        backgroundColor: context.primary.addOpacity(0.1),
-        side: BorderSide.none,
-        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
-        visualDensity: VisualDensity.compact,
-      );
-    }
-
-    if (!file.supportsText(activeExtensions)) {
-      return Chip(
-        label: const Text('Not Supported'),
-        labelStyle: context.labelSmall?.copyWith(
-          color: context.onSurface.addOpacity(0.6),
-        ),
-        backgroundColor: context.onSurface.addOpacity(0.1),
-        side: BorderSide.none,
-        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
-        visualDensity: VisualDensity.compact,
-      );
-    }
-
-    return Chip(
-      label: const Text('Ready'),
-      labelStyle: context.labelSmall,
-      backgroundColor: context.surface,
-      side: BorderSide(
-        color: context.onSurface.addOpacity(0.2),
-      ),
-      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
-      visualDensity: VisualDensity.compact,
-    );
-  }
-
-  Future<void> _showErrorDialog(BuildContext context) async {
-    await showDialog<void>(
-      context: context,
-      builder: (context) => AlertDialog(
-        title: Row(
-          children: [
-            Icon(Icons.error_outline, color: context.error),
-            const SizedBox(width: 8),
-            const Text('File Error'),
-          ],
-        ),
-        content: Column(
-          mainAxisSize: MainAxisSize.min,
-          crossAxisAlignment: CrossAxisAlignment.start,
-          children: [
-            Text(
-              'File: ${file.name}',
-              style: context.titleSmall?.copyWith(
-                fontWeight: FontWeight.w600,
-              ),
-            ),
-            const SizedBox(height: 8),
-            Text(
-              'Error: ${file.error}',
-              style: context.bodyMedium,
-            ),
-          ],
-        ),
-        actions: [
-          TextButton(
-            onPressed: () => Navigator.of(context).pop(),
-            child: const Text('Close'),
-          ),
-        ],
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/scan/presentation/ui/home_screen.dart b/lib/src/features/scan/presentation/ui/home_screen.dart
deleted file mode 100644
index 447837f..0000000
--- a/lib/src/features/scan/presentation/ui/home_screen.dart
+++ /dev/null
@@ -1,332 +0,0 @@
-// lib/src/features/scan/presentation/ui/home_screen.dart
-import 'dart:io';
-
-import 'package:context_collector/context_collector.dart';
-import 'package:context_collector/src/shared/consts.dart';
-import 'package:context_collector/src/shared/utils/drop_file_resolver.dart';
-import 'package:context_collector/src/shared/utils/vscode_drop_detector.dart';
-import 'package:desktop_drop/desktop_drop.dart';
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter_riverpod/flutter_riverpod.dart';
-import 'package:flutter_svg/flutter_svg.dart';
-import 'package:url_launcher/url_launcher.dart';
-
-/// Home screen overlay that shows when no files are selected
-/// This is the top layer in the layered architecture
-class HomeScreen extends ConsumerStatefulWidget {
-  const HomeScreen({super.key});
-
-  @override
-  ConsumerState<HomeScreen> createState() => _HomeScreenState();
-}
-
-class _HomeScreenState extends ConsumerState<HomeScreen> {
-  bool _isDragging = false;
-
-  // Helper method to process children of DropItemDirectory recursively
-  Future<void> _processDropItemChildren(
-    List<DropItem> children,
-    List<String> files,
-    List<String> directories,
-  ) async {
-    for (final child in children) {
-      if (child is DropItemDirectory) {
-        directories.add(child.path);
-        await _processDropItemChildren(child.children, files, directories);
-      } else if (child is DropItemFile) {
-        files.add(child.path);
-      }
-    }
-  }
-
-  @override
-  void initState() {
-    super.initState();
-    // Initial setup for supported extensions
-    WidgetsBinding.instance.addPostFrameCallback((_) {
-      if (mounted) {
-        final selectionNotifier = ref.read(selectionProvider.notifier);
-        final prefsState = ref.read(preferencesProvider);
-        selectionNotifier
-            .setSupportedExtensions(prefsState.prefs.activeExtensions);
-      }
-    });
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    // Listen for preference changes
-    ref
-      ..listen<ExtensionPrefsWithLoading>(preferencesProvider,
-          (previous, next) {
-        if (previous?.prefs.activeExtensions != next.prefs.activeExtensions) {
-          ref
-              .read(selectionProvider.notifier)
-              .setSupportedExtensions(next.prefs.activeExtensions);
-        }
-      })
-
-      // Listen for errors
-      ..listen<SelectionState>(selectionProvider, (previous, next) {
-        if (next.error != null && next.error != previous?.error) {
-          ScaffoldMessenger.of(context).showSnackBar(
-            SnackBar(
-              content: Text(next.error!),
-              backgroundColor: context.error,
-              action: SnackBarAction(
-                label: 'Dismiss',
-                onPressed: () =>
-                    ref.read(selectionProvider.notifier).clearError(),
-                textColor: context.onError,
-              ),
-            ),
-          );
-        }
-      });
-
-    final selectionNotifier = ref.read(selectionProvider.notifier);
-
-    return Scaffold(
-      backgroundColor: context.surface,
-      appBar: AppBar(
-        title: Row(
-          mainAxisAlignment: MainAxisAlignment.center,
-          children: [
-            Container(
-              padding: const EdgeInsets.all(8),
-              decoration: BoxDecoration(
-                gradient: LinearGradient(
-                  colors: [
-                    context.primary,
-                    context.primary.addOpacity(0.8),
-                  ],
-                ),
-                borderRadius: BorderRadius.circular(10),
-              ),
-              child: const Icon(
-                Icons.collections_bookmark_rounded,
-                color: Colors.white,
-                size: 20,
-              ),
-            ),
-            const SizedBox(width: 12),
-            const Text('Context Collector'),
-          ],
-        ),
-        centerTitle: true,
-        actions: [
-          IconButton(
-            onPressed: () async {
-              final githubUrl =
-                  Uri.parse('https://github.com/omar-hanafy/context_collector');
-              if (!await launchUrl(githubUrl)) {
-                if (context.mounted) {
-                  ScaffoldMessenger.of(context).showSnackBar(
-                    const SnackBar(content: Text('Could not open GitHub')),
-                  );
-                }
-              }
-            },
-            icon: SvgPicture.asset(
-              context.isDark ? AppAssets.githubLight : AppAssets.githubDark,
-              width: 20,
-              height: 20,
-            ),
-            tooltip: 'View on GitHub',
-          ),
-          IconButton(
-            onPressed: () async {
-              final coffeeUrl =
-                  Uri.parse('https://www.buymeacoffee.com/omar.hanafy');
-              if (!await launchUrl(coffeeUrl)) {
-                if (context.mounted) {
-                  ScaffoldMessenger.of(context).showSnackBar(
-                    const SnackBar(
-                        content: Text('Could not open Buy Me a Coffee')),
-                  );
-                }
-              }
-            },
-            icon: SvgPicture.asset(
-              context.isDark ? AppAssets.logoLight : AppAssets.logoDark,
-              width: 20,
-              height: 20,
-            ),
-            tooltip: 'Buy Me a Coffee',
-          ),
-          IconButton(
-            onPressed: () {
-              Navigator.push(
-                context,
-                MaterialPageRoute<void>(
-                  builder: (context) => const SettingsScreen(),
-                ),
-              );
-            },
-            icon: const Icon(Icons.settings_rounded),
-            tooltip: 'Settings',
-          ),
-          const SizedBox(width: 8),
-        ],
-      ),
-      body: DropTarget(
-        onDragEntered: (details) {
-          setState(() => _isDragging = true);
-        },
-        onDragExited: (details) {
-          setState(() => _isDragging = false);
-        },
-        onDragDone: (details) async {
-          setState(() => _isDragging = false);
-
-          // Enhanced debug logging with ALL available metadata
-          if (kDebugMode) {
-            print('\n========== DROP EVENT DEBUG ==========');
-            print('Drop local position: ${details.localPosition}');
-            print('Drop global position: ${details.globalPosition}');
-            print('Number of items: ${details.files.length}');
-
-            for (var i = 0; i < details.files.length; i++) {
-              final item = details.files[i];
-              print('\n--- Item $i ---');
-              print('Runtime type: ${item.runtimeType}');
-              print('Path: ${item.path}');
-              print('Name: ${item.name}');
-
-              // Try to get async properties
-              try {
-                final mimeType = item.mimeType;
-                print('MIME type: $mimeType');
-              } catch (e) {
-                print('MIME type error: $e');
-              }
-
-              try {
-                final length = await item.length();
-                print('File size: $length bytes');
-              } catch (e) {
-                print('File size error: $e');
-              }
-
-              try {
-                final lastMod = await item.lastModified();
-                print('Last modified: $lastMod');
-              } catch (e) {
-                print('Last modified error: $e');
-              }
-
-              // Check macOS-specific bookmark data
-              if (item is DropItemFile) {
-                print('Has Apple bookmark: ${item.extraAppleBookmark != null}');
-                if (item.extraAppleBookmark != null) {
-                  print(
-                      'Bookmark size: ${item.extraAppleBookmark!.length} bytes');
-                }
-              }
-
-              // Check actual filesystem type
-              final fsType = FileSystemEntity.typeSync(item.path);
-              print('Filesystem type: $fsType');
-
-              // Check if it's a temporary file
-              print(
-                  'Is temp file: ${item.path.contains('/tmp/') || item.path.contains('/var/folders/')}');
-
-              // For directories, check children
-              if (item is DropItemDirectory) {
-                print('Children count: ${item.children.length}');
-              }
-            }
-            print('=====================================\n');
-          }
-
-          final files = <String>[];
-          final directories = <String>[];
-
-          for (final item in details.files) {
-            final filePath = item.path;
-
-            // Check if this is a VS Code directory drop
-            if (filePath.contains('/tmp/Drops/')) {
-              try {
-                // Try to read as VS Code directory listing
-                final content = await File(filePath).readAsString();
-                final directoryPath =
-                    VSCodeDropDetector.extractDirectoryPath(content);
-
-                if (directoryPath != null) {
-                  // Just add the directory path and let normal error handling deal with permissions
-                  directories.add(directoryPath);
-                  continue;
-                }
-              } catch (_) {
-                // Not a VS Code directory listing, process normally
-              }
-            }
-
-            // Handle typed drops (desktop_drop 0.6.0+)
-            if (item is DropItemDirectory) {
-              directories.add(filePath);
-              await _processDropItemChildren(item.children, files, directories);
-            } else if (item is DropItemFile) {
-              // JetBrains workaround: Check if this "file" is actually a directory
-              // JetBrains incorrectly reports directories as DropItemFile
-              final checkType = FileSystemEntity.typeSync(filePath);
-              if (checkType == FileSystemEntityType.directory) {
-                directories.add(filePath);
-              } else {
-                files.add(filePath);
-              }
-            } else {
-              // Fallback for regular XFile - use filesystem check
-              final entity = FileSystemEntity.typeSync(filePath);
-
-              if (entity == FileSystemEntityType.directory) {
-                directories.add(filePath);
-              } else if (entity == FileSystemEntityType.file) {
-                files.add(filePath);
-              } else if (DropFileResolver.isTemporaryDropFile(filePath)) {
-                // Handle other temporary drop files
-                try {
-                  final testFile = File(filePath);
-                  if (testFile.existsSync() &&
-                      testFile.statSync().type == FileSystemEntityType.file) {
-                    files.add(filePath);
-                  }
-                } catch (_) {
-                  // Skip files that can't be accessed
-                }
-              }
-            }
-          }
-
-          if (files.isNotEmpty) {
-            await selectionNotifier.addFiles(files);
-          }
-
-          for (final directory in directories) {
-            await selectionNotifier.addDirectory(directory);
-          }
-        },
-        child: Center(
-          child: AnimatedContainer(
-            duration: const Duration(milliseconds: 200),
-            decoration: BoxDecoration(
-              color: _isDragging
-                  ? context.primary.addOpacity(0.1)
-                  : Colors.transparent,
-              border: _isDragging
-                  ? Border.all(
-                      color: context.primary.addOpacity(0.5),
-                      width: 2,
-                    )
-                  : null,
-            ),
-            child: const DropZoneWidget(),
-          ),
-        ),
-      ),
-    );
-  }
-}
diff --git a/lib/src/features/scan/scan.dart b/lib/src/features/scan/scan.dart
index 41b5c5a..62af9e1 100644
--- a/lib/src/features/scan/scan.dart
+++ b/lib/src/features/scan/scan.dart
@@ -1,9 +1,15 @@
-// Scan feature exports
-export 'data/content_assembler.dart';
-export 'data/file_scanner.dart';
-export 'domain/scanned_file.dart';
-export 'presentation/state/selection_notifier.dart';
-export 'presentation/ui/action_buttons_widget.dart';
-export 'presentation/ui/drop_zone_widget.dart';
-export 'presentation/ui/file_list_widget.dart';
-export 'presentation/ui/home_screen.dart';
+// Simplified scan feature exports
+// Maintains the same public API as before
+
+export 'models/file_category.dart';
+export 'models/scan_result.dart';
+// Models
+export 'models/scanned_file.dart';
+export 'services/drop_handler.dart';
+// Services
+export 'services/file_scanner.dart';
+// State
+export 'state/file_list_state.dart';
+// UI
+export 'ui/file_list_screen.dart';
+export 'ui/home_screen_with_drop.dart';
diff --git a/lib/src/features/scan/services/drop_handler.dart b/lib/src/features/scan/services/drop_handler.dart
new file mode 100644
index 0000000..6543f65
--- /dev/null
+++ b/lib/src/features/scan/services/drop_handler.dart
@@ -0,0 +1,163 @@
+import 'dart:io';
+
+import 'package:cross_file/cross_file.dart';
+import 'package:desktop_drop/desktop_drop.dart';
+import 'package:path/path.dart' as path;
+
+import '../models/scan_result.dart';
+import '../models/scanned_file.dart';
+import 'file_scanner.dart';
+
+/// Simplified drop handler - keeps VS Code & JetBrains edge cases
+class DropHandler {
+  DropHandler({required this.fileScanner});
+
+  final FileScanner fileScanner;
+
+  /// Process dropped items - now returns ScanResult with metadata
+  Future<ScanResult> processDroppedItems(
+    List<XFile> items, {
+    required Set<String> blacklist,
+  }) async {
+    final allFiles = <ScannedFile>[];
+    final processedPaths = <String>{};
+    final sourcePaths = <String>{};
+
+    // Deduplicate items first - sometimes the same file appears multiple times
+    final uniquePaths = <String>{};
+    final uniqueItems = <XFile>[];
+    for (final item in items) {
+      if (!uniquePaths.contains(item.path)) {
+        uniquePaths.add(item.path);
+        uniqueItems.add(item);
+      }
+    }
+
+    // Group files by their parent directory first to avoid duplicate source paths
+    final filesByDirectory = <String, List<String>>{};
+    final directories = <String>[];
+
+    // First pass: categorize items
+    for (final item in uniqueItems) {
+      final itemPath = item.path;
+
+      // VS Code directory drop detection
+      if (await _isVSCodeDirectoryDrop(itemPath)) {
+        final dirPath = await _extractVSCodeDirectory(itemPath);
+        if (dirPath != null) {
+          directories.add(dirPath);
+        }
+        continue;
+      }
+
+      // Handle typed drops (desktop_drop 0.6.0+)
+      if (item is DropItemDirectory) {
+        directories.add(itemPath);
+      } else {
+        // Check if "file" is actually a directory (JetBrains workaround)
+        final entityType = FileSystemEntity.typeSync(itemPath);
+
+        if (entityType == FileSystemEntityType.directory) {
+          directories.add(itemPath);
+        } else if (entityType == FileSystemEntityType.file) {
+          // Group individual files by their parent directory
+          final parentDir = path.dirname(itemPath);
+          filesByDirectory.putIfAbsent(parentDir, () => []).add(itemPath);
+        }
+      }
+    }
+
+    // Process directories
+    for (final dirPath in directories) {
+      final scanResult = await fileScanner.scanDirectory(
+        dirPath,
+        blacklist: blacklist,
+      );
+      sourcePaths.add(dirPath);
+      for (final file in scanResult.files) {
+        if (!processedPaths.contains(file.fullPath)) {
+          allFiles.add(file);
+          processedPaths.add(file.fullPath);
+        }
+      }
+    }
+
+    // Process grouped files
+    for (final entry in filesByDirectory.entries) {
+      final parentDir = entry.key;
+      final filePaths = entry.value;
+
+      // Only add parent directory to source paths once per group
+      sourcePaths.add(parentDir);
+
+      for (final filePath in filePaths) {
+        // Skip if we've already processed this exact file path
+        if (processedPaths.contains(filePath)) {
+          continue;
+        }
+
+        final fileName = path.basename(filePath);
+
+        // Check if filename matches any blacklist pattern
+        bool isBlacklisted = false;
+        for (final pattern in blacklist) {
+          if (fileName.toLowerCase().endsWith(pattern.toLowerCase())) {
+            isBlacklisted = true;
+            break;
+          }
+        }
+
+        if (isBlacklisted) {
+          continue;
+        }
+
+        final file = ScannedFile.fromFile(
+          File(filePath),
+          relativePath: fileName,
+          source: ScanSource.drop,
+        );
+
+        allFiles.add(file);
+        processedPaths.add(filePath);
+      }
+    }
+
+    return ScanResult(
+      files: allFiles,
+      metadata: ScanMetadata(
+        sourcePaths: sourcePaths.toList(),
+        timestamp: DateTime.now(),
+        source: ScanSource.drop,
+      ),
+    );
+  }
+
+  /// Check if this is a VS Code directory drop
+  Future<bool> _isVSCodeDirectoryDrop(String filePath) async {
+    if (!filePath.contains('/tmp/Drops/')) return false;
+
+    try {
+      final content = await File(filePath).readAsString();
+      return content.contains('<script>start("') && content.contains('addRow(');
+    } catch (_) {
+      return false;
+    }
+  }
+
+  /// Extract directory path from VS Code drop
+  Future<String?> _extractVSCodeDirectory(String filePath) async {
+    try {
+      final content = await File(filePath).readAsString();
+      final match = RegExp(
+        r'<script>start\("([^"]+)"\);</script>',
+      ).firstMatch(content);
+      final dirPath = match?.group(1);
+
+      if (dirPath != null && Directory(dirPath).existsSync()) {
+        return dirPath;
+      }
+    } catch (_) {}
+
+    return null;
+  }
+}
diff --git a/lib/src/features/scan/services/file_scanner.dart b/lib/src/features/scan/services/file_scanner.dart
new file mode 100644
index 0000000..2b2424b
--- /dev/null
+++ b/lib/src/features/scan/services/file_scanner.dart
@@ -0,0 +1,132 @@
+import 'dart:io';
+
+import 'package:path/path.dart' as path;
+
+import '../models/scan_result.dart';
+import '../models/scanned_file.dart';
+
+/// Simplified file scanner - combines scanning and content assembly
+class FileScanner {
+  /// Scan directory for files, ignoring those in the blacklist.
+  /// Now returns ScanResult with metadata
+  Future<ScanResult> scanDirectory(
+    String directoryPath, {
+    required Set<String> blacklist,
+  }) async {
+    final directory = Directory(directoryPath);
+    if (!directory.existsSync()) {
+      throw FileSystemException('Directory not found: $directoryPath');
+    }
+
+    final files = <ScannedFile>[];
+
+    await for (final entity in directory.list(
+      recursive: true,
+      followLinks: false,
+    )) {
+      if (entity is File) {
+        final fileName = path.basename(entity.path);
+
+        // Skip hidden files
+        if (fileName.startsWith('.')) {
+          continue;
+        }
+
+        // Check if filename matches any blacklist pattern
+        bool isBlacklisted = false;
+        for (final pattern in blacklist) {
+          // Check if the filename ENDS WITH the blacklist pattern.
+          // This handles all cases:
+          // - '.log' matches my_app.log
+          // - '.g.dart' matches my_file.g.dart
+          // - 'pubspec.lock' matches pubspec.lock
+          if (fileName.toLowerCase().endsWith(pattern.toLowerCase())) {
+            isBlacklisted = true;
+            break;
+          }
+        }
+
+        if (isBlacklisted) {
+          continue;
+        }
+
+        try {
+          // Calculate relative path from the scanned directory
+          final relativePath = path.relative(entity.path, from: directoryPath);
+
+          files.add(
+            ScannedFile.fromFile(
+              entity,
+              relativePath: relativePath,
+              source: ScanSource.browse,
+            ),
+          );
+        } catch (_) {
+          // Skip files we can't access
+        }
+      }
+    }
+
+    return ScanResult(
+      files: files,
+      metadata: ScanMetadata(
+        sourcePaths: [directoryPath],
+        timestamp: DateTime.now(),
+        source: ScanSource.browse,
+      ),
+    );
+  }
+
+  /// Create a virtual file (not from disk)
+  ScannedFile createVirtualFile({
+    required String name,
+    required String content,
+    String? virtualPath,
+  }) {
+    final fullPath = virtualPath ?? '/$name';
+
+    // Generate deterministic ID for virtual files based on path
+    // Prefix with 'virtual_' to avoid conflicts with real files
+    final normalizedPath = path.normalize(fullPath);
+    final id =
+        'virtual_${normalizedPath.hashCode.toUnsigned(32).toRadixString(16)}';
+
+    return ScannedFile(
+      id: id,
+      name: name,
+      fullPath: fullPath,
+      relativePath: virtualPath?.replaceFirst('/', '') ?? name,
+      extension: path.extension(name).toLowerCase(),
+      size: content.length,
+      lastModified: DateTime.now(),
+      source: ScanSource.manual,
+      isVirtual: true,
+      content: content,
+      virtualContent: content,
+    );
+  }
+
+  /// Load content for a file
+  Future<ScannedFile> loadFileContent(ScannedFile file) async {
+    // Virtual files already have content
+    if (file.isVirtual) {
+      return file;
+    }
+
+    try {
+      final fileEntity = File(file.fullPath);
+      if (!fileEntity.existsSync()) {
+        return file.copyWith(error: 'File not found');
+      }
+
+      // Try to read as text
+      final content = await fileEntity.readAsString();
+      return file.copyWith(content: content);
+    } catch (e) {
+      // If it fails, it's probably binary
+      return file.copyWith(
+        error: 'Cannot read file: binary or unsupported format',
+      );
+    }
+  }
+}
diff --git a/lib/src/features/scan/services/markdown_builder.dart b/lib/src/features/scan/services/markdown_builder.dart
new file mode 100644
index 0000000..6e4bc06
--- /dev/null
+++ b/lib/src/features/scan/services/markdown_builder.dart
@@ -0,0 +1,40 @@
+import '../models/scanned_file.dart';
+import '../ui/file_display_helper.dart';
+
+/// Service responsible for building markdown output from selected files
+class MarkdownBuilder {
+  /// Build markdown from selected files
+  Future<String> buildMarkdown(List<ScannedFile> selectedFiles) async {
+    final buffer = StringBuffer()
+      ..writeln('# Context Collection')
+      ..writeln();
+
+    // Sort by path for consistency
+    final sortedFiles = List<ScannedFile>.from(selectedFiles)
+      ..sort((a, b) => a.fullPath.compareTo(b.fullPath));
+
+    for (final file in sortedFiles) {
+      buffer
+        ..writeln('## ${file.name}')
+        ..writeln(file.generateReference())
+        ..writeln();
+
+      // Use effectiveContent to support edited and virtual content
+      if (file.effectiveContent.isNotEmpty && file.error == null) {
+        buffer
+          ..writeln('```${FileDisplayHelper.getLanguageFromFile(file)}')
+          ..writeln(file.effectiveContent)
+          ..writeln('```')
+          ..writeln('\n---\n');
+      } else if (file.error != null) {
+        buffer.writeln('```\nERROR: ${file.error}\n```');
+      } else if (file.content == null && !file.isVirtual) {
+        buffer.writeln('```\n// Content not loaded\n```');
+      }
+
+      buffer.writeln();
+    }
+
+    return buffer.toString().replaceAll(RegExp(r'\n{3,}'), '\n\n');
+  }
+}
diff --git a/lib/src/features/scan/state/file_list_state.dart b/lib/src/features/scan/state/file_list_state.dart
new file mode 100644
index 0000000..ca6eec9
--- /dev/null
+++ b/lib/src/features/scan/state/file_list_state.dart
@@ -0,0 +1,583 @@
+import 'dart:io';
+
+import 'package:file_selector/file_selector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+import '../../settings/presentation/state/preferences_notifier.dart';
+import '../../virtual_tree/api/virtual_tree_api.dart';
+import '../models/scan_result.dart';
+import '../models/scanned_file.dart';
+import '../services/drop_handler.dart';
+import '../services/file_scanner.dart';
+import '../services/markdown_builder.dart';
+
+/// Selection state - enhanced with file map and scan history
+@immutable
+class SelectionState {
+  const SelectionState({
+    this.fileMap = const {},
+    this.selectedFileIds = const {},
+    this.scanHistory = const [],
+    this.isProcessing = false,
+    this.error,
+    this.combinedContent = '',
+    this.virtualTreeJson,
+  });
+
+  final Map<String, ScannedFile>
+  fileMap; // Quick lookup by ID - single source of truth
+  final Set<String> selectedFileIds; // Now using IDs instead of paths
+  final List<ScanMetadata> scanHistory;
+  final bool isProcessing;
+  final String? error;
+  final String combinedContent;
+  final String? virtualTreeJson;
+
+  // Backward compatible getters
+  Set<String> get selectedFilePaths =>
+      selectedFiles.map((f) => f.fullPath).toSet();
+
+  // New getters using IDs
+  List<ScannedFile> get selectedFiles => selectedFileIds
+      .map((id) => fileMap[id])
+      .whereType<ScannedFile>()
+      .toList();
+
+  int get selectedFilesCount => selectedFiles.length;
+
+  int get totalFilesCount => fileMap.length;
+
+  bool get hasFiles => fileMap.isNotEmpty;
+
+  bool get hasSelectedFiles => selectedFileIds.isNotEmpty;
+
+  // Helper methods
+  ScannedFile? getFileById(String id) => fileMap[id];
+
+  List<ScannedFile> getFilesByIds(List<String> ids) =>
+      ids.map((id) => fileMap[id]).whereType<ScannedFile>().toList();
+
+  SelectionState copyWith({
+    Map<String, ScannedFile>? fileMap,
+    Set<String>? selectedFileIds,
+    List<ScanMetadata>? scanHistory,
+    bool? isProcessing,
+    String? error,
+    bool clearError = false,
+    String? combinedContent,
+    String? virtualTreeJson,
+  }) {
+    return SelectionState(
+      fileMap: fileMap ?? this.fileMap,
+      selectedFileIds: selectedFileIds ?? this.selectedFileIds,
+      scanHistory: scanHistory ?? this.scanHistory,
+      isProcessing: isProcessing ?? this.isProcessing,
+      error: clearError ? null : error ?? this.error,
+      combinedContent: combinedContent ?? this.combinedContent,
+      virtualTreeJson: virtualTreeJson ?? this.virtualTreeJson,
+    );
+  }
+}
+
+/// Provider - same API
+final selectionProvider =
+    StateNotifierProvider<FileListNotifier, SelectionState>((ref) {
+      final fileScanner = FileScanner();
+      final markdownBuilder = MarkdownBuilder();
+      return FileListNotifier(
+        ref: ref,
+        fileScanner: fileScanner,
+        dropHandler: DropHandler(fileScanner: fileScanner),
+        markdownBuilder: markdownBuilder,
+      );
+    });
+
+/// Enhanced notifier with virtual tree integration
+class FileListNotifier extends StateNotifier<SelectionState> {
+  FileListNotifier({
+    required this.ref,
+    required this.fileScanner,
+    required this.dropHandler,
+    required this.markdownBuilder,
+  }) : super(const SelectionState());
+
+  final Ref ref;
+  final FileScanner fileScanner;
+  final DropHandler dropHandler;
+  final MarkdownBuilder markdownBuilder;
+
+  // Optional virtual tree integration
+  VirtualTreeAPI? virtualTree;
+
+  /// Initialize virtual tree and wire up callbacks
+  void initializeVirtualTree(VirtualTreeAPI tree) {
+    virtualTree = tree;
+
+    // Wire up callbacks from tree to this notifier
+    tree
+      ..onNodeCreated(onVirtualFileCreated)
+      ..onNodeEdited(onFileContentChanged)
+      ..onSelectionChanged(updateSelectionFromTree);
+  }
+
+  /// Process dropped items - main orchestrator method
+  Future<void> processDroppedItems(
+    List<XFile> items, {
+    BuildContext? context,
+  }) async {
+    state = state.copyWith(isProcessing: true, clearError: true);
+
+    try {
+      // Read the blacklist from settings
+      final filterSettings = ref.read(preferencesProvider).settings;
+      final blacklist = filterSettings.blacklistedExtensions;
+
+      // Step 1: Scan the dropped items
+      final scanResult = await dropHandler.processDroppedItems(
+        items,
+        blacklist: blacklist,
+      );
+
+      if (scanResult.files.isEmpty) {
+        state = state.copyWith(
+          isProcessing: false,
+          error: 'No new files to add',
+        );
+        return;
+      }
+
+      // Step 4: Apply changes to state
+      await _applyScanResultToState(scanResult);
+    } catch (e) {
+      state = state.copyWith(error: 'Failed to process files: $e');
+    } finally {
+      state = state.copyWith(isProcessing: false);
+    }
+  }
+
+  /// Apply scan result to state
+  Future<void> _applyScanResultToState(ScanResult scanResult) async {
+    // Build new file map
+    final newFileMap = Map<String, ScannedFile>.from(state.fileMap);
+    for (final file in scanResult.files) {
+      newFileMap[file.id] = file;
+    }
+
+    // Update scan history
+    final newScanHistory = [...state.scanHistory, scanResult.metadata];
+
+    // Auto-select new files
+    final updatedSelection = {
+      ...state.selectedFileIds,
+      ...scanResult.files.map((f) => f.id),
+    };
+
+    // Build virtual tree if available
+    if (virtualTree != null) {
+      final treeData = await virtualTree!.buildTree(
+        files: newFileMap.values.toList(),
+        scanMetadata: newScanHistory,
+      );
+
+      state = state.copyWith(
+        fileMap: newFileMap,
+        selectedFileIds: updatedSelection,
+        scanHistory: newScanHistory,
+        virtualTreeJson: treeData.toJson(),
+      );
+    } else {
+      state = state.copyWith(
+        fileMap: newFileMap,
+        selectedFileIds: updatedSelection,
+        scanHistory: newScanHistory,
+      );
+    }
+
+    // Load content for new files
+    await _loadFileContents(scanResult.files);
+  }
+
+  /// Load file contents - updated to use file map
+  Future<void> _loadFileContents(List<ScannedFile> files) async {
+    // Load all files first without updating state
+    final loadedFiles = <ScannedFile>[];
+    for (final file in files) {
+      final loadedFile = await fileScanner.loadFileContent(file);
+      loadedFiles.add(loadedFile);
+    }
+
+    // Update file map with loaded content
+    final newFileMap = Map<String, ScannedFile>.from(state.fileMap);
+    for (final loadedFile in loadedFiles) {
+      newFileMap[loadedFile.id] = loadedFile;
+    }
+
+    // Build combined content before updating state
+    final selectedFiles = state.selectedFileIds
+        .map((id) => newFileMap[id])
+        .whereType<ScannedFile>()
+        .toList();
+    final content = await markdownBuilder.buildMarkdown(selectedFiles);
+
+    // Single state update with everything
+    state = state.copyWith(
+      fileMap: newFileMap,
+      combinedContent: content,
+    );
+  }
+
+  /// Update selection from tree - called when tree selection changes
+  void updateSelectionFromTree(Set<String> fileIds) {
+    // Update selection and rebuild content
+    _updateSelectionAndContent(fileIds);
+  }
+
+  /// Toggle file selection - updated to use IDs
+  void toggleFileSelection(ScannedFile file) {
+    final currentSelection = Set<String>.from(state.selectedFileIds);
+    if (currentSelection.contains(file.id)) {
+      currentSelection.remove(file.id);
+    } else {
+      currentSelection.add(file.id);
+    }
+
+    _updateSelectionAndContent(currentSelection);
+  }
+
+  /// Update selection and rebuild content
+  void _updateSelectionAndContent(Set<String> newSelection) {
+    // Build content from selected files
+    final selectedFiles = newSelection
+        .map((id) => state.fileMap[id])
+        .whereType<ScannedFile>()
+        .toList();
+
+    // Update state and build content
+    markdownBuilder.buildMarkdown(selectedFiles).then((content) {
+      if (mounted) {
+        state = state.copyWith(
+          selectedFileIds: newSelection,
+          combinedContent: content,
+        );
+
+        // Notify virtual tree of selection change
+        virtualTree?.setSelectedFileIds(newSelection);
+      }
+    });
+  }
+
+  /// Select all files
+  void selectAll() {
+    final allIds = state.fileMap.keys.toSet();
+    _updateSelectionAndContent(allIds);
+  }
+
+  /// Deselect all files
+  void deselectAll() {
+    _updateSelectionAndContent({});
+  }
+
+  /// Remove a file
+  void removeFile(ScannedFile file) {
+    final newFileMap = Map<String, ScannedFile>.from(state.fileMap)
+      ..remove(file.id);
+
+    final updatedSelection = Set<String>.from(state.selectedFileIds)
+      ..remove(file.id);
+
+    // Update state and rebuild content
+    state = state.copyWith(
+      fileMap: newFileMap,
+      selectedFileIds: updatedSelection,
+    );
+
+    // Rebuild content
+    _rebuildCombinedContent();
+  }
+
+  /// Clear all files
+  void clearFiles() {
+    // Clear virtual tree first
+    virtualTree?.clearTree();
+
+    // Reset state
+    state = const SelectionState();
+  }
+
+  /// Copy to clipboard
+  Future<void> copyToClipboard() async {
+    if (state.combinedContent.isEmpty) {
+      state = state.copyWith(error: 'No content to copy');
+      return;
+    }
+    await Clipboard.setData(ClipboardData(text: state.combinedContent));
+  }
+
+  /// Save to file
+  Future<void> saveToFile() async {
+    if (state.combinedContent.isEmpty) {
+      state = state.copyWith(error: 'No content to save');
+      return;
+    }
+
+    try {
+      final fileName =
+          'context_collection_${DateTime.now().millisecondsSinceEpoch}.txt';
+      final filePath = await getSaveLocation(suggestedName: fileName);
+      if (filePath != null) {
+        await File(filePath.path).writeAsString(state.combinedContent);
+      }
+    } catch (e) {
+      state = state.copyWith(error: 'Error saving file: $e');
+    }
+  }
+
+  /// Pick files manually
+  Future<void> pickFiles(BuildContext context) async {
+    state = state.copyWith(isProcessing: true, clearError: true);
+    try {
+      final files = await openFiles();
+      if (files.isNotEmpty) {
+        await processDroppedItems(files, context: context);
+      }
+    } catch (e) {
+      state = state.copyWith(error: 'Error picking files: $e');
+    } finally {
+      state = state.copyWith(isProcessing: false);
+    }
+  }
+
+  /// Pick directory
+  Future<void> pickDirectory(BuildContext context) async {
+    state = state.copyWith(isProcessing: true, clearError: true);
+    try {
+      final directoryPath = await getDirectoryPath();
+      if (directoryPath != null) {
+        // Process as a dropped directory
+        await processDroppedItems([XFile(directoryPath)], context: context);
+      }
+    } catch (e) {
+      state = state.copyWith(error: 'Error picking directory: $e');
+    } finally {
+      state = state.copyWith(isProcessing: false);
+    }
+  }
+
+  /// Clear error
+  void clearError() {
+    state = state.copyWith(clearError: true);
+  }
+
+  /// Rebuild combined content from current selection
+  Future<void> _rebuildCombinedContent() async {
+    final selectedFiles = state.selectedFileIds
+        .map((id) => state.fileMap[id])
+        .whereType<ScannedFile>()
+        .toList();
+
+    final content = await markdownBuilder.buildMarkdown(selectedFiles);
+
+    if (mounted) {
+      state = state.copyWith(combinedContent: content);
+    }
+  }
+
+  // Virtual tree callback methods
+
+  /// Called when file content is edited
+  void onFileContentChanged(String fileId, String newContent) {
+    final file = state.fileMap[fileId];
+    if (file == null) return;
+
+    final updatedFile = file.copyWith(editedContent: newContent);
+    final newFileMap = Map<String, ScannedFile>.from(state.fileMap);
+    newFileMap[fileId] = updatedFile;
+
+    state = state.copyWith(
+      fileMap: newFileMap,
+    );
+
+    _rebuildCombinedContent();
+  }
+
+  /// Called when a virtual file is created
+  void onVirtualFileCreated(
+    String parentNodeId,
+    String fileName,
+    String content,
+  ) {
+    // Get the parent node's virtual path from the tree
+    final parentVirtualPath =
+        virtualTree?.getNodeVirtualPath(parentNodeId) ?? '';
+
+    // Build the correct virtual path for the new file
+    final virtualPath = parentVirtualPath.isEmpty
+        ? fileName
+        : '$parentVirtualPath/$fileName';
+
+    // Create the ScannedFile data object with the correct path
+    final virtualFile = fileScanner.createVirtualFile(
+      name: fileName,
+      content: content,
+      virtualPath: virtualPath,
+    );
+
+    // Add the new file to our central file map
+    final newFileMap = Map<String, ScannedFile>.from(state.fileMap);
+    newFileMap[virtualFile.id] = virtualFile;
+
+    // Update the state with the new file
+    state = state.copyWith(
+      fileMap: newFileMap,
+    );
+
+    // NOW, command the virtual tree to add the UI node for this new file
+    virtualTree?.addVirtualFileNode(
+      parentNodeId: parentNodeId,
+      file: virtualFile,
+    );
+
+    // No need to call _rebuildCombinedContent here, because the tree notifier
+    // will call back with the updated selection, which triggers the rebuild.
+  }
+
+  /// Called when a virtual folder is created
+  void onVirtualFolderCreated(
+    String parentNodeId,
+    String folderName,
+  ) {
+    if (virtualTree == null) return;
+
+    // For virtual folders, we delegate directly to the tree state
+    // since folders don't have associated file data
+    virtualTree!.createVirtualFolder(
+      parentNodeId: parentNodeId,
+      folderName: folderName,
+    );
+  }
+
+  /// Removes a set of nodes and all their descendants from the state.
+  /// This is the ONLY way to remove items to ensure proper cleanup.
+  ///
+  /// CRITICAL: This method performs three essential operations:
+  /// 1. Removes files from the master file map
+  /// 2. Updates the selection state
+  /// 3. CLEANS the scanHistory to prevent false duplicate detection
+  ///
+  /// The scanHistory cleanup (step 3) is CRITICAL. Without it, removing files
+  /// and then re-adding the same directory will incorrectly trigger the duplicate
+  /// detection dialog, even though the files are no longer in the tree.
+  ///
+  /// Implementation note: This method delegates the actual tree removal to a full
+  /// rebuild from the cleaned state, ensuring the tree always reflects the truth.
+  Future<void> removeNodes(Set<String> topLevelNodeIds) async {
+    if (virtualTree == null) return;
+
+    final allNodes = virtualTree!.getCurrentTree()?.nodes ?? {};
+    if (allNodes.isEmpty) return;
+
+    // --- Step 1: Collect all file IDs and source paths to be removed ---
+    final fileIdsToRemove = <String>{};
+    final nodesToRemove = <String>{};
+    final sourcePathsToRemove = <String>{};
+
+    void collectDescendants(String nodeId) {
+      if (nodesToRemove.contains(nodeId)) return;
+      nodesToRemove.add(nodeId);
+      final node = allNodes[nodeId];
+      if (node == null) return;
+      if (node.fileId != null) {
+        fileIdsToRemove.add(node.fileId!);
+      }
+      // If a folder node has an original source path, it's a candidate for history cleanup
+      if (node.type == NodeType.folder && node.sourcePath != null) {
+        sourcePathsToRemove.add(node.sourcePath!);
+      }
+      for (final childId in node.childIds) {
+        collectDescendants(childId);
+      }
+    }
+
+    for (final nodeId in topLevelNodeIds) {
+      collectDescendants(nodeId);
+    }
+
+    // Nothing to do
+    if (fileIdsToRemove.isEmpty && nodesToRemove.isEmpty) return;
+
+    // --- Step 2: Remove files from the master file map ---
+    final newFileMap = Map<String, ScannedFile>.from(state.fileMap)
+      ..removeWhere((fileId, _) => fileIdsToRemove.contains(fileId));
+
+    final newSelectedFileIds = Set<String>.from(state.selectedFileIds)
+      ..removeAll(fileIdsToRemove);
+
+    // --- Step 3: Clean the scanHistory (THE CRITICAL BUG FIX) ---
+    final newScanHistory = _removePathsFromScanHistory(sourcePathsToRemove);
+
+    // --- Step 4: Update state and trigger a full tree rebuild ---
+    state = state.copyWith(
+      fileMap: newFileMap,
+      selectedFileIds: newSelectedFileIds,
+      scanHistory: newScanHistory,
+    );
+
+    // This rebuilds the tree from the now-clean master state
+    await _rebuildTreeFromState();
+    await _rebuildCombinedContent();
+  }
+
+  /// Helper to rebuild the virtual tree from the current state
+  Future<void> _rebuildTreeFromState() async {
+    if (virtualTree != null) {
+      final treeData = await virtualTree!.buildTree(
+        files: state.fileMap.values.toList(),
+        scanMetadata: state.scanHistory,
+      );
+      state = state.copyWith(virtualTreeJson: treeData.toJson());
+    }
+  }
+
+  /// Removes a set of source paths from the scan history and returns the
+  /// clean history. This is critical for preventing incorrect duplicate detection.
+  ///
+  /// Why this is needed:
+  /// The scan history tracks all directories that have been scanned. When files
+  /// are removed from the tree, their source paths must also be removed from
+  /// the history. Otherwise, re-adding the same directory will be incorrectly
+  /// identified as a duplicate, even though those files are no longer present.
+  ///
+  /// Example bug this prevents:
+  /// 1. User adds /project/src/ (path recorded in scan history)
+  /// 2. User removes all files from /project/src/
+  /// 3. User adds /project/src/ again
+  /// 4. WITHOUT this cleanup: "Duplicate detected" dialog appears (incorrect)
+  /// 5. WITH this cleanup: Files are added normally (correct)
+  List<ScanMetadata> _removePathsFromScanHistory(
+    Iterable<String> pathsToRemove,
+  ) {
+    final pathsToRemoveSet = pathsToRemove.toSet();
+    final newScanHistory = <ScanMetadata>[];
+
+    for (final scanMetadata in state.scanHistory) {
+      // Get the source paths from this metadata entry that are NOT being removed.
+      final remainingSourcePaths = scanMetadata.sourcePaths
+          .where((p) => !pathsToRemoveSet.contains(p))
+          .toList();
+
+      // If there are any paths left, create a new metadata object for them.
+      if (remainingSourcePaths.isNotEmpty) {
+        newScanHistory.add(
+          ScanMetadata(
+            sourcePaths: remainingSourcePaths,
+            timestamp: scanMetadata.timestamp,
+            source: scanMetadata.source,
+          ),
+        );
+      }
+    }
+    return newScanHistory;
+  }
+}
diff --git a/lib/src/features/scan/ui/duplicate_handling_dialog.dart b/lib/src/features/scan/ui/duplicate_handling_dialog.dart
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/lib/src/features/scan/ui/duplicate_handling_dialog.dart
@@ -0,0 +1 @@
+
diff --git a/lib/src/features/scan/ui/file_conflict_dialog.dart b/lib/src/features/scan/ui/file_conflict_dialog.dart
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/lib/src/features/scan/ui/file_conflict_dialog.dart
@@ -0,0 +1 @@
+
diff --git a/lib/src/features/scan/ui/file_display_helper.dart b/lib/src/features/scan/ui/file_display_helper.dart
new file mode 100644
index 0000000..5169aea
--- /dev/null
+++ b/lib/src/features/scan/ui/file_display_helper.dart
@@ -0,0 +1,325 @@
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+import '../models/file_category.dart';
+import '../models/scanned_file.dart';
+
+/// Shared utility for displaying file information consistently across the app
+class FileDisplayHelper {
+  FileDisplayHelper._();
+
+  /// Get icon for file based on extension
+  static IconData getIconForExtension(String extension) {
+    const codeExtensions = {
+      '.dart',
+      '.py',
+      '.js',
+      '.ts',
+      '.java',
+      '.cpp',
+      '.c',
+      '.rs',
+      '.go',
+      '.rb',
+      '.php',
+      '.swift',
+      '.kt',
+      '.scala',
+      '.r',
+      '.m',
+      '.h',
+    };
+    const webExtensions = {
+      '.html',
+      '.css',
+      '.scss',
+      '.sass',
+      '.less',
+      '.jsx',
+      '.tsx',
+      '.vue',
+      '.svelte',
+      '.astro',
+    };
+    const configExtensions = {
+      '.json',
+      '.yaml',
+      '.yml',
+      '.xml',
+      '.toml',
+      '.ini',
+      '.conf',
+      '.config',
+      '.env',
+      '.properties',
+    };
+    const docExtensions = {
+      '.md',
+      '.txt',
+      '.rst',
+      '.adoc',
+      '.tex',
+      '.doc',
+      '.docx',
+      '.pdf',
+    };
+    const scriptExtensions = {
+      '.sh',
+      '.bash',
+      '.zsh',
+      '.fish',
+      '.ps1',
+      '.bat',
+      '.cmd',
+    };
+    const dataExtensions = {
+      '.csv',
+      '.tsv',
+      '.xls',
+      '.xlsx',
+      '.sql',
+      '.db',
+      '.sqlite',
+    };
+
+    final ext = extension.toLowerCase();
+
+    if (ext.isEmpty) return Icons.insert_drive_file_outlined;
+    if (codeExtensions.contains(ext)) return Icons.code;
+    if (webExtensions.contains(ext)) return Icons.web;
+    if (configExtensions.contains(ext)) return Icons.settings_outlined;
+    if (docExtensions.contains(ext)) return Icons.description_outlined;
+    if (scriptExtensions.contains(ext)) return Icons.terminal;
+    if (dataExtensions.contains(ext)) return Icons.table_chart_outlined;
+
+    return Icons.insert_drive_file_outlined;
+  }
+
+  /// Get color for file icon based on extension
+  static Color getIconColor(String extension, BuildContext context) {
+    final colorScheme = Theme.of(context).colorScheme;
+    final ext = extension.toLowerCase();
+
+    // Special colors for certain file types
+    if (ext == '.dart') return Colors.blue.shade600;
+    if (ext == '.py') return Colors.green.shade600;
+    if (ext == '.js' || ext == '.ts') return Colors.amber.shade700;
+    if (ext == '.html' || ext == '.css') return Colors.orange.shade600;
+    if (ext == '.json' || ext == '.yaml') return Colors.purple.shade600;
+    if (ext == '.md') return Colors.blueGrey.shade600;
+
+    return colorScheme.onSurface.addOpacity(0.7);
+  }
+
+  /// Build status indicator for file
+  static Widget? buildStatusIndicator(BuildContext context, ScannedFile file) {
+    if (file.isDirty) {
+      return Tooltip(
+        message: 'Modified',
+        child: Icon(
+          Icons.edit,
+          size: 14,
+          color: Colors.orange.shade700,
+        ),
+      );
+    }
+
+    if (file.error != null) {
+      return Tooltip(
+        message: file.error,
+        child: Icon(
+          Icons.error_outline,
+          size: 14,
+          color: Theme.of(context).colorScheme.error,
+        ),
+      );
+    }
+
+    if (file.isVirtual) {
+      return Tooltip(
+        message: 'Virtual file',
+        child: Icon(
+          Icons.add_circle_outline,
+          size: 14,
+          color: Colors.green.shade600,
+        ),
+      );
+    }
+
+    return null;
+  }
+
+  /// Get status text for file
+  static String getStatusText(ScannedFile file) {
+    if (file.error != null) return 'Error';
+    if (file.isVirtual) return 'Virtual';
+    if (file.isDirty) return 'Modified';
+    if (file.content != null) return 'Loaded';
+    return 'Pending';
+  }
+
+  /// Get status color for file
+  static Color getStatusColor(BuildContext context, ScannedFile file) {
+    final colorScheme = Theme.of(context).colorScheme;
+
+    if (file.error != null) return colorScheme.error;
+    if (file.isVirtual) return Colors.green;
+    if (file.isDirty) return Colors.orange;
+    if (file.content != null) return colorScheme.primary;
+    return colorScheme.onSurface.addOpacity(0.5);
+  }
+
+  /// Format file size for display
+  static String formatFileSize(int bytes) {
+    if (bytes < 1024) return '${bytes}B';
+    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)}KB';
+    if (bytes < 1024 * 1024 * 1024) {
+      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)}MB';
+    }
+    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)}GB';
+  }
+
+  /// Get language identifier for syntax highlighting
+  static String getLanguageId(String extension) {
+    final languageMap = {
+      '.dart': 'dart',
+      '.py': 'python',
+      '.js': 'javascript',
+      '.ts': 'typescript',
+      '.java': 'java',
+      '.cpp': 'cpp',
+      '.c': 'c',
+      '.cs': 'csharp',
+      '.go': 'go',
+      '.rs': 'rust',
+      '.rb': 'ruby',
+      '.php': 'php',
+      '.swift': 'swift',
+      '.kt': 'kotlin',
+      '.html': 'html',
+      '.css': 'css',
+      '.scss': 'scss',
+      '.json': 'json',
+      '.yaml': 'yaml',
+      '.yml': 'yaml',
+      '.xml': 'xml',
+      '.md': 'markdown',
+      '.sql': 'sql',
+      '.sh': 'shell',
+      '.bash': 'shell',
+      '.ps1': 'powershell',
+      '.bat': 'batch',
+    };
+
+    return languageMap[extension.toLowerCase()] ?? 'plaintext';
+  }
+
+  /// Get display name for a file (handles virtual files and VS Code temp files)
+  static String getDisplayName(ScannedFile file) {
+    return file.isVirtual ? file.name : (file.displayPath ?? file.name);
+  }
+
+  /// Get language for syntax highlighting from a file
+  static String getLanguageFromFile(ScannedFile file) {
+    return file.extension.isEmpty ? 'plaintext' : getLanguageId(file.extension);
+  }
+
+  /// Get the best path to display for a file
+  /// Priority: displayPath > relativePath > fullPath
+  static String getPathForDisplay(ScannedFile file) {
+    return file.displayPath ?? file.relativePath ?? file.fullPath;
+  }
+
+  /// Comprehensive extension catalog - single source of truth
+  static const Map<String, FileCategory> extensionCatalog = {
+    // Programming Languages
+    '.dart': FileCategory.programming,
+    '.py': FileCategory.programming,
+    '.js': FileCategory.programming,
+    '.ts': FileCategory.programming,
+    '.java': FileCategory.programming,
+    '.cpp': FileCategory.programming,
+    '.c': FileCategory.programming,
+    '.cs': FileCategory.programming,
+    '.go': FileCategory.programming,
+    '.rs': FileCategory.programming,
+    '.rb': FileCategory.programming,
+    '.php': FileCategory.programming,
+    '.swift': FileCategory.programming,
+    '.kt': FileCategory.programming,
+    '.scala': FileCategory.programming,
+    '.r': FileCategory.programming,
+    '.m': FileCategory.programming,
+    '.h': FileCategory.programming,
+
+    // Web Technologies
+    '.html': FileCategory.web,
+    '.css': FileCategory.web,
+    '.scss': FileCategory.web,
+    '.sass': FileCategory.web,
+    '.less': FileCategory.web,
+    '.jsx': FileCategory.web,
+    '.tsx': FileCategory.web,
+    '.vue': FileCategory.web,
+    '.svelte': FileCategory.web,
+    '.astro': FileCategory.web,
+
+    // Data & Config
+    '.json': FileCategory.data,
+    '.yaml': FileCategory.data,
+    '.yml': FileCategory.data,
+    '.xml': FileCategory.data,
+    '.toml': FileCategory.data,
+    '.ini': FileCategory.data,
+    '.conf': FileCategory.data,
+    '.config': FileCategory.data,
+    '.env': FileCategory.data,
+    '.properties': FileCategory.data,
+
+    // Scripts
+    '.sh': FileCategory.script,
+    '.bash': FileCategory.script,
+    '.zsh': FileCategory.script,
+    '.fish': FileCategory.script,
+    '.ps1': FileCategory.script,
+    '.bat': FileCategory.script,
+    '.cmd': FileCategory.script,
+
+    // Documentation
+    '.md': FileCategory.documentation,
+    '.txt': FileCategory.documentation,
+    '.rst': FileCategory.documentation,
+    '.adoc': FileCategory.documentation,
+    '.tex': FileCategory.documentation,
+    '.doc': FileCategory.documentation,
+    '.docx': FileCategory.documentation,
+    '.pdf': FileCategory.documentation,
+
+    // Database
+    '.sql': FileCategory.database,
+    '.db': FileCategory.database,
+    '.sqlite': FileCategory.database,
+
+    // Data files
+    '.csv': FileCategory.data,
+    '.tsv': FileCategory.data,
+    '.xls': FileCategory.data,
+    '.xlsx': FileCategory.data,
+  };
+
+  /// Get file category for an extension
+  static FileCategory getCategoryForExtension(String extension) {
+    return extensionCatalog[extension.toLowerCase()] ?? FileCategory.other;
+  }
+
+  /// Get all supported extensions
+  static Set<String> get supportedExtensions => extensionCatalog.keys.toSet();
+
+  /// Get extensions for a specific category
+  static Set<String> getExtensionsForCategory(FileCategory category) {
+    return extensionCatalog.entries
+        .where((entry) => entry.value == category)
+        .map((entry) => entry.key)
+        .toSet();
+  }
+}
diff --git a/lib/src/features/scan/ui/file_list_screen.dart b/lib/src/features/scan/ui/file_list_screen.dart
new file mode 100644
index 0000000..2416a96
--- /dev/null
+++ b/lib/src/features/scan/ui/file_list_screen.dart
@@ -0,0 +1,79 @@
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+import '../../virtual_tree/providers/virtual_tree_provider.dart';
+import '../../virtual_tree/ui/virtual_tree_view.dart';
+import '../state/file_list_state.dart';
+
+/// Main file list screen (without drop zone - handled globally in editor)
+class FileListScreen extends ConsumerStatefulWidget {
+  const FileListScreen({super.key});
+
+  @override
+  ConsumerState<FileListScreen> createState() => _FileListScreenState();
+}
+
+class _FileListScreenState extends ConsumerState<FileListScreen> {
+  @override
+  void initState() {
+    super.initState();
+    // Connect virtual tree to scanner
+    WidgetsBinding.instance.addPostFrameCallback((_) {
+      ref
+          .read(selectionProvider.notifier)
+          .initializeVirtualTree(ref.read(virtualTreeProvider));
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final selectionState = ref.watch(selectionProvider);
+    final selectionNotifier = ref.read(selectionProvider.notifier);
+
+    // Listen for errors
+    ref.listen<SelectionState>(selectionProvider, (previous, next) {
+      if (next.error != null && next.error != previous?.error) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text(next.error!),
+            backgroundColor: Theme.of(context).colorScheme.error,
+            action: SnackBarAction(
+              label: 'Dismiss',
+              onPressed: selectionNotifier.clearError,
+            ),
+          ),
+        );
+      }
+    });
+
+    return selectionState.hasFiles
+        ? const VirtualTreeView()
+        : Center(
+            child: Column(
+              mainAxisAlignment: MainAxisAlignment.center,
+              children: [
+                Icon(
+                  Icons.folder_open,
+                  size: 64,
+                  color: Theme.of(context).colorScheme.primary.addOpacity(0.5),
+                ),
+                const SizedBox(height: 16),
+                Text(
+                  'Drop files or directories here',
+                  style: Theme.of(context).textTheme.headlineSmall,
+                ),
+                const SizedBox(height: 8),
+                Text(
+                  'Or use the buttons in the app bar',
+                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
+                    color: Theme.of(
+                      context,
+                    ).colorScheme.onSurface.addOpacity(0.6),
+                  ),
+                ),
+              ],
+            ),
+          );
+  }
+}
diff --git a/lib/src/features/scan/ui/home_screen_with_drop.dart b/lib/src/features/scan/ui/home_screen_with_drop.dart
new file mode 100644
index 0000000..8a38f05
--- /dev/null
+++ b/lib/src/features/scan/ui/home_screen_with_drop.dart
@@ -0,0 +1,590 @@
+import 'package:desktop_drop/desktop_drop.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:flutter_svg/flutter_svg.dart';
+import 'package:url_launcher/url_launcher.dart';
+
+import '../../../shared/consts.dart';
+import '../../settings/presentation/ui/settings_screen.dart';
+import '../state/file_list_state.dart';
+
+/// Beautiful home screen with drop zone functionality
+class HomeScreenWithDrop extends ConsumerStatefulWidget {
+  const HomeScreenWithDrop({super.key});
+
+  @override
+  ConsumerState<HomeScreenWithDrop> createState() => _HomeScreenWithDropState();
+}
+
+class _HomeScreenWithDropState extends ConsumerState<HomeScreenWithDrop> {
+  bool _isDragging = false;
+
+  @override
+  Widget build(BuildContext context) {
+    final selectionNotifier = ref.read(selectionProvider.notifier);
+    // State watching is no longer needed here since parent handles switching
+
+    // State is now handled by parent ScanContainer
+
+    return DropTarget(
+      onDragEntered: (_) => setState(() => _isDragging = true),
+      onDragExited: (_) => setState(() => _isDragging = false),
+      onDragDone: (details) async {
+        setState(() => _isDragging = false);
+        if (details.files.isNotEmpty) {
+          await selectionNotifier.processDroppedItems(
+            details.files,
+            context: context,
+          );
+        }
+      },
+      child: AnimatedContainer(
+        duration: const Duration(milliseconds: 200),
+        decoration: BoxDecoration(
+          color: _isDragging
+              ? Theme.of(context).colorScheme.primary.addOpacity(0.05)
+              : null,
+          border: _isDragging
+              ? Border.all(
+                  color: Theme.of(context).colorScheme.primary.addOpacity(0.3),
+                  width: 2,
+                )
+              : null,
+        ),
+        child: HomeScreenContent(isDragging: _isDragging),
+      ),
+    );
+  }
+}
+
+/// Beautiful home screen that serves as the landing page
+class HomeScreenContent extends ConsumerWidget {
+  const HomeScreenContent({this.isDragging = false, super.key});
+
+  final bool isDragging;
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final selectionNotifier = ref.read(selectionProvider.notifier);
+    final theme = Theme.of(context);
+    final isDark = theme.brightness == Brightness.dark;
+
+    return Scaffold(
+      backgroundColor: theme.colorScheme.surface,
+      appBar: AppBar(
+        title: Row(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            Container(
+              padding: const EdgeInsets.all(8),
+              decoration: BoxDecoration(
+                gradient: LinearGradient(
+                  colors: [
+                    theme.colorScheme.primary,
+                    theme.colorScheme.primary.addOpacity(0.8),
+                  ],
+                ),
+                borderRadius: BorderRadius.circular(10),
+              ),
+              child: const Icon(
+                Icons.collections_bookmark_rounded,
+                color: Colors.white,
+                size: 20,
+              ),
+            ),
+            const SizedBox(width: 12),
+            const Text('Context Collector'),
+          ],
+        ),
+        centerTitle: true,
+        actions: [
+          // GitHub button
+          IconButton(
+            onPressed: () async {
+              final githubUrl = Uri.parse(
+                'https://github.com/omar-hanafy/context_collector',
+              );
+              if (!await launchUrl(githubUrl)) {
+                if (context.mounted) {
+                  ScaffoldMessenger.of(context).showSnackBar(
+                    const SnackBar(content: Text('Could not open GitHub')),
+                  );
+                }
+              }
+            },
+            icon: SvgPicture.asset(
+              isDark ? AppAssets.githubLight : AppAssets.githubDark,
+              width: 20,
+              height: 20,
+            ),
+            tooltip: 'View on GitHub',
+          ),
+          // Buy Me a Coffee button
+          IconButton(
+            onPressed: () async {
+              final coffeeUrl = Uri.parse(
+                'https://www.buymeacoffee.com/omar.hanafy',
+              );
+              if (!await launchUrl(coffeeUrl)) {
+                if (context.mounted) {
+                  ScaffoldMessenger.of(context).showSnackBar(
+                    const SnackBar(
+                      content: Text('Could not open Buy Me a Coffee'),
+                    ),
+                  );
+                }
+              }
+            },
+            icon: SvgPicture.asset(
+              isDark ? AppAssets.logoLight : AppAssets.logoDark,
+              width: 20,
+              height: 20,
+            ),
+            tooltip: 'Buy Me a Coffee',
+          ),
+          // Settings button
+          IconButton(
+            onPressed: () {
+              Navigator.push(
+                context,
+                MaterialPageRoute<void>(builder: (_) => const SettingsScreen()),
+              );
+            },
+            icon: const Icon(Icons.settings_rounded),
+            tooltip: 'Settings',
+          ),
+          const SizedBox(width: 8),
+        ],
+      ),
+      body: Stack(
+        children: [
+          Center(
+            child: ConstrainedBox(
+              constraints: const BoxConstraints(maxWidth: 800),
+              child: SingleChildScrollView(
+                padding: const EdgeInsets.all(32),
+                child: Column(
+                  mainAxisAlignment: MainAxisAlignment.center,
+                  children: [
+                    // Main icon with drag indicator
+                    AnimatedContainer(
+                      duration: const Duration(milliseconds: 200),
+                      width: 120,
+                      height: 120,
+                      decoration: BoxDecoration(
+                        gradient: LinearGradient(
+                          colors: [
+                            theme.colorScheme.primary.addOpacity(
+                              isDragging ? 0.2 : 0.1,
+                            ),
+                            theme.colorScheme.primary.addOpacity(
+                              isDragging ? 0.1 : 0.05,
+                            ),
+                          ],
+                          begin: Alignment.topLeft,
+                          end: Alignment.bottomRight,
+                        ),
+                        borderRadius: BorderRadius.circular(30),
+                        border: isDragging
+                            ? Border.all(
+                                color: theme.colorScheme.primary.addOpacity(
+                                  0.3,
+                                ),
+                                width: 2,
+                              )
+                            : null,
+                      ),
+                      child: Icon(
+                        Icons.folder_open_rounded,
+                        size: isDragging ? 64 : 56,
+                        color: theme.colorScheme.primary,
+                      ),
+                    ),
+                    const SizedBox(height: 32),
+
+                    // Title
+                    Text(
+                      'Drop Your Files or Directories Here',
+                      style: theme.textTheme.headlineMedium?.copyWith(
+                        fontWeight: FontWeight.bold,
+                        color: theme.colorScheme.onSurface,
+                      ),
+                      textAlign: TextAlign.center,
+                    ),
+                    const SizedBox(height: 12),
+
+                    // Subtitle
+                    Text(
+                      'Drag and drop files or directories to combine their content\ninto a single, organized collection',
+                      style: theme.textTheme.bodyLarge?.copyWith(
+                        color: theme.colorScheme.onSurface.addOpacity(0.7),
+                      ),
+                      textAlign: TextAlign.center,
+                    ),
+                    const SizedBox(height: 40),
+
+                    // Action buttons row
+                    Wrap(
+                      spacing: 16,
+                      runSpacing: 16,
+                      alignment: WrapAlignment.center,
+                      children: [
+                        // Browse Files button
+                        FilledButton.icon(
+                          onPressed: () => selectionNotifier.pickFiles(context),
+                          icon: const Icon(Icons.file_open_rounded),
+                          label: const Text('Browse Files'),
+                          style: FilledButton.styleFrom(
+                            padding: const EdgeInsets.symmetric(
+                              horizontal: 24,
+                              vertical: 16,
+                            ),
+                            textStyle: const TextStyle(
+                              fontSize: 16,
+                              fontWeight: FontWeight.w600,
+                            ),
+                          ),
+                        ),
+                        // Browse Folder button
+                        OutlinedButton.icon(
+                          onPressed: () =>
+                              selectionNotifier.pickDirectory(context),
+                          icon: const Icon(Icons.folder_open_rounded),
+                          label: const Text('Browse Folder'),
+                          style: OutlinedButton.styleFrom(
+                            padding: const EdgeInsets.symmetric(
+                              horizontal: 24,
+                              vertical: 16,
+                            ),
+                            textStyle: const TextStyle(
+                              fontSize: 16,
+                              fontWeight: FontWeight.w600,
+                            ),
+                          ),
+                        ),
+                      ],
+                    ),
+                    const SizedBox(height: 16),
+
+                    // Supported Formats button
+                    TextButton.icon(
+                      onPressed: () => _showSupportedFormats(context),
+                      icon: const Icon(Icons.help_outline_rounded, size: 18),
+                      label: const Text('Supported Formats'),
+                      style: TextButton.styleFrom(
+                        padding: const EdgeInsets.symmetric(
+                          horizontal: 16,
+                          vertical: 12,
+                        ),
+                      ),
+                    ),
+                    const SizedBox(height: 64),
+
+                    // Features grid
+                    _buildFeatureGrid(context),
+                  ],
+                ),
+              ),
+            ),
+          ),
+
+          // Dragging overlay
+          if (isDragging)
+            Positioned.fill(
+              child: IgnorePointer(
+                child: ColoredBox(
+                  color: theme.colorScheme.primary.addOpacity(0.05),
+                  child: Center(
+                    child: Container(
+                      padding: const EdgeInsets.all(32),
+                      decoration: BoxDecoration(
+                        color: theme.colorScheme.surface,
+                        borderRadius: BorderRadius.circular(20),
+                        boxShadow: [
+                          BoxShadow(
+                            color: theme.colorScheme.shadow.addOpacity(0.1),
+                            blurRadius: 20,
+                            offset: const Offset(0, 10),
+                          ),
+                        ],
+                      ),
+                      child: Column(
+                        mainAxisSize: MainAxisSize.min,
+                        children: [
+                          Icon(
+                            Icons.file_download_outlined,
+                            size: 48,
+                            color: theme.colorScheme.primary,
+                          ),
+                          const SizedBox(height: 16),
+                          Text(
+                            'Drop to add files',
+                            style: theme.textTheme.titleLarge?.copyWith(
+                              fontWeight: FontWeight.bold,
+                            ),
+                          ),
+                        ],
+                      ),
+                    ),
+                  ),
+                ),
+              ),
+            ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildFeatureGrid(BuildContext context) {
+    final theme = Theme.of(context);
+
+    final features = [
+      (
+        icon: Icons.code_rounded,
+        title: 'All Text Files',
+        description: 'Supports any text-based file format',
+        color: Colors.blue,
+      ),
+      (
+        icon: Icons.link_rounded,
+        title: 'File References',
+        description: 'Includes path & metadata for AI context',
+        color: Colors.green,
+      ),
+      (
+        icon: Icons.content_copy_rounded,
+        title: 'Quick Copy',
+        description: 'One-click copy to clipboard',
+        color: Colors.orange,
+      ),
+      (
+        icon: Icons.edit_note_rounded,
+        title: 'Code Editor',
+        description: 'View and edit with Monaco editor',
+        color: Colors.purple,
+      ),
+    ];
+
+    return LayoutBuilder(
+      builder: (context, constraints) {
+        final crossAxisCount = constraints.maxWidth > 600 ? 2 : 1;
+        final itemWidth =
+            (constraints.maxWidth - 16 * (crossAxisCount - 1)) / crossAxisCount;
+
+        return Wrap(
+          spacing: 16,
+          runSpacing: 16,
+          children: features.map((feature) {
+            return SizedBox(
+              width: itemWidth,
+              child: Card(
+                elevation: 0,
+                shape: RoundedRectangleBorder(
+                  borderRadius: BorderRadius.circular(16),
+                  side: BorderSide(
+                    color: theme.colorScheme.outline.addOpacity(0.2),
+                  ),
+                ),
+                child: Padding(
+                  padding: const EdgeInsets.all(20),
+                  child: Row(
+                    children: [
+                      Container(
+                        width: 48,
+                        height: 48,
+                        decoration: BoxDecoration(
+                          color: feature.color.addOpacity(0.1),
+                          borderRadius: BorderRadius.circular(12),
+                        ),
+                        child: Icon(
+                          feature.icon,
+                          color: feature.color,
+                          size: 24,
+                        ),
+                      ),
+                      const SizedBox(width: 16),
+                      Expanded(
+                        child: Column(
+                          crossAxisAlignment: CrossAxisAlignment.start,
+                          children: [
+                            Text(
+                              feature.title,
+                              style: theme.textTheme.titleSmall?.copyWith(
+                                fontWeight: FontWeight.bold,
+                              ),
+                            ),
+                            const SizedBox(height: 4),
+                            Text(
+                              feature.description,
+                              style: theme.textTheme.bodySmall?.copyWith(
+                                color: theme.colorScheme.onSurface.addOpacity(
+                                  0.6,
+                                ),
+                              ),
+                            ),
+                          ],
+                        ),
+                      ),
+                    ],
+                  ),
+                ),
+              ),
+            );
+          }).toList(),
+        );
+      },
+    );
+  }
+
+  Future<void> _showSupportedFormats(BuildContext context) async {
+    final theme = Theme.of(context);
+
+    await showDialog<void>(
+      context: context,
+      builder: (context) => Dialog(
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.circular(20),
+        ),
+        child: Container(
+          constraints: const BoxConstraints(
+            maxWidth: 600,
+            maxHeight: 700,
+          ),
+          child: Column(
+            mainAxisSize: MainAxisSize.min,
+            children: [
+              // Header
+              Container(
+                padding: const EdgeInsets.all(24),
+                decoration: BoxDecoration(
+                  color: theme.colorScheme.primary.addOpacity(0.05),
+                  borderRadius: const BorderRadius.only(
+                    topLeft: Radius.circular(20),
+                    topRight: Radius.circular(20),
+                  ),
+                ),
+                child: Row(
+                  children: [
+                    Icon(
+                      Icons.file_present_rounded,
+                      color: theme.colorScheme.primary,
+                      size: 28,
+                    ),
+                    const SizedBox(width: 12),
+                    Text(
+                      'Supported File Formats',
+                      style: theme.textTheme.headlineSmall?.copyWith(
+                        fontWeight: FontWeight.bold,
+                      ),
+                    ),
+                    const Spacer(),
+                    IconButton(
+                      onPressed: () => Navigator.of(context).pop(),
+                      icon: const Icon(Icons.close_rounded),
+                      style: IconButton.styleFrom(
+                        backgroundColor: theme.colorScheme.surface,
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+              // Content
+              Flexible(
+                child: SingleChildScrollView(
+                  padding: const EdgeInsets.all(24),
+                  child: Column(
+                    crossAxisAlignment: CrossAxisAlignment.start,
+                    children: [
+                      Text(
+                        'Context Collector supports all text-based files. '
+                        'Simply drop any file and it will try to read it as text. '
+                        'Binary files will be automatically skipped.\n\n'
+                        'You can blacklist specific extensions in Settings to exclude them from scanning.',
+                        style: theme.textTheme.bodyLarge,
+                      ),
+                      const SizedBox(height: 24),
+                      Text(
+                        'Common Examples:',
+                        style: theme.textTheme.titleMedium?.copyWith(
+                          fontWeight: FontWeight.bold,
+                        ),
+                      ),
+                      const SizedBox(height: 16),
+                      Wrap(
+                        spacing: 8,
+                        runSpacing: 8,
+                        children:
+                            [
+                                  '.dart',
+                                  '.py',
+                                  '.js',
+                                  '.ts',
+                                  '.java',
+                                  '.cpp',
+                                  '.go',
+                                  '.html',
+                                  '.css',
+                                  '.json',
+                                  '.yaml',
+                                  '.xml',
+                                  '.md',
+                                  '.txt',
+                                  '.sh',
+                                  '.sql',
+                                  '.rs',
+                                  '.swift',
+                                  '.kt',
+                                ]
+                                .map(
+                                  (ext) => Chip(
+                                    label: Text(
+                                      ext,
+                                      style: const TextStyle(
+                                        fontFamily: 'monospace',
+                                      ),
+                                    ),
+                                    backgroundColor: theme.colorScheme.primary
+                                        .addOpacity(0.1),
+                                  ),
+                                )
+                                .toList(),
+                      ),
+                    ],
+                  ),
+                ),
+              ),
+              // Footer
+              Container(
+                padding: const EdgeInsets.all(16),
+                decoration: BoxDecoration(
+                  color: theme.colorScheme.surface,
+                  borderRadius: const BorderRadius.only(
+                    bottomLeft: Radius.circular(20),
+                    bottomRight: Radius.circular(20),
+                  ),
+                ),
+                child: Row(
+                  children: [
+                    Icon(
+                      Icons.info_outline_rounded,
+                      size: 16,
+                      color: theme.colorScheme.onSurface.addOpacity(0.6),
+                    ),
+                    const SizedBox(width: 8),
+                    Text(
+                      'All text files are supported',
+                      style: theme.textTheme.bodySmall?.copyWith(
+                        color: theme.colorScheme.onSurface.addOpacity(0.6),
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/settings/domain/extension_prefs.dart b/lib/src/features/settings/domain/extension_prefs.dart
index 16af3f8..d10fa87 100644
--- a/lib/src/features/settings/domain/extension_prefs.dart
+++ b/lib/src/features/settings/domain/extension_prefs.dart
@@ -1,4 +1,5 @@
-import 'package:context_collector/src/shared/utils/extension_catalog.dart';
+import 'package:context_collector/src/features/scan/models/file_category.dart';
+import 'package:context_collector/src/features/scan/ui/file_display_helper.dart';
 import 'package:dart_helper_utils/dart_helper_utils.dart';
 import 'package:flutter/foundation.dart';
 
@@ -45,7 +46,7 @@ class ExtensionPrefs {
       final categoryName = entry.value.toString();
       final category =
           FileCategory.values.firstWhereOrNull((c) => c.name == categoryName) ??
-              FileCategory.other;
+          FileCategory.other;
 
       result[entry.key] = category;
     }
@@ -81,7 +82,7 @@ class ExtensionPrefs {
   /// Get all active extensions (catalog defaults + custom - disabled)
   Map<String, FileCategory> get activeExtensions {
     final result = Map<String, FileCategory>.from(
-      ExtensionCatalog.extensionCategories,
+      FileDisplayHelper.extensionCatalog,
     );
 
     // Remove disabled extensions
@@ -154,8 +155,9 @@ class ExtensionPrefs {
 
     // Count by category
     for (final category in FileCategory.values) {
-      final count =
-          activeExtensions.values.where((cat) => cat == category).length;
+      final count = activeExtensions.values
+          .where((cat) => cat == category)
+          .length;
       if (count > 0) {
         stats[category.name] = count;
       }
@@ -188,7 +190,9 @@ class ExtensionPrefs {
           .map((e) => Object.hash(e.key, e.value))
           .fold(0, (a, b) => a is num ? a.toInt() ^ b : 0),
       disabledExtensions.fold(
-          0, (a, b) => a is num ? a.toInt() ^ b.hashCode : 0),
+        0,
+        (a, b) => a is num ? a.toInt() ^ b.hashCode : 0,
+      ),
     );
   }
 
diff --git a/lib/src/features/settings/domain/filter_settings.dart b/lib/src/features/settings/domain/filter_settings.dart
new file mode 100644
index 0000000..6d9235e
--- /dev/null
+++ b/lib/src/features/settings/domain/filter_settings.dart
@@ -0,0 +1,84 @@
+import 'package:dart_helper_utils/dart_helper_utils.dart';
+import 'package:flutter/foundation.dart';
+
+/// Manages a simple blacklist of file extensions to be ignored during scans.
+@immutable
+class FilterSettings {
+  /// A default set of extensions that are typically not useful for context collection.
+  static const Set<String> defaultBlacklist = {
+    // System & Editor Junk
+    '.ds_store',
+    'thumbs.db',
+
+    // Logs & Temporary Files
+    '.log',
+    '.tmp',
+    '.bak',
+    '.swp',
+
+    // Dart/Flutter Generated Files
+    '.g.dart',
+    '.freezed.dart',
+    '.gr.dart',
+    '.reflectable.dart',
+    '_test.reflectable.dart',
+
+    // Compiled Code & Artifacts
+    '.exe', '.dll', '.so', '.o', '.a', // Generic binaries
+    '.pyc', // Python
+    '.class', '.jar', // Java/JVM
+    '.map', // Source Maps
+    // Common Non-Code / Media Files
+    '.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico',
+    '.mp4', '.mov', '.mp3', '.wav',
+    '.pdf',
+    '.zip', '.rar', '.gz', '.7z',
+    '.svg',
+
+    // Dependency Lock Files (very noisy)
+    'package-lock.json',
+    'yarn.lock',
+    'pubspec.lock',
+    'composer.lock',
+    'gemfile.lock',
+    'podfile.lock',
+  };
+
+  const FilterSettings({
+    this.blacklistedExtensions = defaultBlacklist,
+  });
+
+  factory FilterSettings.fromJson(Map<String, dynamic> json) {
+    final extensions = json.tryGetList<String>('blacklistedExtensions');
+    return FilterSettings(
+      blacklistedExtensions: extensions?.toSet() ?? defaultBlacklist,
+    );
+  }
+
+  /// The set of file extensions (e.g., '.log') to ignore.
+  final Set<String> blacklistedExtensions;
+
+  Map<String, dynamic> toJson() {
+    return {
+      'blacklistedExtensions': blacklistedExtensions.toList(),
+    };
+  }
+
+  FilterSettings copyWith({
+    Set<String>? blacklistedExtensions,
+  }) {
+    return FilterSettings(
+      blacklistedExtensions:
+          blacklistedExtensions ?? this.blacklistedExtensions,
+    );
+  }
+
+  @override
+  bool operator ==(Object other) =>
+      identical(this, other) ||
+      other is FilterSettings &&
+          setEquals(other.blacklistedExtensions, blacklistedExtensions);
+
+  @override
+  int get hashCode => Object.hashAll(blacklistedExtensions);
+}
diff --git a/lib/src/features/settings/presentation/state/preferences_notifier.dart b/lib/src/features/settings/presentation/state/preferences_notifier.dart
index 08b5b0f..66f372b 100644
--- a/lib/src/features/settings/presentation/state/preferences_notifier.dart
+++ b/lib/src/features/settings/presentation/state/preferences_notifier.dart
@@ -1,74 +1,53 @@
-import 'package:context_collector/context_collector.dart';
+import 'dart:convert';
+
+import 'package:context_collector/src/features/settings/domain/filter_settings.dart';
 import 'package:flutter/foundation.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:shared_preferences/shared_preferences.dart';
 
 // Provider for the PreferencesNotifier
 final preferencesProvider =
-    StateNotifierProvider<PreferencesNotifier, ExtensionPrefsWithLoading>(
-  (ref) => PreferencesNotifier(),
-);
+    StateNotifierProvider<PreferencesNotifier, FilterSettingsWithLoading>(
+      (ref) => PreferencesNotifier(),
+    );
 
 // State class to include loading status
-class ExtensionPrefsWithLoading {
-  const ExtensionPrefsWithLoading({
-    this.prefs = const ExtensionPrefs(),
+class FilterSettingsWithLoading {
+  const FilterSettingsWithLoading({
+    this.settings = const FilterSettings(),
     this.isLoading = true,
   });
-  final ExtensionPrefs prefs;
+  final FilterSettings settings;
   final bool isLoading;
 
-  ExtensionPrefsWithLoading copyWith({
-    ExtensionPrefs? prefs,
+  FilterSettingsWithLoading copyWith({
+    FilterSettings? settings,
     bool? isLoading,
   }) {
-    return ExtensionPrefsWithLoading(
-      prefs: prefs ?? this.prefs,
+    return FilterSettingsWithLoading(
+      settings: settings ?? this.settings,
       isLoading: isLoading ?? this.isLoading,
     );
   }
 }
 
-class PreferencesNotifier extends StateNotifier<ExtensionPrefsWithLoading> {
-  PreferencesNotifier() : super(const ExtensionPrefsWithLoading()) {
+class PreferencesNotifier extends StateNotifier<FilterSettingsWithLoading> {
+  PreferencesNotifier() : super(const FilterSettingsWithLoading()) {
     _loadPreferences();
   }
 
-  static const String _prefsKey = 'extension_preferences';
-
-  // Getters for convenience, accessing prefs from the state object
-  ExtensionPrefs get _prefs => state.prefs;
-  Map<String, FileCategory> get activeExtensions => _prefs.activeExtensions;
-
-  Map<FileCategory, List<MapEntry<String, bool>>> get groupedExtensions {
-    final result = <FileCategory, List<MapEntry<String, bool>>>{};
-
-    for (final entry in ExtensionCatalog.extensionCategories.entries) {
-      final category = entry.value;
-      final isEnabled = !_prefs.disabledExtensions.contains(entry.key);
-      result.putIfAbsent(category, () => []);
-      result[category]!.add(MapEntry(entry.key, isEnabled));
-    }
-
-    for (final entry in _prefs.customExtensions.entries) {
-      final category = entry.value;
-      result.putIfAbsent(category, () => []);
-      result[category]!.add(MapEntry(entry.key, true));
-    }
-
-    for (final list in result.values) {
-      list.sort((a, b) => a.key.compareTo(b.key));
-    }
-    return result;
-  }
+  static const String _prefsKey = 'filter_settings';
 
   Future<void> _loadPreferences() async {
     try {
       final sharedPrefs = await SharedPreferences.getInstance();
       final prefsJson = sharedPrefs.getString(_prefsKey);
       if (prefsJson != null) {
+        final json = jsonDecode(prefsJson) as Map<String, dynamic>;
         state = state.copyWith(
-            prefs: ExtensionPrefs.fromJsonString(prefsJson), isLoading: false);
+          settings: FilterSettings.fromJson(json),
+          isLoading: false,
+        );
       } else {
         state = state.copyWith(isLoading: false);
       }
@@ -81,64 +60,36 @@ class PreferencesNotifier extends StateNotifier<ExtensionPrefsWithLoading> {
   Future<void> _savePreferences() async {
     try {
       final sharedPrefs = await SharedPreferences.getInstance();
-      await sharedPrefs.setString(_prefsKey, state.prefs.encode());
+      final json = state.settings.toJson();
+      await sharedPrefs.setString(_prefsKey, jsonEncode(json));
     } catch (e) {
       debugPrint('Error saving preferences: $e');
     }
   }
 
-  Future<void> toggleExtension(String extension) async {
-    ExtensionPrefs newPrefs;
-    final isDefault =
-        ExtensionCatalog.extensionCategories.containsKey(extension);
-
-    if (isDefault) {
-      if (_prefs.disabledExtensions.contains(extension)) {
-        newPrefs = _prefs.enableExtension(extension);
-      } else {
-        newPrefs = _prefs.disableExtension(extension);
-      }
-    } else {
-      newPrefs = _prefs.removeCustomExtension(extension);
+  Future<void> addToBlacklist(String pattern) async {
+    if (pattern.isEmpty) {
+      throw ArgumentError('Pattern cannot be empty.');
     }
-    state = state.copyWith(prefs: newPrefs);
+    final newSet = Set<String>.from(state.settings.blacklistedExtensions)
+      ..add(pattern.toLowerCase());
+    state = state.copyWith(
+      settings: state.settings.copyWith(blacklistedExtensions: newSet),
+    );
     await _savePreferences();
   }
 
-  Future<void> addCustomExtension(
-      String extension, FileCategory category) async {
-    if (extension.isEmpty || !extension.startsWith('.')) {
-      throw ArgumentError('Invalid extension format');
-    }
-    final ext = extension.toLowerCase();
-    if (ExtensionCatalog.extensionCategories.containsKey(ext) ||
-        _prefs.customExtensions.containsKey(ext)) {
-      throw ArgumentError('Extension already exists');
-    }
-
-    var newPrefs = _prefs.addCustomExtension(ext, category);
-    if (newPrefs.disabledExtensions.contains(ext)) {
-      newPrefs = newPrefs.enableExtension(ext);
-    }
-    state = state.copyWith(prefs: newPrefs);
+  Future<void> removeFromBlacklist(String extension) async {
+    final newSet = Set<String>.from(state.settings.blacklistedExtensions)
+      ..remove(extension.toLowerCase());
+    state = state.copyWith(
+      settings: state.settings.copyWith(blacklistedExtensions: newSet),
+    );
     await _savePreferences();
   }
 
   Future<void> resetToDefaults() async {
-    state = state.copyWith(prefs: const ExtensionPrefs());
-    await _savePreferences();
-  }
-
-  Future<void> enableAll() async {
-    state = state.copyWith(prefs: _prefs.copyWith(disabledExtensions: {}));
-    await _savePreferences();
-  }
-
-  Future<void> disableAll() async {
-    state = state.copyWith(
-        prefs: _prefs.copyWith(
-      disabledExtensions: ExtensionCatalog.extensionCategories.keys.toSet(),
-    ));
+    state = state.copyWith(settings: const FilterSettings());
     await _savePreferences();
   }
 }
diff --git a/lib/src/features/settings/presentation/ui/settings_screen.dart b/lib/src/features/settings/presentation/ui/settings_screen.dart
index c979e8c..67eca4e 100644
--- a/lib/src/features/settings/presentation/ui/settings_screen.dart
+++ b/lib/src/features/settings/presentation/ui/settings_screen.dart
@@ -1,13 +1,12 @@
+import 'dart:async';
 import 'dart:io';
 
-import 'package:context_collector/src/features/settings/presentation/state/preferences_notifier.dart';
-import 'package:context_collector/src/features/settings/presentation/state/theme_notifier.dart';
-import 'package:context_collector/src/features/settings/services/auto_updater_service.dart';
-import 'package:context_collector/src/shared/theme/extensions.dart';
-import 'package:context_collector/src/shared/utils/extension_catalog.dart';
+import 'package:context_collector/context_collector.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter/services.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:package_info_plus/package_info_plus.dart';
 
 class SettingsScreen extends ConsumerStatefulWidget {
   const SettingsScreen({super.key});
@@ -19,9 +18,9 @@ class SettingsScreen extends ConsumerStatefulWidget {
 class _SettingsScreenState extends ConsumerState<SettingsScreen>
     with SingleTickerProviderStateMixin {
   final _extensionController = TextEditingController();
-  FileCategory _selectedCategory = FileCategory.other;
   final _formKey = GlobalKey<FormState>();
   late TabController _tabController;
+  PackageInfo? _packageInfo;
 
   @override
   void initState() {
@@ -29,6 +28,16 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
     // Add Updates tab only on supported platforms
     final tabCount = (Platform.isMacOS || Platform.isWindows) ? 3 : 2;
     _tabController = TabController(length: tabCount, vsync: this);
+    _loadPackageInfo();
+  }
+
+  Future<void> _loadPackageInfo() async {
+    final info = await PackageInfo.fromPlatform();
+    if (mounted) {
+      setState(() {
+        _packageInfo = info;
+      });
+    }
   }
 
   @override
@@ -38,127 +47,6 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
     super.dispose();
   }
 
-  Future<void> _showAddExtensionDialog(BuildContext context) async {
-    final notifier = ref.read(preferencesProvider.notifier);
-    final currentPrefs = ref.read(preferencesProvider).prefs;
-
-    await showDialog<void>(
-      context: context,
-      builder: (dialogContext) => AlertDialog(
-        title: const Text('Add Custom Extension'),
-        content: Form(
-          key: _formKey,
-          child: Column(
-            mainAxisSize: MainAxisSize.min,
-            children: [
-              TextFormField(
-                controller: _extensionController,
-                decoration: const InputDecoration(
-                  labelText: 'Extension',
-                  hintText: '.example',
-                  prefixIcon: Icon(Icons.extension_rounded),
-                ),
-                inputFormatters: [
-                  TextInputFormatter.withFunction((oldValue, newValue) {
-                    final text = newValue.text;
-                    if (text.isEmpty) return newValue;
-                    if (!text.startsWith('.')) {
-                      return TextEditingValue(
-                        text: '.$text',
-                        selection:
-                            TextSelection.collapsed(offset: text.length + 1),
-                      );
-                    }
-                    return newValue;
-                  }),
-                ],
-                validator: (value) {
-                  if (value == null || value.isEmpty || value == '.') {
-                    return 'Please enter a valid extension';
-                  }
-                  if (!value.startsWith('.')) {
-                    return 'Extension must start with a dot';
-                  }
-                  if (currentPrefs.activeExtensions
-                      .containsKey(value.toLowerCase())) {
-                    return 'Extension already exists';
-                  }
-                  return null;
-                },
-              ),
-              const SizedBox(height: 16),
-              DropdownButtonFormField<FileCategory>(
-                value: _selectedCategory,
-                decoration: const InputDecoration(
-                  labelText: 'Category',
-                  prefixIcon: Icon(Icons.category_rounded),
-                ),
-                items: FileCategory.values.map((category) {
-                  return DropdownMenuItem(
-                    value: category,
-                    child: Row(
-                      children: [
-                        Icon(
-                          category.icon,
-                          size: 20,
-                          color: context.isDark ? Colors.white : Colors.black,
-                        ),
-                        const SizedBox(width: 8),
-                        Text(category.displayName),
-                      ],
-                    ),
-                  );
-                }).toList(),
-                onChanged: (value) {
-                  if (value != null) {
-                    setState(() => _selectedCategory = value);
-                  }
-                },
-              ),
-            ],
-          ),
-        ),
-        actions: [
-          TextButton(
-            onPressed: () => Navigator.pop(dialogContext),
-            child: const Text('Cancel'),
-          ),
-          FilledButton(
-            onPressed: () async {
-              if (_formKey.currentState!.validate()) {
-                try {
-                  await notifier.addCustomExtension(
-                    _extensionController.text.toLowerCase(),
-                    _selectedCategory,
-                  );
-                  if (mounted) {
-                    Navigator.pop(dialogContext);
-                    _extensionController.clear();
-                    ScaffoldMessenger.of(context).showSnackBar(
-                      const SnackBar(
-                        content: Text('Extension added successfully'),
-                      ),
-                    );
-                  }
-                } catch (e) {
-                  if (mounted) {
-                    ScaffoldMessenger.of(context).showSnackBar(
-                      SnackBar(
-                        content: Text('Error: $e'),
-                        backgroundColor: context.error,
-                      ),
-                    );
-                  }
-                }
-              }
-            },
-            child: const Text('Add'),
-          ),
-        ],
-      ),
-    );
-  }
-
   @override
   Widget build(BuildContext context) {
     final prefsState = ref.watch(preferencesProvider);
@@ -195,62 +83,52 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
 
   Widget _buildGeneralSettings(BuildContext context, ThemeMode currentTheme) {
     return ListView(
-      padding: const EdgeInsets.all(16),
+      padding: DsDimensions.paddingMedium,
       children: [
-        Card(
-          child: Padding(
-            padding: const EdgeInsets.all(16),
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Row(
-                  children: [
-                    Icon(
-                      Icons.palette_rounded,
-                      color: context.primary,
-                    ),
-                    const SizedBox(width: 12),
-                    Text(
-                      'Appearance',
-                      style: context.titleMedium?.copyWith(
-                        fontWeight: FontWeight.bold,
-                      ),
-                    ),
-                  ],
-                ),
-                const SizedBox(height: 16),
-                Text(
-                  'Theme Mode',
-                  style: context.titleSmall,
-                ),
-                const SizedBox(height: 8),
-                SegmentedButton<ThemeMode>(
-                  segments: const [
-                    ButtonSegment<ThemeMode>(
-                      value: ThemeMode.system,
-                      label: Text('System'),
-                      icon: Icon(Icons.settings_brightness_rounded),
-                    ),
-                    ButtonSegment<ThemeMode>(
-                      value: ThemeMode.light,
-                      label: Text('Light'),
-                      icon: Icon(Icons.light_mode_rounded),
-                    ),
-                    ButtonSegment<ThemeMode>(
-                      value: ThemeMode.dark,
-                      label: Text('Dark'),
-                      icon: Icon(Icons.dark_mode_rounded),
-                    ),
-                  ],
-                  selected: {currentTheme},
-                  onSelectionChanged: (Set<ThemeMode> selection) {
-                    ref
-                        .read(themeProvider.notifier)
-                        .setThemeMode(selection.first);
-                  },
+        DsCard(
+          child: Column(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              DsSectionHeader(
+                title: 'Appearance',
+                trailing: Icon(
+                  Icons.palette_rounded,
+                  color: context.primary,
+                  size: DesignSystem.iconSizeMedium,
                 ),
-              ],
-            ),
+              ),
+              context.ds.spaceHeight(DesignSystem.space16),
+              Text(
+                'Theme Mode',
+                style: context.titleSmall,
+              ),
+              context.ds.spaceHeight(DesignSystem.space8),
+              SegmentedButton<ThemeMode>(
+                segments: const [
+                  ButtonSegment<ThemeMode>(
+                    value: ThemeMode.system,
+                    label: Text('System'),
+                    icon: Icon(Icons.settings_brightness_rounded),
+                  ),
+                  ButtonSegment<ThemeMode>(
+                    value: ThemeMode.light,
+                    label: Text('Light'),
+                    icon: Icon(Icons.light_mode_rounded),
+                  ),
+                  ButtonSegment<ThemeMode>(
+                    value: ThemeMode.dark,
+                    label: Text('Dark'),
+                    icon: Icon(Icons.dark_mode_rounded),
+                  ),
+                ],
+                selected: {currentTheme},
+                onSelectionChanged: (Set<ThemeMode> selection) {
+                  ref
+                      .read(themeProvider.notifier)
+                      .setThemeMode(selection.first);
+                },
+              ),
+            ],
           ),
         ),
       ],
@@ -259,11 +137,19 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
 
   Widget _buildExtensionsSettings(
     BuildContext context,
-    ExtensionPrefsWithLoading prefsState,
+    FilterSettingsWithLoading prefsState,
     PreferencesNotifier notifier,
   ) {
+    if (prefsState.isLoading) {
+      return const Center(child: CircularProgressIndicator());
+    }
+
+    final blacklist = prefsState.settings.blacklistedExtensions.toList()
+      ..sort();
+
     return Column(
       children: [
+        // Header section with add extension form
         Container(
           padding: const EdgeInsetsDirectional.all(16),
           color: context.surfaceContainerHighest,
@@ -273,203 +159,145 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
               Row(
                 children: [
                   Text(
-                    'Customize Supported File Extensions',
-                    style: context.titleMedium?.copyWith(
-                      fontWeight: FontWeight.bold,
-                    ),
+                    'Blacklisted Extensions',
+                    style: context.titleBold,
                   ),
                   const Spacer(),
-                  PopupMenuButton<String>(
-                    icon: const Icon(Icons.more_vert_rounded),
-                    onSelected: (value) async {
-                      switch (value) {
-                        case 'enable_all':
-                          await notifier.enableAll();
-                          if (mounted) {
-                            ScaffoldMessenger.of(context).showSnackBar(
-                              const SnackBar(
-                                content: Text('All extensions enabled'),
-                              ),
-                            );
-                          }
-                        case 'disable_all':
-                          await notifier.disableAll();
-                          if (mounted) {
-                            ScaffoldMessenger.of(context).showSnackBar(
-                              const SnackBar(
-                                content:
-                                    Text('All default extensions disabled'),
-                              ),
-                            );
-                          }
-                        case 'reset':
-                          await showDialog<void>(
-                            context: context,
-                            builder: (dialogContext) => AlertDialog(
-                              title: const Text('Reset to Defaults'),
-                              content: const Text(
-                                'This will remove all custom extensions and reset all settings to default. Are you sure?',
+                  TextButton(
+                    onPressed: () async {
+                      final confirm = await showDialog<bool>(
+                        context: context,
+                        builder: (dialogContext) => AlertDialog(
+                          title: const Text('Reset to Defaults'),
+                          content: const Text(
+                            'This will reset the blacklist to default settings. Are you sure?',
+                          ),
+                          actions: [
+                            TextButton(
+                              onPressed: () =>
+                                  Navigator.pop(dialogContext, false),
+                              child: const Text('Cancel'),
+                            ),
+                            FilledButton(
+                              onPressed: () =>
+                                  Navigator.pop(dialogContext, true),
+                              style: FilledButton.styleFrom(
+                                backgroundColor: context.error,
                               ),
-                              actions: [
-                                TextButton(
-                                  onPressed: () => Navigator.pop(dialogContext),
-                                  child: const Text('Cancel'),
-                                ),
-                                FilledButton(
-                                  onPressed: () async {
-                                    await notifier.resetToDefaults();
-                                    if (mounted) {
-                                      Navigator.pop(dialogContext);
-                                      ScaffoldMessenger.of(context)
-                                          .showSnackBar(
-                                        const SnackBar(
-                                          content: Text(
-                                              'Settings reset to defaults'),
-                                        ),
-                                      );
-                                    }
-                                  },
-                                  style: FilledButton.styleFrom(
-                                    backgroundColor: context.error,
-                                  ),
-                                  child: const Text('Reset'),
-                                ),
-                              ],
+                              child: const Text('Reset'),
                             ),
-                          );
-                      }
-                    },
-                    itemBuilder: (context) => [
-                      const PopupMenuItem(
-                        value: 'enable_all',
-                        child: Row(
-                          children: [
-                            Icon(Icons.check_circle_outline_rounded),
-                            SizedBox(width: 12),
-                            Text('Enable All'),
-                          ],
-                        ),
-                      ),
-                      const PopupMenuItem(
-                        value: 'disable_all',
-                        child: Row(
-                          children: [
-                            Icon(Icons.remove_circle_outline_rounded),
-                            SizedBox(width: 12),
-                            Text('Disable All Default'),
                           ],
                         ),
-                      ),
-                      const PopupMenuDivider(),
-                      const PopupMenuItem(
-                        value: 'reset',
-                        child: Row(
-                          children: [
-                            Icon(Icons.restore_rounded),
-                            SizedBox(width: 12),
-                            Text('Reset to Defaults'),
-                          ],
-                        ),
-                      ),
-                    ],
+                      );
+                      if (confirm == true) {
+                        await notifier.resetToDefaults();
+                        if (mounted) {
+                          context.showOk('Blacklist reset to defaults');
+                        }
+                      }
+                    },
+                    child: const Text('Reset to Default'),
                   ),
                 ],
               ),
-              const SizedBox(height: 8),
+              context.ds.spaceHeight(DesignSystem.space8),
               Text(
-                'Enable or disable file extensions for context collection. You can also add custom extensions.',
-                style: context.bodyMedium?.copyWith(
-                  color: context.onSurface.addOpacity(0.7),
-                ),
+                'Files matching these patterns will be ignored during scanning. '
+                'Supports extensions (.log), multi-part extensions (.g.dart), '
+                'and specific filenames (pubspec.lock).',
+                style: context.bodyMuted,
               ),
-              const SizedBox(height: 16),
-              FilledButton.icon(
-                onPressed: () => _showAddExtensionDialog(context),
-                icon: const Icon(Icons.add_rounded),
-                label: const Text('Add Custom Extension'),
+              context.ds.spaceHeight(DesignSystem.space16),
+              // Add new extension form
+              Form(
+                key: _formKey,
+                child: Row(
+                  children: [
+                    Expanded(
+                      child: TextFormField(
+                        controller: _extensionController,
+                        decoration: const InputDecoration(
+                          labelText: 'Pattern to blacklist',
+                          hintText: 'e.g., .log, .g.dart, pubspec.lock',
+                          prefixIcon: Icon(Icons.block_rounded),
+                          border: OutlineInputBorder(),
+                        ),
+                        // No input formatters - allow any pattern
+                        validator: (value) {
+                          if (value == null || value.isEmpty) {
+                            return 'Please enter a valid pattern';
+                          }
+                          if (blacklist.contains(value.toLowerCase())) {
+                            return 'Pattern already blacklisted';
+                          }
+                          return null;
+                        },
+                      ),
+                    ),
+                    const SizedBox(width: 12),
+                    FilledButton(
+                      onPressed: () async {
+                        if (_formKey.currentState!.validate()) {
+                          await notifier.addToBlacklist(
+                            _extensionController.text,
+                          );
+                          _extensionController.clear();
+                          if (mounted) {
+                            context.showOk('Extension added to blacklist');
+                          }
+                        }
+                      },
+                      child: const Text('Add'),
+                    ),
+                  ],
+                ),
               ),
             ],
           ),
         ),
+        const Divider(height: 1),
+        // Blacklisted extensions list
         Expanded(
-          child: Builder(builder: (context) {
-            if (prefsState.isLoading) {
-              return const Center(child: CircularProgressIndicator());
-            }
-
-            final groupedExtensions = notifier.groupedExtensions;
-            final currentPrefs = prefsState.prefs;
-
-            return ListView.builder(
-              padding: const EdgeInsetsDirectional.all(16),
-              itemCount: groupedExtensions.length,
-              itemBuilder: (context, index) {
-                final category = groupedExtensions.keys.elementAt(index);
-                final extensions = groupedExtensions[category]!;
-                final enabledCount = extensions.where((e) => e.value).length;
-
-                return Card(
-                  margin: const EdgeInsetsDirectional.only(bottom: 16),
-                  child: ExpansionTile(
-                    leading: Icon(category.icon),
-                    title: Text(category.displayName),
-                    subtitle: Text(
-                      '$enabledCount of ${extensions.length} enabled',
-                      style: context.bodySmall?.copyWith(
-                        color: context.onSurface.addOpacity(0.6),
-                      ),
+          child: ListView(
+            padding: const EdgeInsets.all(16),
+            children: [
+              Row(
+                mainAxisAlignment: MainAxisAlignment.spaceBetween,
+                children: [
+                  Text(
+                    'Currently Blacklisted (${blacklist.length})',
+                    style: context.titleMedium,
+                  ),
+                  if (blacklist.isEmpty)
+                    Text(
+                      'No extensions blacklisted',
+                      style: context.bodyMuted,
                     ),
-                    children: [
-                      const Divider(height: 1),
-                      Padding(
-                        padding: const EdgeInsetsDirectional.all(8),
-                        child: Wrap(
-                          spacing: 8,
-                          runSpacing: 8,
-                          children: extensions.map((entry) {
-                            final extension = entry.key;
-                            final isEnabled = entry.value;
-                            final isCustom = currentPrefs.customExtensions
-                                .containsKey(extension);
-
-                            return FilterChip(
-                              label: Row(
-                                mainAxisSize: MainAxisSize.min,
-                                children: [
-                                  Text(extension),
-                                  if (isCustom) ...[
-                                    const SizedBox(width: 4),
-                                    Icon(
-                                      Icons.star_rounded,
-                                      size: 14,
-                                      color: context.primary,
-                                    ),
-                                  ],
-                                ],
-                              ),
-                              selected: isEnabled,
-                              onSelected: (_) async {
-                                await notifier.toggleExtension(extension);
-                              },
-                              showCheckmark: true,
-                              deleteIcon: isCustom
-                                  ? const Icon(Icons.close_rounded, size: 18)
-                                  : null,
-                              onDeleted: isCustom
-                                  ? () async {
-                                      await notifier.toggleExtension(extension);
-                                    }
-                                  : null,
-                            );
-                          }).toList(),
-                        ),
+                ],
+              ),
+              const SizedBox(height: 16),
+              if (blacklist.isNotEmpty)
+                Wrap(
+                  spacing: 8,
+                  runSpacing: 8,
+                  children: blacklist.map((ext) {
+                    return Chip(
+                      label: Text(
+                        ext,
+                        style: const TextStyle(fontFamily: 'monospace'),
                       ),
-                    ],
-                  ),
-                );
-              },
-            );
-          }),
+                      deleteIcon: const Icon(Icons.close_rounded, size: 18),
+                      onDeleted: () async {
+                        await notifier.removeFromBlacklist(ext);
+                        if (mounted) {
+                          context.showOk('Extension removed from blacklist');
+                        }
+                      },
+                    );
+                  }).toList(),
+                ),
+            ],
+          ),
         ),
       ],
     );
@@ -479,174 +307,145 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
     final autoUpdaterService = ref.read(autoUpdaterServiceProvider);
 
     return ListView(
-      padding: const EdgeInsets.all(16),
+      padding: DsDimensions.paddingMedium,
       children: [
-        Card(
-          child: Padding(
-            padding: const EdgeInsets.all(16),
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Row(
-                  children: [
-                    Icon(
-                      Icons.system_update_rounded,
-                      color: context.primary,
-                    ),
-                    const SizedBox(width: 12),
-                    Text(
-                      'Automatic Updates',
-                      style: context.titleMedium?.copyWith(
-                        fontWeight: FontWeight.bold,
-                      ),
-                    ),
-                  ],
-                ),
-                const SizedBox(height: 16),
-                Text(
-                  'Keep Context Collector up to date with the latest features and improvements.',
-                  style: context.bodyMedium?.copyWith(
-                    color: context.onSurface.addOpacity(0.7),
-                  ),
+        DsCard(
+          child: Column(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              DsSectionHeader(
+                title: 'Automatic Updates',
+                trailing: Icon(
+                  Icons.system_update_rounded,
+                  color: context.primary,
+                  size: DesignSystem.iconSizeMedium,
                 ),
-                const SizedBox(height: 24),
-                FilledButton.icon(
-                  onPressed: () async {
-                    try {
-                      // Show loading indicator
-                      await showDialog<void>(
+              ),
+              context.ds.spaceHeight(DesignSystem.space16),
+              Text(
+                'Keep Context Collector up to date with the latest features and improvements.',
+                style: context.bodyMuted,
+              ),
+              context.ds.spaceHeight(DesignSystem.space24),
+              DsButton(
+                onPressed: () async {
+                  try {
+                    // Show loading indicator without awaiting it
+                    unawaited(
+                      showDialog<void>(
                         context: context,
                         barrierDismissible: false,
-                        builder: (context) => const Center(
-                          child: Card(
-                            child: Padding(
-                              padding: EdgeInsets.all(20),
-                              child: CircularProgressIndicator(),
-                            ),
+                        builder: (dialogContext) => const Center(
+                          child: DsCard(
+                            child: CircularProgressIndicator(),
                           ),
                         ),
-                      );
+                      ),
+                    );
 
-                      await autoUpdaterService.checkForUpdates();
+                    await autoUpdaterService.checkForUpdates();
 
-                      if (mounted) {
-                        Navigator.pop(context); // Close loading dialog
-                        ScaffoldMessenger.of(context).showSnackBar(
-                          const SnackBar(
-                            content: Text('Checking for updates...'),
-                          ),
-                        );
-                      }
-                    } catch (e) {
-                      if (mounted) {
-                        Navigator.pop(context); // Close loading dialog
-                        ScaffoldMessenger.of(context).showSnackBar(
-                          SnackBar(
-                            content: Text('Failed to check for updates: $e'),
-                            backgroundColor: context.error,
-                          ),
-                        );
-                      }
+                    if (mounted) {
+                      Navigator.pop(context); // Close loading dialog
+                      context.showOk(
+                        'Update check complete! If an update is available, it will download automatically.',
+                      );
                     }
-                  },
-                  icon: const Icon(Icons.refresh_rounded),
-                  label: const Text('Check for Updates'),
-                ),
-                const SizedBox(height: 16),
-                const Divider(),
-                const SizedBox(height: 16),
-                Text(
-                  'Update Settings',
-                  style: context.titleSmall?.copyWith(
-                    fontWeight: FontWeight.bold,
-                  ),
-                ),
-                const SizedBox(height: 12),
-                Container(
-                  padding: const EdgeInsets.all(12),
-                  decoration: BoxDecoration(
-                    color: context.surfaceContainerHighest,
-                    borderRadius: BorderRadius.circular(8),
-                  ),
-                  child: Column(
-                    crossAxisAlignment: CrossAxisAlignment.start,
-                    children: [
-                      Row(
-                        children: [
-                          Icon(
-                            Icons.schedule_rounded,
-                            size: 16,
-                            color: context.onSurface.addOpacity(0.6),
-                          ),
-                          const SizedBox(width: 8),
-                          Text(
-                            'Automatic check interval: Every 6 hours',
-                            style: context.bodySmall?.copyWith(
-                              color: context.onSurface.addOpacity(0.6),
-                            ),
-                          ),
-                        ],
-                      ),
-                      const SizedBox(height: 8),
-                      Row(
-                        children: [
-                          Icon(
-                            Icons.cloud_download_rounded,
-                            size: 16,
-                            color: context.onSurface.addOpacity(0.6),
-                          ),
-                          const SizedBox(width: 8),
-                          Expanded(
-                            child: Text(
-                              'Updates are downloaded automatically and will be installed on next app restart',
-                              style: context.bodySmall?.copyWith(
-                                color: context.onSurface.addOpacity(0.6),
-                              ),
-                            ),
-                          ),
-                        ],
-                      ),
-                    ],
-                  ),
+                  } catch (e) {
+                    if (mounted) {
+                      Navigator.pop(context); // Close loading dialog
+                      context.showErr('Failed to check for updates: $e');
+                    }
+                  }
+                },
+                icon: const Icon(Icons.refresh_rounded),
+                isFilled: true,
+                child: const Text('Check for Updates'),
+              ),
+              context.ds.spaceHeight(DesignSystem.space16),
+              const DsDivider(),
+              context.ds.spaceHeight(DesignSystem.space16),
+              Text(
+                'Update Settings',
+                style: context.titleBold,
+              ),
+              context.ds.spaceHeight(DesignSystem.space12),
+              Container(
+                padding: DsDimensions.paddingSmall,
+                decoration: BoxDecoration(
+                  color: context.surfaceContainerHighest,
+                  borderRadius: context.ds.radiusMedium,
                 ),
-              ],
-            ),
-          ),
-        ),
-        const SizedBox(height: 16),
-        Card(
-          child: Padding(
-            padding: const EdgeInsets.all(16),
-            child: Column(
-              crossAxisAlignment: CrossAxisAlignment.start,
-              children: [
-                Row(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
                   children: [
-                    Icon(
-                      Icons.info_outline_rounded,
-                      color: context.primary,
+                    Row(
+                      children: [
+                        Icon(
+                          Icons.schedule_rounded,
+                          size: 16,
+                          color: context.onSurface.addOpacity(0.6),
+                        ),
+                        context.ds.spaceWidth(DesignSystem.space8),
+                        Text(
+                          'Automatic check interval: Every 6 hours',
+                          style: context.bodyMuted,
+                        ),
+                      ],
                     ),
-                    const SizedBox(width: 12),
-                    Text(
-                      'About',
-                      style: context.titleMedium?.copyWith(
-                        fontWeight: FontWeight.bold,
-                      ),
+                    context.ds.spaceHeight(DesignSystem.space8),
+                    Row(
+                      children: [
+                        Icon(
+                          Icons.cloud_download_rounded,
+                          size: 16,
+                          color: context.onSurface.addOpacity(0.6),
+                        ),
+                        context.ds.spaceWidth(DesignSystem.space8),
+                        Expanded(
+                          child: Text(
+                            'Updates are downloaded automatically and will be installed on next app restart',
+                            style: context.bodyMuted,
+                          ),
+                        ),
+                      ],
                     ),
                   ],
                 ),
-                const SizedBox(height: 16),
-                _buildInfoRow(context, 'Version', '1.1.0'),
-                const SizedBox(height: 8),
-                _buildInfoRow(context, 'Platform', Platform.operatingSystem),
-                const SizedBox(height: 8),
-                _buildInfoRow(
-                  context,
-                  'Update Channel',
-                  'Stable',
+              ),
+            ],
+          ),
+        ),
+        context.ds.spaceHeight(DesignSystem.space16),
+        DsCard(
+          child: Column(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              DsSectionHeader(
+                title: 'About',
+                trailing: Icon(
+                  Icons.info_outline_rounded,
+                  color: context.primary,
+                  size: DesignSystem.iconSizeMedium,
                 ),
-              ],
-            ),
+              ),
+              context.ds.spaceHeight(DesignSystem.space16),
+              _buildInfoRow(
+                context,
+                'Version',
+                _packageInfo == null
+                    ? 'Loading...'
+                    : '${_packageInfo!.version}${_packageInfo!.buildNumber.isNotEmpty ? '+${_packageInfo!.buildNumber}' : ''}',
+              ),
+              context.ds.spaceHeight(DesignSystem.space8),
+              _buildInfoRow(context, 'Platform', Platform.operatingSystem),
+              context.ds.spaceHeight(DesignSystem.space8),
+              _buildInfoRow(
+                context,
+                'Update Channel',
+                'Stable',
+              ),
+            ],
           ),
         ),
       ],
@@ -654,22 +453,9 @@ class _SettingsScreenState extends ConsumerState<SettingsScreen>
   }
 
   Widget _buildInfoRow(BuildContext context, String label, String value) {
-    return Row(
-      children: [
-        Text(
-          '$label:',
-          style: context.bodyMedium?.copyWith(
-            fontWeight: FontWeight.w600,
-          ),
-        ),
-        const SizedBox(width: 8),
-        Text(
-          value,
-          style: context.bodyMedium?.copyWith(
-            color: context.onSurface.addOpacity(0.7),
-          ),
-        ),
-      ],
+    return DsInfoRow(
+      label: '$label:',
+      value: value,
     );
   }
 }
diff --git a/lib/src/features/settings/services/auto_updater_service.dart b/lib/src/features/settings/services/auto_updater_service.dart
index d936418..1c4e2f9 100644
--- a/lib/src/features/settings/services/auto_updater_service.dart
+++ b/lib/src/features/settings/services/auto_updater_service.dart
@@ -8,7 +8,7 @@ final autoUpdaterServiceProvider = Provider<AutoUpdaterService>((ref) {
 });
 
 /// Service to manage automatic updates
-class AutoUpdaterService {
+class AutoUpdaterService implements UpdaterListener {
   // Production update feed URL - hosted on GitHub Pages
   static const String _productionFeedUrl =
       'https://omar-hanafy.github.io/context_collector/appcast.xml';
@@ -19,6 +19,9 @@ class AutoUpdaterService {
   /// Initialize the auto updater
   Future<void> initialize() async {
     try {
+      // Add this service as a listener for update events
+      autoUpdater.addListener(this);
+
       // Use development URL in debug mode, production URL in release mode
       const feedUrl = kDebugMode ? _developmentFeedUrl : _productionFeedUrl;
 
@@ -77,4 +80,51 @@ class AutoUpdaterService {
       rethrow;
     }
   }
+
+  // UpdaterListener implementation
+  @override
+  void onUpdaterError(UpdaterError? error) {
+    debugPrint('[AutoUpdater] Error: ${error?.message}');
+  }
+
+  @override
+  void onUpdaterCheckingForUpdate(Appcast? appcast) {
+    debugPrint('[AutoUpdater] Checking for update...');
+    if (appcast != null) {
+      debugPrint('[AutoUpdater] Appcast items: ${appcast.items.length}');
+    }
+  }
+
+  @override
+  void onUpdaterUpdateAvailable(AppcastItem? appcastItem) {
+    debugPrint('[AutoUpdater] Update available!');
+    if (appcastItem != null) {
+      debugPrint('[AutoUpdater] Version: ${appcastItem.versionString}');
+      debugPrint('[AutoUpdater] Title: ${appcastItem.title}');
+      debugPrint('[AutoUpdater] File URL: ${appcastItem.fileURL}');
+    }
+  }
+
+  @override
+  void onUpdaterUpdateNotAvailable(UpdaterError? error) {
+    debugPrint('[AutoUpdater] No update available');
+    if (error != null) {
+      debugPrint('[AutoUpdater] Reason: ${error.message}');
+    }
+  }
+
+  @override
+  void onUpdaterUpdateDownloaded(AppcastItem? appcastItem) {
+    debugPrint('[AutoUpdater] Update downloaded!');
+    if (appcastItem != null) {
+      debugPrint(
+        '[AutoUpdater] Ready to install: ${appcastItem.versionString}',
+      );
+    }
+  }
+
+  @override
+  void onUpdaterBeforeQuitForUpdate(AppcastItem? appcastItem) {
+    debugPrint('[AutoUpdater] About to quit for update installation');
+  }
 }
diff --git a/lib/src/features/settings/settings.dart b/lib/src/features/settings/settings.dart
index b9dc2d9..a3d6453 100644
--- a/lib/src/features/settings/settings.dart
+++ b/lib/src/features/settings/settings.dart
@@ -1,4 +1,6 @@
 // Settings feature exports
 export 'domain/extension_prefs.dart';
 export 'presentation/state/preferences_notifier.dart';
+export 'presentation/state/theme_notifier.dart';
 export 'presentation/ui/settings_screen.dart';
+export 'services/auto_updater_service.dart';
diff --git a/lib/src/features/virtual_tree/RULES.md b/lib/src/features/virtual_tree/RULES.md
new file mode 100644
index 0000000..831fb48
--- /dev/null
+++ b/lib/src/features/virtual_tree/RULES.md
@@ -0,0 +1,355 @@
+# Virtual Tree Behavior Rules & Specifications
+
+## Core Principles
+
+### 1. **User Choice First**
+- The user should have control over how their files are organized
+- When ambiguity exists, ask the user what they want
+- Provide sensible defaults but allow overrides
+
+### 2. **Flexible Organization**
+- Files can exist multiple times if the user chooses (virtual duplicates)
+- The tree represents the user's mental model, not the file system
+- Support both automatic organization and manual adjustments
+
+### 3. **Clear Visual Feedback**
+- Always show what will happen before it happens
+- Distinguish between different file states (original, duplicate, virtual)
+- Make the tree structure predictable and understandable
+
+## Drop Behavior Rules
+
+### Rule 1: First Drop of Any Item
+**Scenario**: User drops files/folders for the first time
+**Behavior**: 
+- Add immediately without asking
+- Create minimal necessary structure
+- Auto-select new items
+
+### Rule 2: Dropping Same Directory Again
+**Scenario**: User drops `/home/project/` when it already exists in tree
+**Behavior**:
+- **ALWAYS** show dialog with options:
+  1. **Merge Smart** (default)
+     - Only add files that don't exist
+     - Use existing folder structure
+     - Don't create duplicates
+  2. **Replace Entire Directory**
+     - Remove ALL files from this source directory
+     - Add fresh copy of everything
+     - Useful when files have changed
+  3. **Add as Duplicate**
+     - Create new virtual folder with suffix (e.g., "project (2)")
+     - Keep all existing files
+     - Add all new files under duplicate folder
+
+### Rule 3: Dropping Subset of Existing Directory
+**Scenario**: User drops `/home/project/src/file.js` when `/home/project/` already exists
+**Behavior**:
+- Check if file already exists at that path
+- If exists: Show dialog
+  1. **Skip** (default) - Don't add duplicate
+  2. **Replace** - Update the existing file
+  3. **Add as Copy** - Add with suffix (e.g., "file (2).js")
+- If doesn't exist: Add to existing structure
+
+### Rule 4: Dropping Different Files from Same Directory
+**Scenario**: First drop `/project/file1.js`, then drop `/project/file2.js`
+**Behavior**:
+- Recognize they share a parent
+- Add `file2.js` to existing `/project/` folder
+- Don't create duplicate folder structures
+
+### Rule 5: Mixed Source Drops
+**Scenario**: Drop multiple items from different locations at once
+**Behavior**:
+- Process each source location independently
+- Apply above rules for each source
+- Show combined dialog if multiple conflicts
+
+## Tree Organization Rules
+
+### Structure Rule 1: Minimal Necessary Folders
+**Principle**: Only create folders that add meaning
+**Example**:
+```
+‚ùå Bad:  /home/user/projects/myapp/src/index.js
+‚úÖ Good: myapp/src/index.js
+```
+
+### Structure Rule 2: Preserve Relative Paths
+**Principle**: Keep relative structure within a source
+**Example**:
+Drop: `/projects/app/src/components/Button.js` and `/projects/app/src/utils/helpers.js`
+Result:
+```
+app/
+‚îú‚îÄ‚îÄ src/
+    ‚îú‚îÄ‚îÄ components/
+    ‚îÇ   ‚îî‚îÄ‚îÄ Button.js
+    ‚îî‚îÄ‚îÄ utils/
+        ‚îî‚îÄ‚îÄ helpers.js
+```
+
+### Structure Rule 3: Smart Root Naming
+**Principle**: Use meaningful root folder names
+- If dropping a project folder, use the project name
+- If dropping mixed files, group by common parent
+- If no common parent, create "Mixed Sources" root
+
+## Duplicate Handling Specifications
+
+### Duplicate Detection
+**What constitutes a duplicate?**
+1. **Exact Path Match**: Same source path already in scan history (not just in current files)
+2. **Content Match**: Different path but identical content (future feature)
+
+### User Decision Points
+**When to ask the user:**
+1. Dropping exact same directory path that was previously scanned
+2. Dropping file that exists in structure
+3. Dropping subset that creates conflicts
+
+**When NOT to ask:**
+1. First scan operation (empty scan history)
+2. Dropping completely new files
+3. Dropping to different virtual locations
+4. Dropping a file then its parent directory (no longer shows false duplicate)
+
+### Duplicate Resolution Options
+
+#### For Directories:
+1. **Merge Smart**
+   - Compare file lists
+   - Add only new files
+   - Skip existing files
+   - Preserve tree structure
+
+2. **Replace All**
+   - Remove all files from this source
+   - Add fresh copies
+   - Preserve virtual edits in other files
+
+3. **Keep Both**
+   - Rename folder with suffix
+   - Keep all existing
+   - Add all new under renamed folder
+
+#### For Individual Files:
+1. **Skip** - Don't add
+2. **Replace** - Update existing
+3. **Rename** - Add with suffix
+
+## Virtual Files & Folders
+
+### Creating Virtual Items
+**Allowed Operations:**
+- Create new file in any folder
+- Create new folder anywhere
+- Create at root level
+- Edit content of any file (virtual or real)
+
+**Naming Rules:**
+- Virtual files start with default names (untitled-1.md)
+- Auto-increment if name exists
+- User can rename immediately
+- Name validation prevents duplicates and invalid characters
+
+### Virtual Item Behavior
+- Treated exactly like real files in selection
+- Can be edited, moved, deleted
+- Shown with special indicator (‚ú®)
+- Included in export/copy operations
+- Virtual file paths reflect their position in the tree hierarchy
+
+### Implementation Details
+- Virtual files are created directly in their parent folder without rebuilding the entire tree
+- File creation uses dedicated `addVirtualFileNode` API to maintain proper state synchronization
+- Virtual paths are built from the parent node's virtual path, not filesystem paths
+- Checkboxes work immediately upon creation due to proper fileId linking
+
+## Selection Behavior
+
+### File Selection
+- Clicking file toggles selection
+- Multiple selection supported
+- Selection persists across tree operations
+
+### Folder Selection
+- Checkbox shows three states:
+  - ‚òê None selected
+  - ‚òë All selected  
+  - ‚äü Partial selected
+- Clicking checkbox:
+  - From none/partial ‚Üí Select all
+  - From all ‚Üí Deselect all
+
+### Selection Sync
+- Tree selection immediately updates editor content
+- Deselecting file removes it from combined output
+- Selection state persists through refreshes
+
+## Edge Cases & Decisions
+
+### Case 1: Circular References
+**Scenario**: Symlinks causing circular refs
+**Decision**: Skip with warning, don't follow symlinks
+
+### Case 2: Very Large Directories
+**Scenario**: Dropping folder with 10,000+ files
+**Decision**: Show progress, allow cancellation, add in batches
+
+### Case 3: Binary Files
+**Scenario**: Dropping images, executables
+**Decision**: Add to tree but mark as binary, don't load content
+
+### Case 4: Permission Errors
+**Scenario**: Can't read file due to permissions
+**Decision**: Add to tree with error indicator, show in tooltip
+
+### Case 5: Multiple Duplicates
+**Scenario**: file.js, file (2).js already exist, dropping file.js again
+**Decision**: Increment to next available: file (3).js
+
+## State Management Rules
+
+### What Persists
+- Tree structure
+- Selection state  
+- Virtual file content
+- Expansion state
+
+### What Resets
+- On "Clear All": Everything
+- On "Remove": Just that node and children
+- On "Replace": Only affected files
+
+### Undo/Redo (Future)
+- Track operations for undo
+- Granular undo per operation
+- Clear undo stack on major operations
+
+## UI/UX Standards
+
+### Feedback Timing
+- Immediate: Selection, expansion
+- Async with progress: Large operations
+- Debounced: Content building (300ms)
+
+### Error Handling
+- Show inline for file errors
+- Toast for operation errors
+- Dialog for critical decisions
+
+### Visual Hierarchy
+- Root folders: Bold
+- Virtual items: Special icon
+- Errors: Red indicator
+- Modified: Orange indicator
+
+## Performance Considerations
+
+### Lazy Loading
+- Load file content on demand
+- Virtualize tree rendering for large lists
+- Batch operations when possible
+
+### Memory Management
+- Cap in-memory content (100MB default)
+- Offer to exclude large files
+- Stream large file operations
+
+## Summary of Key Decisions
+
+1. **Duplicates ARE allowed** if user chooses
+2. **Always ask** when dropping same source again (based on scan history, not file content)
+3. **Smart merge** is the default option
+4. **Preserve user organization** over file system structure
+5. **Virtual files** are first-class citizens
+6. **Selection drives content** in real-time
+7. **Visual feedback** before any destructive operation
+
+## Technical Implementation Notes
+
+### State Synchronization (CRITICAL)
+- **FileListNotifier is the SINGLE SOURCE OF TRUTH** for all file data and scan history
+- TreeStateNotifier manages ONLY UI state (expansion, visual representation)
+- All operations that modify files MUST go through FileListNotifier:
+  - File creation: UI ‚Üí FileListNotifier ‚Üí TreeStateNotifier
+  - File removal: UI ‚Üí FileListNotifier.removeNodes() ‚Üí Tree rebuild
+  - Folder creation: UI ‚Üí FileListNotifier ‚Üí VirtualTreeAPI
+- Tree is ALWAYS rebuilt from FileListNotifier's state
+- This architecture prevents state synchronization bugs
+- **IMPORTANT**: TreeStateNotifier.removeNode() method has been removed to enforce this pattern
+
+### Virtual File Creation Flow
+1. User creates file in tree UI
+2. FileListNotifier creates ScannedFile with proper virtual path from parent
+3. FileListNotifier calls `addVirtualFileNode` to add the node to the tree
+4. Tree node is created with correct fileId linking
+5. Selection callback triggers content rebuild
+
+### Removal Operations (Bug Fix)
+- **CRITICAL**: All removals MUST use FileListNotifier.removeNodes()
+- This method:
+  1. Recursively collects all descendant file IDs
+  2. Removes files from the master file map
+  3. **Cleans scanHistory** to remove orphaned source paths
+  4. Rebuilds the entire tree from clean state
+- This prevents the "remove and re-add shows duplicate dialog" bug
+- Direct tree node removal is FORBIDDEN - TreeStateNotifier no longer has removeNode() method
+
+### Edge Case Handling
+- Name conflicts: Validated before showing content editor
+- Large files: Warning dialog for files over 2MB
+- Invalid characters: Prevented via form validation
+- Double-click prevention: Save button disabled while saving
+
+### Avoiding False Duplicate Detection (CRITICAL)
+
+The scan history is fundamental to duplicate detection. If not properly maintained, it can lead to false positives where the app incorrectly identifies new additions as duplicates.
+
+#### Common Causes of False Duplicates:
+1. **Incomplete History Cleanup**: When files are removed but their source paths remain in scan history
+2. **Replace Operations**: Using "Replace All" without cleaning the scan history
+3. **Partial Removals**: Removing some files from a directory but not updating the scan metadata
+
+#### Key Implementation Requirements:
+1. **Always Clean Scan History**: Any operation that removes files MUST also clean the scan history
+2. **Use Helper Methods**: The `_removePathsFromScanHistory()` helper ensures consistent cleanup
+3. **Replace Operations**: The `_applyReplaceAllAction()` MUST clean scan history before updating state
+
+#### Code Pattern for Safe Removal:
+```dart
+// WRONG - Creates false duplicates
+state = state.copyWith(
+  fileMap: newFileMap,
+  selectedFileIds: newSelection,
+  // scanHistory not updated - BUG!
+);
+
+// CORRECT - Prevents false duplicates
+final newScanHistory = _removePathsFromScanHistory(pathsToRemove);
+state = state.copyWith(
+  fileMap: newFileMap,
+  selectedFileIds: newSelection,
+  scanHistory: newScanHistory, // Clean history
+);
+```
+
+#### Testing for Regressions:
+1. Add a directory
+2. Choose "Replace All" when re-adding
+3. Clear all files
+4. Add the same directory again
+5. Should NOT show duplicate dialog (if it does, scan history isn't being cleaned)
+
+### Recent Architecture Improvements (Post-Cleanup)
+- **SelectionState.allFiles removed**: fileMap is now the single source of truth, eliminating redundancy
+- **Display logic consolidated**: All file display logic moved to FileDisplayHelper for consistency
+- **Extension catalog unified**: FileDisplayHelper.extensionCatalog is the single source for file type definitions
+- **File conflict handling refactored**: Split into smaller, focused methods for better maintainability
+- **Debug statements removed**: Production-ready code without debug prints
+- **Scan history cleanup fixed**: Prevents false duplicate detection after replace operations
+
+These rules prioritize user control and flexibility while providing smart defaults. The tree is a workspace, not just a file viewer.
diff --git a/lib/src/features/virtual_tree/api/virtual_tree_api.dart b/lib/src/features/virtual_tree/api/virtual_tree_api.dart
new file mode 100644
index 0000000..f05c0e2
--- /dev/null
+++ b/lib/src/features/virtual_tree/api/virtual_tree_api.dart
@@ -0,0 +1,80 @@
+import 'dart:convert';
+
+import '../../scan/models/scan_result.dart';
+import '../../scan/models/scanned_file.dart';
+import '../models/tree_node.dart';
+
+export '../models/tree_node.dart';
+
+/// Virtual Tree API contract for scanner integration
+abstract class VirtualTreeAPI {
+  /// Build tree from files and metadata
+  Future<TreeData> buildTree({
+    required List<ScannedFile> files,
+    required List<ScanMetadata> scanMetadata,
+  });
+
+  /// Get current tree structure
+  TreeData? getCurrentTree();
+
+  /// Selection management
+  Set<String> getSelectedFileIds();
+
+  void setSelectedFileIds(Set<String> ids);
+
+  /// Content building (handled by scanner in our case)
+  Future<String> buildCombinedContent(Set<String> selectedIds);
+
+  /// Tree operations callbacks
+  void onNodeCreated(
+    void Function(String parentPath, String name, String content) callback,
+  );
+
+  void onNodeEdited(void Function(String fileId, String content) callback);
+
+  void onSelectionChanged(void Function(Set<String> selectedIds) callback);
+
+  /// Clear the tree
+  void clearTree();
+
+  /// Directly add a new virtual file node to the tree under a specific parent.
+  void addVirtualFileNode({
+    required String parentNodeId,
+    required ScannedFile file,
+  });
+
+  /// Get the virtual path of a node by its ID
+  String? getNodeVirtualPath(String nodeId);
+
+  /// Create a virtual folder in the tree
+  void createVirtualFolder({
+    required String parentNodeId,
+    required String folderName,
+  });
+}
+
+/// Tree data structure
+class TreeData {
+  const TreeData({
+    required this.nodes,
+    required this.rootId,
+  });
+  factory TreeData.fromJson(String json) =>
+      TreeData.fromMap(jsonDecode(json) as Map<String, dynamic>);
+
+  factory TreeData.fromMap(Map<String, dynamic> map) => TreeData(
+    nodes: (map['nodes'] as Map<String, dynamic>).map(
+      (k, v) => MapEntry(k, TreeNode.fromMap(v as Map<String, dynamic>)),
+    ),
+    rootId: map['rootId'] as String,
+  );
+  final Map<String, TreeNode> nodes;
+  final String rootId;
+
+  Map<String, dynamic> toMap() => {
+    'nodes': nodes.map((k, v) => MapEntry(k, v.toMap())),
+    'rootId': rootId,
+  };
+
+  String toJson() => jsonEncode(toMap());
+}
diff --git a/lib/src/features/virtual_tree/api/virtual_tree_impl.dart b/lib/src/features/virtual_tree/api/virtual_tree_impl.dart
new file mode 100644
index 0000000..e20cac5
--- /dev/null
+++ b/lib/src/features/virtual_tree/api/virtual_tree_impl.dart
@@ -0,0 +1,111 @@
+import '../../scan/models/scan_result.dart';
+import '../../scan/models/scanned_file.dart';
+import '../api/virtual_tree_api.dart';
+import '../state/tree_state.dart';
+
+/// Implementation of VirtualTreeAPI for scanner integration
+class VirtualTreeImpl implements VirtualTreeAPI {
+  VirtualTreeImpl(this._notifier);
+  final TreeStateNotifier _notifier;
+
+  @override
+  Future<TreeData> buildTree({
+    required List<ScannedFile> files,
+    required List<ScanMetadata> scanMetadata,
+  }) async {
+    _notifier.buildFromFiles(files, scanMetadata);
+
+    return _notifier.getCurrentTreeData();
+  }
+
+  @override
+  TreeData? getCurrentTree() {
+    if (!_notifier.hasTreeNodes()) return null;
+
+    return _notifier.getCurrentTreeData();
+  }
+
+  @override
+  Set<String> getSelectedFileIds() => _notifier.getSelectedFileIds();
+
+  @override
+  void setSelectedFileIds(Set<String> ids) {
+    _notifier.updateSelectionFromFileIds(ids);
+  }
+
+  @override
+  Future<String> buildCombinedContent(Set<String> selectedIds) async {
+    // This is handled by scanner's buildMarkdown
+    // Virtual tree just provides the selection
+    return '';
+  }
+
+  @override
+  void onNodeCreated(void Function(String, String, String) callback) {
+    _notifier.onNodeCreatedCallback = callback;
+  }
+
+  @override
+  void onNodeEdited(void Function(String, String) callback) {
+    _notifier.onNodeEditedCallback = callback;
+  }
+
+  @override
+  void onSelectionChanged(void Function(Set<String>) callback) {
+    _notifier.onSelectionChangedCallback = callback;
+  }
+
+  /// Get existing file IDs in the tree
+  Set<String> getExistingFileIds() {
+    final treeData = _notifier.getCurrentTreeData();
+    final fileIds = <String>{};
+    for (final node in treeData.nodes.values) {
+      if (node.fileId != null) {
+        fileIds.add(node.fileId!);
+      }
+    }
+    return fileIds;
+  }
+
+  @override
+  void clearTree() {
+    _notifier.clearTree();
+  }
+
+  @override
+  void addVirtualFileNode({
+    required String parentNodeId,
+    required ScannedFile file,
+  }) {
+    _notifier.addVirtualFileNode(parentNodeId: parentNodeId, file: file);
+  }
+
+  @override
+  String? getNodeVirtualPath(String nodeId) {
+    final treeData = _notifier.getCurrentTreeData();
+    return treeData.nodes[nodeId]?.virtualPath;
+  }
+
+  @override
+  void createVirtualFolder({
+    required String parentNodeId,
+    required String folderName,
+  }) {
+    _notifier.createNode(
+      parentId: parentNodeId,
+      name: folderName,
+      isFolder: true,
+    );
+  }
+
+  /// Force content rebuild (useful for debugging)
+  void forceContentRebuild() {
+    final fileIds = _notifier.getSelectedFileIds();
+    _notifier.onSelectionChangedCallback?.call(fileIds);
+  }
+
+  /// Debug: Check if callbacks are set
+  bool hasCallbacks() {
+    return _notifier.onSelectionChangedCallback != null;
+  }
+}
diff --git a/lib/src/features/virtual_tree/models/tree_node.dart b/lib/src/features/virtual_tree/models/tree_node.dart
new file mode 100644
index 0000000..c9511e1
--- /dev/null
+++ b/lib/src/features/virtual_tree/models/tree_node.dart
@@ -0,0 +1,107 @@
+import 'package:uuid/uuid.dart';
+
+/// Node types in the virtual tree
+enum NodeType { root, folder, file }
+
+/// Source of the file/folder
+enum FileSource { disk, created, pasted }
+
+/// Represents a node in the virtual file tree
+class TreeNode {
+  TreeNode({
+    String? id,
+    required this.name,
+    required this.type,
+    required this.parentId,
+    required this.virtualPath,
+    this.sourcePath,
+    this.fileId,
+    this.isVirtual = false,
+    this.source = FileSource.disk,
+    this.isExpanded = false,
+    this.isSelected = false,
+    List<String>? childIds,
+  }) : id = id ?? const Uuid().v4(),
+       childIds = childIds ?? [];
+
+  /// Create from map
+  factory TreeNode.fromMap(Map<String, dynamic> map) => TreeNode(
+    id: map['id'] as String,
+    name: map['name'] as String,
+    type: NodeType.values[map['type'] as int],
+    parentId: map['parentId'] as String,
+    virtualPath: map['virtualPath'] as String,
+    sourcePath: map['sourcePath'] as String?,
+    fileId: map['fileId'] as String?,
+    isVirtual: map['isVirtual'] as bool? ?? false,
+    source: FileSource.values[map['source'] as int? ?? 0],
+    isExpanded: map['isExpanded'] as bool? ?? false,
+    isSelected: map['isSelected'] as bool? ?? false,
+    childIds: (map['childIds'] as List<dynamic>?)?.cast<String>() ?? [],
+  );
+  final String id;
+  final String name;
+  final NodeType type;
+  final String parentId;
+  final List<String> childIds;
+
+  // Source information
+  final String? sourcePath; // Original disk path
+  final String virtualPath; // Path in virtual tree
+  final bool isVirtual; // Created in-app
+  final FileSource source;
+
+  // Content management
+  final String? fileId; // Links to ScannedFile.id
+
+  // UI state
+  bool isExpanded;
+  bool isSelected;
+
+  /// Create a copy with updated values
+  TreeNode copyWith({
+    String? name,
+    bool? isExpanded,
+    bool? isSelected,
+    List<String>? childIds,
+    String? sourcePath,
+  }) {
+    return TreeNode(
+      id: id,
+      name: name ?? this.name,
+      type: type,
+      parentId: parentId,
+      virtualPath: virtualPath,
+      sourcePath: sourcePath ?? this.sourcePath,
+      fileId: fileId,
+      isVirtual: isVirtual,
+      source: source,
+      isExpanded: isExpanded ?? this.isExpanded,
+      isSelected: isSelected ?? this.isSelected,
+      childIds: childIds ?? this.childIds,
+    );
+  }
+
+  /// Convert to map for serialization
+  Map<String, dynamic> toMap() => {
+    'id': id,
+    'name': name,
+    'type': type.index,
+    'parentId': parentId,
+    'virtualPath': virtualPath,
+    'sourcePath': sourcePath,
+    'fileId': fileId,
+    'isVirtual': isVirtual,
+    'source': source.index,
+    'isExpanded': isExpanded,
+    'isSelected': isSelected,
+    'childIds': childIds,
+  };
+
+  @override
+  bool operator ==(Object other) =>
+      identical(this, other) || other is TreeNode && other.id == id;
+
+  @override
+  int get hashCode => id.hashCode;
+}
diff --git a/lib/src/features/virtual_tree/providers/virtual_tree_provider.dart b/lib/src/features/virtual_tree/providers/virtual_tree_provider.dart
new file mode 100644
index 0000000..3454345
--- /dev/null
+++ b/lib/src/features/virtual_tree/providers/virtual_tree_provider.dart
@@ -0,0 +1,10 @@
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import '../api/virtual_tree_api.dart';
+import '../api/virtual_tree_impl.dart';
+import '../state/tree_state.dart';
+
+/// Provider for VirtualTreeAPI implementation
+final virtualTreeProvider = Provider<VirtualTreeAPI>((ref) {
+  final notifier = ref.watch(treeStateProvider.notifier);
+  return VirtualTreeImpl(notifier);
+});
diff --git a/lib/src/features/virtual_tree/services/tree_builder.dart b/lib/src/features/virtual_tree/services/tree_builder.dart
new file mode 100644
index 0000000..ba313f3
--- /dev/null
+++ b/lib/src/features/virtual_tree/services/tree_builder.dart
@@ -0,0 +1,367 @@
+import 'package:path/path.dart' as path;
+
+import '../../scan/models/scan_result.dart';
+import '../../scan/models/scanned_file.dart';
+import '../api/virtual_tree_api.dart';
+
+/// Builds a virtual tree deterministically from a list of files and metadata.
+class TreeBuilder {
+  static const String rootId = 'root';
+
+  TreeData buildTree({
+    required List<ScannedFile> files,
+    required List<ScanMetadata> scanMetadata,
+  }) {
+    final nodes = <String, TreeNode>{
+      rootId: TreeNode(
+        id: rootId,
+        name: 'Context Collection',
+        type: NodeType.root,
+        parentId: '',
+        virtualPath: '/',
+        isExpanded: true,
+      ),
+    };
+
+    if (files.isEmpty) {
+      return TreeData(nodes: nodes, rootId: rootId);
+    }
+
+    final realFiles = files.where((f) => !f.isVirtual).toList();
+    final virtualFiles = files.where((f) => f.isVirtual).toList();
+
+    _buildFromRealFiles(nodes, realFiles, scanMetadata);
+    _mergeVirtualFiles(nodes, virtualFiles);
+
+    return TreeData(nodes: nodes, rootId: rootId);
+  }
+
+  /// PASS 1: Constructs the base tree from filesystem files.
+  void _buildFromRealFiles(
+    Map<String, TreeNode> nodes,
+    List<ScannedFile> realFiles,
+    List<ScanMetadata> scanMetadata,
+  ) {
+    if (realFiles.isEmpty) return;
+
+    final allSourcePaths = scanMetadata
+        .expand((meta) => meta.sourcePaths)
+        .toSet();
+    final filesBySource = _groupFilesByMostSpecificSource(
+      realFiles,
+      allSourcePaths,
+    );
+    final sortedSourcePaths = filesBySource.keys.toList()
+      ..sort((a, b) => a.length.compareTo(b.length));
+
+    for (final sourcePath in sortedSourcePaths) {
+      final filesInGroup = filesBySource[sourcePath]!;
+      final parentId = _findBestParentForSource(sourcePath, nodes);
+      final parentNode = nodes[parentId]!;
+      final sourceFolderName = path.basename(sourcePath);
+      final sourceFolderNode = _findOrCreateFolder(
+        nodes: nodes,
+        name: sourceFolderName,
+        parentId: parentId,
+        parentVirtualPath: parentNode.virtualPath,
+        sourcePath: sourcePath,
+      );
+
+      for (final file in filesInGroup) {
+        final relativePath = path.relative(file.fullPath, from: sourcePath);
+        _addFileAndHierarchy(
+          nodes: nodes,
+          file: file,
+          baseNodeId: sourceFolderNode.id,
+          relativePath: relativePath,
+        );
+      }
+    }
+  }
+
+  /// PASS 2: Merges virtual files by finding the best home in the real tree.
+  void _mergeVirtualFiles(
+    Map<String, TreeNode> nodes,
+    List<ScannedFile> virtualFiles,
+  ) {
+    virtualFiles.sort(
+      (a, b) =>
+          (a.relativePath?.length ?? 0).compareTo(b.relativePath?.length ?? 0),
+    );
+
+    for (final file in virtualFiles) {
+      final relativePath = file.relativePath ?? file.name;
+      final parts = path
+          .split(relativePath)
+          .where((p) => p.isNotEmpty)
+          .toList();
+      if (parts.isEmpty) continue;
+
+      final folderParts = parts.take(parts.length - 1).toList();
+      final fileName = parts.last;
+
+      // Try to find the best existing entry point for this virtual file
+      String parentId = _findBestEntryPoint(nodes, folderParts);
+
+      // Calculate remaining path parts to create
+      final entryNode = nodes[parentId]!;
+      final entryParts = entryNode.virtualPath == '/'
+          ? <String>[]
+          : path
+                .split(entryNode.virtualPath)
+                .where((p) => p.isNotEmpty)
+                .toList();
+
+      final remainingParts = _getRemainingPath(folderParts, entryParts);
+
+      // Create any remaining folders
+      for (final part in remainingParts) {
+        final parentNode = nodes[parentId]!;
+        parentId = _findOrCreateFolder(
+          nodes: nodes,
+          name: part,
+          parentId: parentId,
+          parentVirtualPath: parentNode.virtualPath,
+          isVirtual: true,
+        ).id;
+      }
+
+      // Add the file
+      final parentNode = nodes[parentId]!;
+      final fileNodeId = 'node_${file.id}';
+      if (!nodes.containsKey(fileNodeId)) {
+        nodes[fileNodeId] = TreeNode(
+          id: fileNodeId,
+          name: fileName,
+          type: NodeType.file,
+          parentId: parentId,
+          virtualPath: path.join(parentNode.virtualPath, fileName),
+          sourcePath: file.fullPath,
+          fileId: file.id,
+          isVirtual: true,
+          source: FileSource.created,
+          isSelected: true,
+        );
+        parentNode.childIds.add(fileNodeId);
+      }
+    }
+  }
+
+  /// Adds a single file to the tree, creating its folder hierarchy as needed.
+  void _addFileAndHierarchy({
+    required Map<String, TreeNode> nodes,
+    required ScannedFile file,
+    required String baseNodeId,
+    required String relativePath,
+  }) {
+    final parts = path.split(relativePath).where((p) => p.isNotEmpty).toList();
+    if (parts.isEmpty) return;
+
+    String currentParentId = baseNodeId;
+    for (int i = 0; i < parts.length - 1; i++) {
+      final folderName = parts[i];
+      final parentNode = nodes[currentParentId]!;
+      currentParentId = _findOrCreateFolder(
+        nodes: nodes,
+        name: folderName,
+        parentId: currentParentId,
+        parentVirtualPath: parentNode.virtualPath,
+        isVirtual: file.isVirtual,
+      ).id;
+    }
+
+    final fileName = parts.last;
+    final parentNode = nodes[currentParentId]!;
+    final fileNodeId = 'node_${file.id}';
+
+    if (!nodes.containsKey(fileNodeId)) {
+      nodes[fileNodeId] = TreeNode(
+        id: fileNodeId,
+        name: fileName,
+        type: NodeType.file,
+        parentId: currentParentId,
+        virtualPath: path.join(parentNode.virtualPath, fileName),
+        sourcePath: file.fullPath,
+        fileId: file.id,
+        isVirtual: file.isVirtual,
+        source: file.isVirtual ? FileSource.created : FileSource.disk,
+        isSelected: true,
+      );
+      parentNode.childIds.add(fileNodeId);
+    }
+  }
+
+  Map<String, List<ScannedFile>> _groupFilesByMostSpecificSource(
+    List<ScannedFile> files,
+    Set<String> allSourcePaths,
+  ) {
+    final groups = <String, List<ScannedFile>>{};
+    for (final file in files) {
+      String? bestSourcePath;
+      for (final sourcePath in allSourcePaths) {
+        if (path.isWithin(sourcePath, file.fullPath)) {
+          if (bestSourcePath == null ||
+              sourcePath.length > bestSourcePath.length) {
+            bestSourcePath = sourcePath;
+          }
+        }
+      }
+      final groupKey = bestSourcePath ?? path.dirname(file.fullPath);
+      groups.putIfAbsent(groupKey, () => []).add(file);
+    }
+    return groups;
+  }
+
+  String _findBestParentForSource(
+    String sourcePath,
+    Map<String, TreeNode> nodes,
+  ) {
+    String bestParentId = rootId;
+    int maxMatchDepth = -1;
+    for (final node in nodes.values) {
+      if (node.type != NodeType.folder ||
+          node.isVirtual ||
+          node.sourcePath == null) {
+        continue;
+      }
+      if (path.isWithin(node.sourcePath!, sourcePath)) {
+        final depth = path.split(node.sourcePath!).length;
+        if (depth > maxMatchDepth) {
+          maxMatchDepth = depth;
+          bestParentId = node.id;
+        }
+      }
+    }
+    return bestParentId;
+  }
+
+  TreeNode _findOrCreateFolder({
+    required Map<String, TreeNode> nodes,
+    required String name,
+    required String parentId,
+    required String parentVirtualPath,
+    String? sourcePath,
+    bool isVirtual = false,
+  }) {
+    final parent = nodes[parentId]!;
+    for (final childId in parent.childIds) {
+      final child = nodes[childId];
+      if (child != null &&
+          child.name == name &&
+          child.type == NodeType.folder) {
+        // If this folder didn't have a source yet and we now know one,
+        // clone it with the new sourcePath and put it back.
+        if (sourcePath != null && child.sourcePath == null) {
+          nodes[childId] = child.copyWith(sourcePath: sourcePath);
+        }
+        return nodes[childId]!;
+      }
+    }
+    final newFolder = TreeNode(
+      name: name,
+      type: NodeType.folder,
+      parentId: parentId,
+      virtualPath: path.join(parentVirtualPath, name),
+      sourcePath: sourcePath,
+      isVirtual: isVirtual,
+      source: isVirtual ? FileSource.created : FileSource.disk,
+      isExpanded: true,
+    );
+    nodes[newFolder.id] = newFolder;
+    parent.childIds.add(newFolder.id);
+    return newFolder;
+  }
+
+  /// Finds the best existing entry point in the tree for a virtual file path.
+  /// Prefers deeper matches and suffix matches to handle cases where virtual
+  /// files were created before real directories were added.
+  String _findBestEntryPoint(
+    Map<String, TreeNode> nodes,
+    List<String> folderParts,
+  ) {
+    String bestId = rootId;
+    int bestScore = -1;
+
+    for (final node in nodes.values) {
+      if (node.type == NodeType.file) continue;
+
+      final nodeParts = node.virtualPath == '/'
+          ? <String>[]
+          : path.split(node.virtualPath).where((p) => p.isNotEmpty).toList();
+
+      if (nodeParts.isEmpty) continue; // Skip root, already handled
+
+      // Check for prefix match (folderParts starts with nodeParts)
+      final isPrefix =
+          nodeParts.length <= folderParts.length &&
+          _listStartsWith(folderParts, nodeParts);
+
+      // Check for suffix match (nodeParts ends with folderParts)
+      final isSuffix =
+          folderParts.length <= nodeParts.length &&
+          _listEndsWith(nodeParts, folderParts);
+
+      if (!isPrefix && !isSuffix) continue;
+
+      // Calculate score: suffix matches get higher score to prefer deeper paths
+      int score;
+      if (isSuffix) {
+        // Suffix match: prefer deeper nodes
+        score = folderParts.length * 2000 + nodeParts.length;
+      } else {
+        // Prefix match: standard scoring
+        score = nodeParts.length * 1000 + nodeParts.length;
+      }
+
+      if (score > bestScore) {
+        bestScore = score;
+        bestId = node.id;
+      }
+    }
+
+    return bestId;
+  }
+
+  /// Gets the remaining path parts after the entry point.
+  List<String> _getRemainingPath(
+    List<String> fullPath,
+    List<String> entryParts,
+  ) {
+    // If entry is root or fullPath is shorter, return the full path
+    if (entryParts.isEmpty || fullPath.length < entryParts.length) {
+      return fullPath;
+    }
+
+    // Check if fullPath starts with entryParts (prefix match)
+    if (_listStartsWith(fullPath, entryParts)) {
+      return fullPath.sublist(entryParts.length);
+    }
+
+    // Check if entryParts ends with fullPath (suffix match)
+    if (_listEndsWith(entryParts, fullPath)) {
+      return [];
+    }
+
+    // No match, return full path
+    return fullPath;
+  }
+
+  /// Checks if list starts with prefix.
+  bool _listStartsWith(List<String> list, List<String> prefix) {
+    if (prefix.length > list.length) return false;
+    for (int i = 0; i < prefix.length; i++) {
+      if (list[i] != prefix[i]) return false;
+    }
+    return true;
+  }
+
+  /// Checks if list ends with suffix.
+  bool _listEndsWith(List<String> list, List<String> suffix) {
+    if (suffix.length > list.length) return false;
+    final offset = list.length - suffix.length;
+    for (int i = 0; i < suffix.length; i++) {
+      if (list[offset + i] != suffix[i]) return false;
+    }
+    return true;
+  }
+}
diff --git a/lib/src/features/virtual_tree/state/tree_state.dart b/lib/src/features/virtual_tree/state/tree_state.dart
new file mode 100644
index 0000000..cdbafe4
--- /dev/null
+++ b/lib/src/features/virtual_tree/state/tree_state.dart
@@ -0,0 +1,357 @@
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:path/path.dart' as path;
+
+import '../../scan/models/scan_result.dart';
+import '../../scan/models/scanned_file.dart';
+import '../api/virtual_tree_api.dart';
+import '../services/tree_builder.dart';
+
+/// State for the virtual tree
+class TreeState {
+  const TreeState({
+    required this.nodes,
+    required this.rootId,
+    this.selectedNodeIds = const {},
+    this.expansionState = const {},
+  });
+
+  final Map<String, TreeNode> nodes;
+  final String rootId;
+  final Set<String> selectedNodeIds;
+  final Map<String, bool> expansionState;
+
+  /// Get all selected tree nodes
+  List<TreeNode> get selectedNodes =>
+      selectedNodeIds.map((id) => nodes[id]).whereType<TreeNode>().toList();
+
+  /// Get file IDs of selected file nodes
+  Set<String> get selectedFileIds => selectedNodes
+      .where((node) => node.type == NodeType.file && node.fileId != null)
+      .map((node) => node.fileId!)
+      .toSet();
+
+  /// Check if tree has any nodes
+  bool get hasNodes =>
+      nodes.isNotEmpty && nodes.length > 1; // More than just root
+
+  /// Create a copy with updated values
+  TreeState copyWith({
+    Map<String, TreeNode>? nodes,
+    String? rootId,
+    Set<String>? selectedNodeIds,
+    Map<String, bool>? expansionState,
+  }) {
+    return TreeState(
+      nodes: nodes ?? this.nodes,
+      rootId: rootId ?? this.rootId,
+      selectedNodeIds: selectedNodeIds ?? this.selectedNodeIds,
+      expansionState: expansionState ?? this.expansionState,
+    );
+  }
+}
+
+/// State notifier for virtual tree
+class TreeStateNotifier extends StateNotifier<TreeState> {
+  TreeStateNotifier() : super(const TreeState(nodes: {}, rootId: ''));
+
+  final TreeBuilder _treeBuilder = TreeBuilder();
+
+  // Scanner integration callbacks
+  void Function(String, String, String)? onNodeCreatedCallback;
+  void Function(String, String)? onNodeEditedCallback;
+  void Function(Set<String>)? onSelectionChangedCallback;
+
+  /// Build tree from files and metadata (performs a full rebuild)
+  void buildFromFiles(List<ScannedFile> files, List<ScanMetadata> metadata) {
+    // 1. Preserve the old UI state before rebuilding
+    final oldExpansionState = state.expansionState;
+    final oldSelectedFileIds = state.selectedFileIds;
+
+    // 2. Build a brand new tree from the single source of truth.
+    //    The tree builder now handles virtual file preservation internally.
+    final treeData = _treeBuilder.buildTree(
+      files: files,
+      scanMetadata: metadata,
+    );
+
+    // 3. Re-apply the preserved UI state to the new tree
+    final newNodes = treeData.nodes;
+    final newExpansionState = <String, bool>{};
+    final newSelectedNodeIds = <String>{};
+
+    for (final node in newNodes.values) {
+      // Re-apply expansion state by node ID
+      newExpansionState[node.id] =
+          oldExpansionState[node.id] ?? node.isExpanded;
+
+      // Re-apply selection state by matching the stable ScannedFile.id
+      if (node.fileId != null && oldSelectedFileIds.contains(node.fileId)) {
+        newSelectedNodeIds.add(node.id);
+      }
+    }
+
+    // Also include any files that were auto-selected during the build (i.e., new files)
+    for (final node in newNodes.values) {
+      if (node.isSelected && node.type == NodeType.file) {
+        newSelectedNodeIds.add(node.id);
+      }
+    }
+
+    // 4. Set the new, corrected state
+    state = TreeState(
+      nodes: newNodes,
+      rootId: treeData.rootId,
+      expansionState: newExpansionState,
+      selectedNodeIds: newSelectedNodeIds,
+    );
+
+    // 5. Notify the scanner that the selection may have changed
+    onSelectionChangedCallback?.call(state.selectedFileIds);
+  }
+
+  /// Toggle node (expand/collapse for folders, select/deselect for files)
+  void toggleNode(String nodeId) {
+    final node = state.nodes[nodeId];
+    if (node == null) return;
+
+    if (node.type == NodeType.file) {
+      _toggleFileSelection(nodeId);
+    } else {
+      toggleFolderExpansion(nodeId);
+    }
+  }
+
+  /// Toggle file selection
+  void _toggleFileSelection(String nodeId) {
+    final newSelection = Set<String>.from(state.selectedNodeIds);
+
+    if (newSelection.contains(nodeId)) {
+      newSelection.remove(nodeId);
+    } else {
+      newSelection.add(nodeId);
+    }
+
+    state = state.copyWith(selectedNodeIds: newSelection);
+
+    // Notify scanner of selection change - CRITICAL for content update
+    final fileIds = state.selectedFileIds;
+    onSelectionChangedCallback?.call(fileIds);
+  }
+
+  /// Toggle folder expansion
+  void toggleFolderExpansion(String nodeId) {
+    final newExpansionState = Map<String, bool>.from(state.expansionState);
+    newExpansionState[nodeId] = !(newExpansionState[nodeId] ?? true);
+
+    state = state.copyWith(expansionState: newExpansionState);
+  }
+
+  /// Check if a node is expanded
+  bool isExpanded(String nodeId) {
+    return state.expansionState[nodeId] ??
+        state.nodes[nodeId]?.isExpanded ??
+        false;
+  }
+
+  /// Select all files in a folder
+  void selectFolder(String folderId) {
+    final folder = state.nodes[folderId];
+    if (folder == null || folder.type == NodeType.file) return;
+
+    final newSelection = Set<String>.from(state.selectedNodeIds);
+
+    // Recursively collect all file nodes
+    final fileNodes = <String>[];
+    _collectFileNodes(folderId, fileNodes);
+
+    // Add all file nodes to selection
+    newSelection.addAll(fileNodes);
+
+    state = state.copyWith(selectedNodeIds: newSelection);
+
+    // Notify scanner - CRITICAL for content update
+    final fileIds = state.selectedFileIds;
+    onSelectionChangedCallback?.call(fileIds);
+  }
+
+  /// Deselect all files in a folder
+  void deselectFolder(String folderId) {
+    final folder = state.nodes[folderId];
+    if (folder == null || folder.type == NodeType.file) return;
+
+    final newSelection = Set<String>.from(state.selectedNodeIds);
+
+    // Recursively collect all file nodes
+    final fileNodes = <String>[];
+    _collectFileNodes(folderId, fileNodes);
+
+    // Remove all file nodes from selection
+    newSelection.removeAll(fileNodes);
+
+    state = state.copyWith(selectedNodeIds: newSelection);
+
+    // Notify scanner - CRITICAL for content update
+    final fileIds = state.selectedFileIds;
+    onSelectionChangedCallback?.call(fileIds);
+  }
+
+  /// Recursively collect all file node IDs under a folder
+  void _collectFileNodes(String folderId, List<String> fileNodes) {
+    final folder = state.nodes[folderId];
+    if (folder == null) return;
+
+    for (final childId in folder.childIds) {
+      final child = state.nodes[childId];
+      if (child == null) continue;
+
+      if (child.type == NodeType.file) {
+        fileNodes.add(childId);
+      } else {
+        _collectFileNodes(childId, fileNodes);
+      }
+    }
+  }
+
+  /// Create a new node (file or folder)
+  void createNode({
+    required String parentId,
+    required String name,
+    required bool isFolder,
+    String? content,
+  }) {
+    final parent = state.nodes[parentId];
+    if (parent == null) return;
+
+    // For folders, we can still create them directly as they have no file data
+    if (isFolder) {
+      final virtualPath = path.join(parent.virtualPath, name);
+      final newNode = TreeNode(
+        name: name,
+        type: NodeType.folder,
+        parentId: parentId,
+        virtualPath: virtualPath,
+        isVirtual: true,
+        source: FileSource.created,
+        isExpanded: true,
+      );
+      final newNodes = Map<String, TreeNode>.from(state.nodes);
+      newNodes[newNode.id] = newNode;
+      final updatedParent = parent.copyWith(
+        childIds: [...parent.childIds, newNode.id],
+      );
+      newNodes[parentId] = updatedParent;
+      state = state.copyWith(nodes: newNodes);
+    } else {
+      // For files, simply trigger the callback.
+      // DO NOT create a TreeNode here. Let the FileListNotifier handle it.
+      onNodeCreatedCallback?.call(parent.virtualPath, name, content ?? '');
+    }
+  }
+
+  /// Edit node content (for files)
+  void editNodeContent(String nodeId, String content) {
+    final node = state.nodes[nodeId];
+    if (node?.fileId == null || node!.type != NodeType.file) return;
+
+    // Notify scanner of content change
+    onNodeEditedCallback?.call(node.fileId!, content);
+  }
+
+  /// Update selection from scanner
+  void updateSelectionFromFileIds(Set<String> fileIds) {
+    final newSelection = <String>{};
+
+    // Find tree nodes for the given file IDs
+    for (final entry in state.nodes.entries) {
+      final node = entry.value;
+      if (node.type == NodeType.file &&
+          node.fileId != null &&
+          fileIds.contains(node.fileId)) {
+        newSelection.add(node.id);
+      }
+    }
+
+    state = state.copyWith(selectedNodeIds: newSelection);
+  }
+
+  /// Get current tree data
+  TreeData getCurrentTreeData() {
+    return TreeData(
+      nodes: state.nodes,
+      rootId: state.rootId,
+    );
+  }
+
+  /// Check if tree has nodes
+  bool hasTreeNodes() => state.nodes.isNotEmpty;
+
+  /// Get selected file IDs from current state
+  Set<String> getSelectedFileIds() => state.selectedFileIds;
+
+  /// Clear all nodes (used when scanner clears files)
+  void clearTree() {
+    state = const TreeState(
+      nodes: {},
+      rootId: TreeBuilder.rootId,
+      selectedNodeIds: {},
+      expansionState: {},
+    );
+
+    // Notify scanner of cleared selection
+    onSelectionChangedCallback?.call({});
+  }
+
+  /// Directly adds a virtual file node to the tree.
+  void addVirtualFileNode({
+    required String parentNodeId,
+    required ScannedFile file,
+  }) {
+    final parent = state.nodes[parentNodeId];
+    if (parent == null || parent.type == NodeType.file) return;
+
+    final virtualPath = path.join(parent.virtualPath, file.name);
+    final nodeId = 'node_${file.id}';
+
+    // Create the new tree node, correctly linked to the ScannedFile ID
+    final newNode = TreeNode(
+      id: nodeId,
+      name: file.name,
+      type: NodeType.file,
+      parentId: parentNodeId,
+      virtualPath: virtualPath,
+      fileId: file.id,
+      isVirtual: true,
+      source: FileSource.created,
+      isSelected: true, // Auto-select the new file
+    );
+
+    // Add the new node to the tree
+    final newNodes = Map<String, TreeNode>.from(state.nodes);
+    newNodes[newNode.id] = newNode;
+
+    // Add the new node to its parent's children list
+    final updatedParent = parent.copyWith(
+      childIds: [...parent.childIds, newNode.id],
+    );
+    newNodes[parentNodeId] = updatedParent;
+
+    // Update the selection state
+    final newSelection = Set<String>.from(state.selectedNodeIds)
+      ..add(newNode.id);
+
+    state = state.copyWith(
+      nodes: newNodes,
+      selectedNodeIds: newSelection,
+    );
+
+    // Notify the FileListNotifier that the selection has changed
+    onSelectionChangedCallback?.call(state.selectedFileIds);
+  }
+}
+
+/// Provider for tree state
+final treeStateProvider = StateNotifierProvider<TreeStateNotifier, TreeState>((
+  ref,
+) {
+  return TreeStateNotifier();
+});
diff --git a/lib/src/features/virtual_tree/ui/file_edit_dialog.dart b/lib/src/features/virtual_tree/ui/file_edit_dialog.dart
new file mode 100644
index 0000000..6aa2054
--- /dev/null
+++ b/lib/src/features/virtual_tree/ui/file_edit_dialog.dart
@@ -0,0 +1,275 @@
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+import '../../scan/ui/file_display_helper.dart';
+
+/// Dialog for editing file content
+class FileEditDialog extends StatefulWidget {
+  const FileEditDialog({
+    required this.fileName,
+    this.initialContent = '',
+    super.key,
+  });
+
+  final String fileName;
+  final String initialContent;
+
+  @override
+  State<FileEditDialog> createState() => _FileEditDialogState();
+}
+
+class _FileEditDialogState extends State<FileEditDialog> {
+  late TextEditingController _controller;
+  late FocusNode _focusNode;
+  bool _isSaving = false;
+  int _lineCount = 1;
+
+  @override
+  void initState() {
+    super.initState();
+    _controller = TextEditingController(text: widget.initialContent);
+    _focusNode = FocusNode();
+    _updateLineCount();
+    _controller.addListener(_updateLineCount);
+
+    // Auto-focus the editor
+    WidgetsBinding.instance.addPostFrameCallback((_) {
+      _focusNode.requestFocus();
+    });
+  }
+
+  @override
+  void dispose() {
+    _controller.dispose();
+    _focusNode.dispose();
+    super.dispose();
+  }
+
+  void _updateLineCount() {
+    final lines = _controller.text.split('\n').length;
+    if (lines != _lineCount) {
+      setState(() {
+        _lineCount = lines;
+      });
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final theme = Theme.of(context);
+    final extension = widget.fileName.split('.').lastOrNull ?? '';
+    final language = FileDisplayHelper.getLanguageId(extension);
+
+    return Dialog(
+      child: ConstrainedBox(
+        constraints: BoxConstraints(
+          maxWidth: 1200,
+          maxHeight: MediaQuery.of(context).size.height * 0.9,
+        ),
+        child: Column(
+          children: [
+            // Header
+            Container(
+              padding: const EdgeInsets.all(16),
+              decoration: BoxDecoration(
+                color: theme.colorScheme.surface,
+                border: Border(
+                  bottom: BorderSide(
+                    color: theme.dividerColor.addOpacity(0.5),
+                  ),
+                ),
+              ),
+              child: Row(
+                children: [
+                  Icon(
+                    FileDisplayHelper.getIconForExtension(extension),
+                    size: 20,
+                    color: FileDisplayHelper.getIconColor(extension, context),
+                  ),
+                  const SizedBox(width: 8),
+                  Expanded(
+                    child: Column(
+                      crossAxisAlignment: CrossAxisAlignment.start,
+                      children: [
+                        Text(
+                          widget.fileName,
+                          style: theme.textTheme.titleMedium?.copyWith(
+                            fontWeight: FontWeight.w600,
+                          ),
+                        ),
+                        if (language.isNotEmpty)
+                          Text(
+                            language[0].toUpperCase() + language.substring(1),
+                            style: theme.textTheme.bodySmall?.copyWith(
+                              color: theme.colorScheme.onSurface.addOpacity(
+                                0.6,
+                              ),
+                            ),
+                          ),
+                      ],
+                    ),
+                  ),
+                  Text(
+                    '$_lineCount lines',
+                    style: theme.textTheme.bodySmall?.copyWith(
+                      color: theme.colorScheme.onSurface.addOpacity(0.6),
+                    ),
+                  ),
+                ],
+              ),
+            ),
+
+            // Editor
+            Expanded(
+              child: ColoredBox(
+                color: theme.colorScheme.surface.darken(0.02),
+                child: Row(
+                  children: [
+                    // Line numbers
+                    Container(
+                      width: 50,
+                      padding: const EdgeInsets.only(right: 8, top: 12),
+                      decoration: BoxDecoration(
+                        color: theme.colorScheme.surface.darken(0.04),
+                        border: Border(
+                          right: BorderSide(
+                            color: theme.dividerColor.addOpacity(0.3),
+                          ),
+                        ),
+                      ),
+                      child: ListView.builder(
+                        itemCount: _lineCount,
+                        itemBuilder: (context, index) => Container(
+                          height: 24,
+                          alignment: Alignment.centerRight,
+                          child: Text(
+                            '${index + 1}',
+                            style: TextStyle(
+                              fontFamily: 'monospace',
+                              fontSize: 12,
+                              color: theme.colorScheme.onSurface.addOpacity(
+                                0.4,
+                              ),
+                            ),
+                          ),
+                        ),
+                      ),
+                    ),
+
+                    // Text field
+                    Expanded(
+                      child: RawKeyboardListener(
+                        focusNode: FocusNode(),
+                        onKey: (event) {
+                          // Handle Tab key
+                          if (event is RawKeyDownEvent &&
+                              event.logicalKey == LogicalKeyboardKey.tab) {
+                            final cursorPos = _controller.selection.start;
+                            final text = _controller.text;
+                            final newText =
+                                '${text.substring(0, cursorPos)}  ${text.substring(cursorPos)}';
+                            _controller.value = TextEditingValue(
+                              text: newText,
+                              selection: TextSelection.collapsed(
+                                offset: cursorPos + 2,
+                              ),
+                            );
+                          }
+                        },
+                        child: TextField(
+                          controller: _controller,
+                          focusNode: _focusNode,
+                          maxLines: null,
+                          expands: true,
+                          textAlignVertical: TextAlignVertical.top,
+                          style: const TextStyle(
+                            fontFamily: 'monospace',
+                            fontSize: 14,
+                            height: 1.7,
+                          ),
+                          decoration: InputDecoration(
+                            contentPadding: const EdgeInsets.all(12),
+                            border: InputBorder.none,
+                            hintText: 'Enter file content...',
+                            hintStyle: TextStyle(
+                              color: theme.colorScheme.onSurface.addOpacity(
+                                0.3,
+                              ),
+                            ),
+                          ),
+                        ),
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+            ),
+
+            // Actions
+            Container(
+              padding: const EdgeInsets.all(16),
+              decoration: BoxDecoration(
+                color: theme.colorScheme.surface,
+                border: Border(
+                  top: BorderSide(
+                    color: theme.dividerColor.addOpacity(0.5),
+                  ),
+                ),
+              ),
+              child: Row(
+                mainAxisAlignment: MainAxisAlignment.end,
+                children: [
+                  TextButton(
+                    onPressed: _isSaving
+                        ? null
+                        : () => Navigator.of(context).pop(),
+                    child: const Text('Cancel'),
+                  ),
+                  const SizedBox(width: 8),
+                  FilledButton.icon(
+                    onPressed: _isSaving
+                        ? null
+                        : () {
+                            setState(() {
+                              _isSaving = true;
+                            });
+                            Navigator.of(context).pop(_controller.text);
+                          },
+                    icon: _isSaving
+                        ? SizedBox(
+                            width: 16,
+                            height: 16,
+                            child: CircularProgressIndicator(
+                              strokeWidth: 2,
+                              color: theme.colorScheme.onPrimary,
+                            ),
+                          )
+                        : const Icon(Icons.save, size: 18),
+                    label: Text(_isSaving ? 'Saving...' : 'Save'),
+                  ),
+                ],
+              ),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+}
+
+/// Shows the file edit dialog and returns the edited content
+Future<String?> showFileEditDialog(
+  BuildContext context, {
+  required String fileName,
+  String initialContent = '',
+}) {
+  return showDialog<String>(
+    context: context,
+    barrierDismissible: false,
+    builder: (context) => FileEditDialog(
+      fileName: fileName,
+      initialContent: initialContent,
+    ),
+  );
+}
diff --git a/lib/src/features/virtual_tree/ui/tree_node_widget.dart b/lib/src/features/virtual_tree/ui/tree_node_widget.dart
new file mode 100644
index 0000000..137ad95
--- /dev/null
+++ b/lib/src/features/virtual_tree/ui/tree_node_widget.dart
@@ -0,0 +1,618 @@
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+import '../../scan/ui/file_display_helper.dart';
+import 'file_edit_dialog.dart';
+
+/// Folder selection state
+enum FolderSelectionState { none, partial, all }
+
+/// Widget for displaying a single tree node
+class TreeNodeWidget extends ConsumerStatefulWidget {
+  const TreeNodeWidget({
+    super.key,
+    required this.node,
+    required this.depth,
+    required this.nodes,
+  });
+
+  final TreeNode node;
+  final int depth;
+  final Map<String, TreeNode> nodes;
+
+  @override
+  ConsumerState<TreeNodeWidget> createState() => _TreeNodeWidgetState();
+}
+
+class _TreeNodeWidgetState extends ConsumerState<TreeNodeWidget> {
+  bool _isHovered = false;
+
+  @override
+  Widget build(BuildContext context) {
+    final notifier = ref.read(treeStateProvider.notifier);
+    final treeState = ref.watch(treeStateProvider);
+    final scannerFiles = ref.watch(selectionProvider).fileMap;
+
+    final isExpanded = notifier.isExpanded(widget.node.id);
+    final isSelected = treeState.selectedNodeIds.contains(widget.node.id);
+    final file = widget.node.fileId != null
+        ? scannerFiles[widget.node.fileId]
+        : null;
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        MouseRegion(
+          onEnter: (_) => setState(() => _isHovered = true),
+          onExit: (_) => setState(() => _isHovered = false),
+          child: GestureDetector(
+            onTap: () => _handleNodeTap(context, ref),
+            onSecondaryTapDown: (details) => _showContextMenu(context, details),
+            child: Container(
+              height: 32,
+              decoration: BoxDecoration(
+                color: _getBackgroundColor(context, isSelected),
+                borderRadius: BorderRadius.circular(4),
+              ),
+              child: Row(
+                children: [
+                  SizedBox(width: 16.0 * widget.depth + 8),
+
+                  // Expand/collapse icon for folders
+                  if (widget.node.type == NodeType.folder)
+                    SizedBox(
+                      width: 24,
+                      height: 24,
+                      child: IconButton(
+                        icon: Icon(
+                          isExpanded ? Icons.expand_more : Icons.chevron_right,
+                          size: 18,
+                        ),
+                        onPressed: () =>
+                            notifier.toggleFolderExpansion(widget.node.id),
+                        padding: EdgeInsets.zero,
+                        splashRadius: 12,
+                      ),
+                    )
+                  else
+                    const SizedBox(width: 24),
+
+                  // Selection checkbox (for both files and folders)
+                  if (widget.node.type != NodeType.root)
+                    SizedBox(
+                      width: 20,
+                      height: 20,
+                      child: widget.node.type == NodeType.file
+                          ? Checkbox(
+                              value: isSelected,
+                              onChanged: (value) =>
+                                  _handleSelectionChange(ref, value ?? false),
+                              materialTapTargetSize:
+                                  MaterialTapTargetSize.shrinkWrap,
+                              visualDensity: VisualDensity.compact,
+                            )
+                          : _buildFolderCheckbox(ref),
+                    ),
+
+                  const SizedBox(width: 4),
+
+                  // Node icon
+                  _buildNodeIcon(context, widget.node, file),
+
+                  const SizedBox(width: 8),
+
+                  // Node name
+                  Expanded(
+                    child: Text(
+                      widget.node.name,
+                      style: TextStyle(
+                        fontSize: 13,
+                        fontWeight: widget.node.type == NodeType.folder
+                            ? FontWeight.w600
+                            : FontWeight.normal,
+                        color: _getTextColor(context, isSelected),
+                      ),
+                      maxLines: 1,
+                      overflow: TextOverflow.ellipsis,
+                    ),
+                  ),
+
+                  // Status indicators
+                  if (file != null) ...[
+                    _buildStatusIndicator(context, file),
+                    const SizedBox(width: 8),
+                  ],
+
+                  // Hover actions
+                  if (_isHovered) ...[
+                    if (widget.node.type == NodeType.folder) ...[
+                      _buildHoverAction(
+                        icon: Icons.create_new_folder_outlined,
+                        tooltip: 'New Folder',
+                        onPressed: _createNewFolder,
+                      ),
+                      _buildHoverAction(
+                        icon: Icons.note_add_outlined,
+                        tooltip: 'New File',
+                        onPressed: _createNewFile,
+                      ),
+                    ],
+                    if (widget.node.type == NodeType.file && file != null) ...[
+                      _buildHoverAction(
+                        icon: Icons.edit_outlined,
+                        tooltip: 'Edit',
+                        onPressed: _editFile,
+                      ),
+                    ],
+                  ],
+
+                  const SizedBox(width: 8),
+                ],
+              ),
+            ),
+          ),
+        ),
+
+        // Children (if folder is expanded)
+        if (widget.node.type == NodeType.folder && isExpanded)
+          ...widget.node.childIds
+              .map((id) => widget.nodes[id])
+              .whereType<TreeNode>()
+              .map(
+                (child) => TreeNodeWidget(
+                  node: child,
+                  depth: widget.depth + 1,
+                  nodes: widget.nodes,
+                ),
+              ),
+      ],
+    );
+  }
+
+  Color _getBackgroundColor(BuildContext context, bool isSelected) {
+    final colorScheme = Theme.of(context).colorScheme;
+
+    if (isSelected) {
+      return colorScheme.primary.addOpacity(0.15);
+    } else if (_isHovered) {
+      return colorScheme.onSurface.addOpacity(0.05);
+    }
+
+    return Colors.transparent;
+  }
+
+  Color _getTextColor(BuildContext context, bool isSelected) {
+    final colorScheme = Theme.of(context).colorScheme;
+
+    if (isSelected && widget.node.type == NodeType.file) {
+      return colorScheme.primary;
+    }
+
+    return colorScheme.onSurface;
+  }
+
+  Widget _buildNodeIcon(
+    BuildContext context,
+    TreeNode node,
+    ScannedFile? file,
+  ) {
+    final colorScheme = Theme.of(context).colorScheme;
+
+    if (node.type == NodeType.folder) {
+      final isExpanded = ref
+          .read(treeStateProvider.notifier)
+          .isExpanded(node.id);
+      return Icon(
+        isExpanded ? Icons.folder_open : Icons.folder,
+        color: Colors.amber.shade700,
+        size: 20,
+      );
+    }
+
+    // File icon based on status
+    if (node.isVirtual) {
+      return Icon(
+        Icons.note_add,
+        color: Colors.green.shade600,
+        size: 18,
+      );
+    }
+
+    // Icon based on file extension
+    if (file != null) {
+      return Icon(
+        FileDisplayHelper.getIconForExtension(file.extension),
+        size: 18,
+        color: FileDisplayHelper.getIconColor(file.extension, context),
+      );
+    }
+
+    return Icon(
+      Icons.insert_drive_file,
+      size: 18,
+      color: colorScheme.onSurface.addOpacity(0.7),
+    );
+  }
+
+  Widget _buildStatusIndicator(BuildContext context, ScannedFile file) {
+    final indicator = FileDisplayHelper.buildStatusIndicator(context, file);
+    if (indicator != null) {
+      return Padding(
+        padding: const EdgeInsets.only(right: 4),
+        child: indicator,
+      );
+    }
+    return const SizedBox.shrink();
+  }
+
+  Widget _buildHoverAction({
+    required IconData icon,
+    required String tooltip,
+    required VoidCallback onPressed,
+  }) {
+    return SizedBox(
+      width: 24,
+      height: 24,
+      child: IconButton(
+        icon: Icon(icon, size: 16),
+        onPressed: onPressed,
+        tooltip: tooltip,
+        padding: EdgeInsets.zero,
+        splashRadius: 12,
+      ),
+    );
+  }
+
+  void _handleNodeTap(BuildContext context, WidgetRef ref) {
+    final notifier = ref.read(treeStateProvider.notifier);
+
+    if (widget.node.type == NodeType.folder) {
+      // For folders, toggle expansion
+      notifier.toggleFolderExpansion(widget.node.id);
+    } else {
+      // For files, toggle selection
+      notifier.toggleNode(widget.node.id);
+    }
+  }
+
+  Widget _buildFolderCheckbox(WidgetRef ref) {
+    final folderState = _getFolderSelectionState(ref);
+
+    return Checkbox(
+      value: folderState == FolderSelectionState.all
+          ? true
+          : folderState == FolderSelectionState.none
+          ? false
+          : null,
+      tristate: true,
+      onChanged: (value) {
+        // If partially selected or none selected, select all
+        // If all selected, deselect all
+        final shouldSelect = folderState != FolderSelectionState.all;
+        _handleSelectionChange(ref, shouldSelect);
+      },
+      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
+      visualDensity: VisualDensity.compact,
+    );
+  }
+
+  FolderSelectionState _getFolderSelectionState(WidgetRef ref) {
+    if (widget.node.type != NodeType.folder) return FolderSelectionState.none;
+
+    final treeState = ref.watch(treeStateProvider);
+
+    // Check selection state of all files in this folder
+    final fileNodes = <String>[];
+    _collectFileNodesInFolder(widget.node.id, fileNodes, treeState.nodes);
+
+    if (fileNodes.isEmpty) return FolderSelectionState.none;
+
+    final selectedCount = fileNodes
+        .where(treeState.selectedNodeIds.contains)
+        .length;
+
+    if (selectedCount == 0) return FolderSelectionState.none;
+    if (selectedCount == fileNodes.length) return FolderSelectionState.all;
+    return FolderSelectionState.partial;
+  }
+
+  void _collectFileNodesInFolder(
+    String folderId,
+    List<String> fileNodes,
+    Map<String, TreeNode> nodes,
+  ) {
+    final folder = nodes[folderId];
+    if (folder == null) return;
+
+    for (final childId in folder.childIds) {
+      final child = nodes[childId];
+      if (child == null) continue;
+
+      if (child.type == NodeType.file) {
+        fileNodes.add(childId);
+      } else {
+        _collectFileNodesInFolder(childId, fileNodes, nodes);
+      }
+    }
+  }
+
+  void _handleSelectionChange(WidgetRef ref, bool selected) {
+    final notifier = ref.read(treeStateProvider.notifier);
+
+    if (widget.node.type == NodeType.file) {
+      notifier.toggleNode(widget.node.id);
+    } else if (widget.node.type == NodeType.folder) {
+      if (selected) {
+        notifier.selectFolder(widget.node.id);
+      } else {
+        notifier.deselectFolder(widget.node.id);
+      }
+    }
+  }
+
+  void _showContextMenu(BuildContext context, TapDownDetails details) {
+    final RenderBox? overlay =
+        Overlay.of(context).context.findRenderObject() as RenderBox?;
+
+    if (overlay == null) {
+      return;
+    }
+
+    showMenu(
+      context: context,
+      position: RelativeRect.fromRect(
+        details.globalPosition & const Size(40, 40),
+        Offset.zero & overlay.size,
+      ),
+      items: _buildContextMenuItems(context),
+    ).then((value) {
+      if (value != null) {
+        _handleContextMenuAction(value);
+      }
+    });
+  }
+
+  List<PopupMenuEntry<String>> _buildContextMenuItems(BuildContext context) {
+    final items = <PopupMenuEntry<String>>[];
+
+    PopupMenuItem<String> menuItem(String value, IconData icon, String text) {
+      return PopupMenuItem<String>(
+        value: value,
+        child: Row(
+          children: [
+            Icon(icon, size: 18),
+            const SizedBox(width: 8),
+            Text(text),
+          ],
+        ),
+      );
+    }
+
+    if (widget.node.type == NodeType.folder) {
+      items.addAll([
+        menuItem('new_file', Icons.note_add, 'New File'),
+        menuItem('new_folder', Icons.create_new_folder, 'New Folder'),
+        const PopupMenuDivider(),
+        menuItem('select_all', Icons.select_all, 'Select All Files'),
+      ]);
+    }
+
+    if (widget.node.type == NodeType.file) {
+      items.addAll([
+        menuItem('edit', Icons.edit, 'Edit'),
+        menuItem('copy_path', Icons.content_copy, 'Copy Path'),
+      ]);
+    }
+
+    // Common actions
+    items.addAll([
+      const PopupMenuDivider(),
+      menuItem('remove', Icons.delete_outline, 'Remove'),
+    ]);
+
+    return items;
+  }
+
+  void _handleContextMenuAction(String action) {
+    final notifier = ref.read(treeStateProvider.notifier);
+
+    switch (action) {
+      case 'new_file':
+        _createNewFile();
+      case 'new_folder':
+        _createNewFolder();
+      case 'select_all':
+        notifier.selectFolder(widget.node.id);
+      case 'edit':
+        _editFile();
+      case 'copy_path':
+        _copyPath();
+      case 'remove':
+        // Use the FileListNotifier's removeNodes method for proper cleanup
+        ref.read(selectionProvider.notifier).removeNodes({widget.node.id});
+    }
+  }
+
+  void _createNewFile() {
+    // Get existing names in the parent folder
+    final parentNode = widget.node;
+    final existingNames = parentNode.childIds
+        .map((id) => widget.nodes[id]?.name)
+        .whereType<String>()
+        .toSet();
+
+    _showCreateDialog(
+      title: 'New File',
+      hint: 'Enter file name (e.g., script.js)',
+      existingNames: existingNames,
+      onConfirm: (name) async {
+        // Show the file edit dialog
+        final content = await showFileEditDialog(
+          context,
+          fileName: name,
+          initialContent: '',
+        );
+
+        // If content is not null (user clicked Save), create the file
+        if (content != null) {
+          // We now call the FileListNotifier, not the TreeStateNotifier.
+          // We pass the PARENT NODE ID so the tree knows where to put the new file.
+          ref
+              .read(selectionProvider.notifier)
+              .onVirtualFileCreated(
+                widget.node.id, // The ID of the folder node we clicked on
+                name,
+                content,
+              );
+        }
+      },
+    );
+  }
+
+  void _createNewFolder() {
+    // Get existing names in the parent folder
+    final parentNode = widget.node;
+    final existingNames = parentNode.childIds
+        .map((id) => widget.nodes[id]?.name)
+        .whereType<String>()
+        .toSet();
+
+    _showCreateDialog(
+      title: 'New Folder',
+      hint: 'Enter folder name',
+      existingNames: existingNames,
+      onConfirm: (name) {
+        ref
+            .read(selectionProvider.notifier)
+            .onVirtualFolderCreated(
+              widget.node.id,
+              name,
+            );
+      },
+    );
+  }
+
+  Future<void> _editFile() async {
+    // Get the ScannedFile from the selection provider
+    final file = ref.read(selectionProvider).fileMap[widget.node.fileId];
+    if (file == null) return;
+
+    // Check for large file
+    const int largeFileThreshold = 2 * 1024 * 1024; // 2MB
+
+    if (file.size > largeFileThreshold) {
+      final proceed = await showDialog<bool>(
+        context: context,
+        builder: (context) => AlertDialog(
+          title: const Text('Warning: Large File'),
+          content: Text(
+            'This file is ${FileDisplayHelper.formatFileSize(file.size)} and may cause performance issues. '
+            'Do you want to proceed?',
+          ),
+          actions: [
+            TextButton(
+              onPressed: () => Navigator.of(context).pop(false),
+              child: const Text('Cancel'),
+            ),
+            FilledButton(
+              onPressed: () => Navigator.of(context).pop(true),
+              child: const Text('Proceed'),
+            ),
+          ],
+        ),
+      );
+
+      if (proceed != true) {
+        return; // User cancelled
+      }
+    }
+
+    // Show the file edit dialog
+    final newContent = await showFileEditDialog(
+      context,
+      fileName: FileDisplayHelper.getDisplayName(file),
+      initialContent: file.effectiveContent,
+    );
+
+    // If newContent is not null and different, update the file
+    if (newContent != null && newContent != file.effectiveContent) {
+      ref
+          .read(treeStateProvider.notifier)
+          .editNodeContent(widget.node.id, newContent);
+    }
+  }
+
+  void _copyPath() {
+    final path = widget.node.sourcePath ?? widget.node.virtualPath;
+    Clipboard.setData(ClipboardData(text: path));
+
+    ScaffoldMessenger.of(context).showSnackBar(
+      SnackBar(content: Text('Copied: $path')),
+    );
+  }
+
+  void _showCreateDialog({
+    required String title,
+    required String hint,
+    required Set<String> existingNames,
+    required void Function(String) onConfirm,
+  }) {
+    final controller = TextEditingController();
+    final formKey = GlobalKey<FormState>();
+
+    showDialog<void>(
+      context: context,
+      builder: (context) => AlertDialog(
+        title: Text(title),
+        content: Form(
+          key: formKey,
+          child: TextFormField(
+            controller: controller,
+            autofocus: true,
+            decoration: InputDecoration(
+              hintText: hint,
+              border: const OutlineInputBorder(),
+            ),
+            validator: (value) {
+              if (value == null || value.trim().isEmpty) {
+                return 'Name cannot be empty';
+              }
+              if (existingNames.contains(value.trim())) {
+                return 'A file or folder with this name already exists';
+              }
+              // Check for invalid file name characters
+              if (RegExp(r'[\\/:*?"<>|]').hasMatch(value.trim())) {
+                return 'Name contains invalid characters';
+              }
+              return null;
+            },
+            onFieldSubmitted: (_) {
+              if (formKey.currentState!.validate()) {
+                Navigator.of(context).pop();
+                onConfirm(controller.text.trim());
+              }
+            },
+          ),
+        ),
+        actions: [
+          TextButton(
+            onPressed: () => Navigator.of(context).pop(),
+            child: const Text('Cancel'),
+          ),
+          FilledButton(
+            onPressed: () {
+              if (formKey.currentState!.validate()) {
+                Navigator.of(context).pop();
+                onConfirm(controller.text.trim());
+              }
+            },
+            child: const Text('Create'),
+          ),
+        ],
+      ),
+    );
+  }
+}
diff --git a/lib/src/features/virtual_tree/ui/virtual_tree_view.dart b/lib/src/features/virtual_tree/ui/virtual_tree_view.dart
new file mode 100644
index 0000000..8a2abaa
--- /dev/null
+++ b/lib/src/features/virtual_tree/ui/virtual_tree_view.dart
@@ -0,0 +1,184 @@
+import 'package:context_collector/src/features/scan/state/file_list_state.dart';
+import 'package:context_collector/src/features/virtual_tree/services/tree_builder.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+import '../models/tree_node.dart';
+import '../state/tree_state.dart';
+import 'tree_node_widget.dart';
+
+/// Main virtual tree view widget
+class VirtualTreeView extends ConsumerWidget {
+  const VirtualTreeView({super.key});
+
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    final treeState = ref.watch(treeStateProvider);
+    final selectionState = ref.watch(selectionProvider);
+    final selectionNotifier = ref.read(selectionProvider.notifier);
+    final rootNode = treeState.nodes[treeState.rootId];
+
+    if (rootNode == null || !treeState.hasNodes) {
+      return Center(
+        child: Column(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            Icon(
+              Icons.account_tree_rounded,
+              size: 64,
+              color: Theme.of(context).colorScheme.primary.addOpacity(0.3),
+            ),
+            const SizedBox(height: 16),
+            Text(
+              'No files in tree',
+              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
+                color: Theme.of(context).colorScheme.onSurface.addOpacity(0.6),
+              ),
+            ),
+            const SizedBox(height: 8),
+            Text(
+              'Drop files or folders to get started',
+              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
+                color: Theme.of(context).colorScheme.onSurface.addOpacity(0.5),
+              ),
+            ),
+          ],
+        ),
+      );
+    }
+
+    // Determine the state for the master checkbox
+    final totalCount = selectionState.totalFilesCount;
+    final selectedCount = selectionState.selectedFilesCount;
+    bool? isChecked; // null is the indeterminate state
+    if (selectedCount > 0 && selectedCount < totalCount) {
+      isChecked = null;
+    } else if (selectedCount == totalCount && totalCount > 0) {
+      isChecked = true;
+    } else {
+      isChecked = false;
+    }
+
+    return Column(
+      children: [
+        // Tree header/toolbar with master checkbox
+        Tooltip(
+          message: '$selectedCount / $totalCount files selected',
+          child: Container(
+            height: 48,
+            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
+            decoration: BoxDecoration(
+              color: Theme.of(context).colorScheme.surface,
+              border: Border(
+                bottom: BorderSide(
+                  color: Theme.of(context).dividerColor.addOpacity(0.5),
+                ),
+              ),
+            ),
+            child: Row(
+              children: [
+                // Master checkbox
+                Checkbox(
+                  value: isChecked,
+                  tristate: true,
+                  onChanged: (value) {
+                    // When clicked, if it's not already fully checked, select all.
+                    // Otherwise, deselect all.
+                    if (isChecked ?? false) {
+                      selectionNotifier.deselectAll();
+                    } else {
+                      selectionNotifier.selectAll();
+                    }
+                  },
+                ),
+                const SizedBox(width: 4),
+                Icon(
+                  Icons.account_tree_rounded,
+                  size: 20,
+                  color: Theme.of(
+                    context,
+                  ).colorScheme.onSurface.addOpacity(0.7),
+                ),
+                const SizedBox(width: 8),
+                Text(
+                  'File Tree',
+                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
+                    fontWeight: FontWeight.w600,
+                  ),
+                ),
+                const Spacer(),
+                // Tree actions
+                IconButton(
+                  icon: const Icon(Icons.unfold_more_rounded, size: 20),
+                  onPressed: () => _expandAll(ref),
+                  tooltip: 'Expand All',
+                  padding: const EdgeInsets.all(8),
+                  constraints: const BoxConstraints(),
+                  splashRadius: 20,
+                ),
+                const SizedBox(width: 4),
+                IconButton(
+                  icon: const Icon(Icons.unfold_less_rounded, size: 20),
+                  onPressed: () => _collapseAll(ref),
+                  tooltip: 'Collapse All',
+                  padding: const EdgeInsets.all(8),
+                  constraints: const BoxConstraints(),
+                  splashRadius: 20,
+                ),
+              ],
+            ),
+          ),
+        ),
+
+        // Tree content
+        Expanded(
+          child: SingleChildScrollView(
+            padding: const EdgeInsets.symmetric(vertical: 8),
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: rootNode.childIds
+                  .map((childId) => treeState.nodes[childId])
+                  .whereType<TreeNode>()
+                  .map(
+                    (child) => TreeNodeWidget(
+                      node: child,
+                      depth: 0,
+                      nodes: treeState.nodes,
+                    ),
+                  )
+                  .toList(),
+            ),
+          ),
+        ),
+      ],
+    );
+  }
+
+  void _expandAll(WidgetRef ref) {
+    final notifier = ref.read(treeStateProvider.notifier);
+    final nodes = ref.read(treeStateProvider).nodes;
+
+    // Expand all folders
+    for (final node in nodes.values) {
+      if (node.type == NodeType.folder && !notifier.isExpanded(node.id)) {
+        notifier.toggleFolderExpansion(node.id);
+      }
+    }
+  }
+
+  void _collapseAll(WidgetRef ref) {
+    final notifier = ref.read(treeStateProvider.notifier);
+    final nodes = ref.read(treeStateProvider).nodes;
+
+    // Collapse all folders except root children
+    for (final node in nodes.values) {
+      if (node.type == NodeType.folder && node.parentId != TreeBuilder.rootId) {
+        final isExpanded = notifier.isExpanded(node.id);
+        if (isExpanded) {
+          notifier.toggleFolderExpansion(node.id);
+        }
+      }
+    }
+  }
+}
diff --git a/lib/src/features/virtual_tree/virtual_tree.dart b/lib/src/features/virtual_tree/virtual_tree.dart
new file mode 100644
index 0000000..4bc91ff
--- /dev/null
+++ b/lib/src/features/virtual_tree/virtual_tree.dart
@@ -0,0 +1,16 @@
+// Virtual tree feature exports
+
+// API
+export 'api/virtual_tree_api.dart';
+export 'api/virtual_tree_impl.dart';
+// Models
+export 'models/tree_node.dart';
+// Providers
+export 'providers/virtual_tree_provider.dart';
+// Services
+export 'services/tree_builder.dart';
+// State
+export 'state/tree_state.dart';
+export 'ui/tree_node_widget.dart';
+// UI
+export 'ui/virtual_tree_view.dart';
diff --git a/lib/src/shared/design_system/design_system.dart b/lib/src/shared/design_system/design_system.dart
new file mode 100644
index 0000000..7d0d723
--- /dev/null
+++ b/lib/src/shared/design_system/design_system.dart
@@ -0,0 +1,52 @@
+/// Design System for Context Collector
+/// Centralizes all design tokens and common UI patterns
+library;
+
+import 'package:context_collector/context_collector.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+
+part 'ds_colors.dart';
+part 'ds_dimensions.dart';
+part 'ds_extensions.dart';
+part 'ds_helpers.dart';
+part 'ds_text_styles.dart';
+part 'ds_widgets.dart';
+
+/// Design System configuration
+class DesignSystem {
+  const DesignSystem._();
+
+  // Border Radii
+  static const radiusSmall = 4.0;
+  static const radiusMedium = 8.0;
+  static const radiusLarge = 12.0;
+  static const radiusXLarge = 16.0;
+
+  // Spacing
+  static const space4 = 4.0;
+  static const space8 = 8.0;
+  static const space12 = 12.0;
+  static const space16 = 16.0;
+  static const space20 = 20.0;
+  static const space24 = 24.0;
+  static const space32 = 32.0;
+
+  // Icon Sizes
+  static const iconSizeSmall = 16.0;
+  static const iconSizeMedium = 20.0;
+  static const iconSizeLarge = 24.0;
+  static const iconSizeXLarge = 28.0;
+
+  // Common Durations
+  static const durationFast = Duration(milliseconds: 200);
+  static const durationMedium = Duration(milliseconds: 300);
+  static const durationSlow = Duration(milliseconds: 500);
+
+  // Opacity values
+  static const opacityDisabled = 0.38;
+  static const opacityHover = 0.04;
+  static const opacityPressed = 0.12;
+  static const opacityOverlay = 0.8;
+  static const opacityBorder = 0.2;
+}
diff --git a/lib/src/shared/design_system/ds_colors.dart b/lib/src/shared/design_system/ds_colors.dart
new file mode 100644
index 0000000..0cc5290
--- /dev/null
+++ b/lib/src/shared/design_system/ds_colors.dart
@@ -0,0 +1,17 @@
+part of 'design_system.dart';
+
+/// Design System color utilities
+extension DsColors on BuildContext {
+  // Quick color helpers with opacity
+  Color addOpacity(Color color, double opacity) => color.addOpacity(opacity);
+
+  Color get hoverColor => onSurface.addOpacity(DesignSystem.opacityHover);
+  Color get pressedColor => onSurface.addOpacity(DesignSystem.opacityPressed);
+  Color get borderColor => onSurface.addOpacity(DesignSystem.opacityBorder);
+  Color get disabledColor => onSurface.addOpacity(DesignSystem.opacityDisabled);
+
+  // Common overlay colors
+  Color get primaryOverlay => primary.addOpacity(0.1);
+  Color get errorOverlay => error.addOpacity(0.1);
+  Color get successOverlay => Colors.green.addOpacity(0.1);
+}
diff --git a/lib/src/shared/design_system/ds_dimensions.dart b/lib/src/shared/design_system/ds_dimensions.dart
new file mode 100644
index 0000000..a92e748
--- /dev/null
+++ b/lib/src/shared/design_system/ds_dimensions.dart
@@ -0,0 +1,48 @@
+part of 'design_system.dart';
+
+/// Common dimension configurations
+class DsDimensions {
+  const DsDimensions._();
+
+  // Button dimensions
+  static const buttonHeightSmall = 32.0;
+  static const buttonHeightMedium = 40.0;
+  static const buttonHeightLarge = 48.0;
+
+  // Input field dimensions
+  static const inputHeightSmall = 36.0;
+  static const inputHeightMedium = 44.0;
+  static const inputHeightLarge = 52.0;
+
+  // Common paddings
+  static const paddingSmall = EdgeInsets.all(8);
+  static const paddingMedium = EdgeInsets.all(16);
+  static const paddingLarge = EdgeInsets.all(24);
+
+  static const paddingHorizontalSmall = EdgeInsets.symmetric(horizontal: 8);
+  static const paddingHorizontalMedium = EdgeInsets.symmetric(horizontal: 16);
+  static const paddingHorizontalLarge = EdgeInsets.symmetric(horizontal: 24);
+
+  static const paddingVerticalSmall = EdgeInsets.symmetric(vertical: 8);
+  static const paddingVerticalMedium = EdgeInsets.symmetric(vertical: 16);
+  static const paddingVerticalLarge = EdgeInsets.symmetric(vertical: 24);
+
+  // List item paddings
+  static const listItemPadding = EdgeInsets.symmetric(
+    horizontal: 16,
+    vertical: 12,
+  );
+  static const listItemPaddingCompact = EdgeInsets.symmetric(
+    horizontal: 12,
+    vertical: 8,
+  );
+
+  // Dialog dimensions
+  static const dialogWidth = 900.0;
+  static const dialogHeight = 700.0;
+  static const dialogPadding = EdgeInsets.all(24);
+
+  // Sidebar dimensions
+  static const sidebarWidth = 280.0;
+  static const sidebarPadding = EdgeInsets.all(16);
+}
diff --git a/lib/src/shared/design_system/ds_extensions.dart b/lib/src/shared/design_system/ds_extensions.dart
new file mode 100644
index 0000000..c191f8a
--- /dev/null
+++ b/lib/src/shared/design_system/ds_extensions.dart
@@ -0,0 +1,113 @@
+part of 'design_system.dart';
+
+/// Main Design System extension on BuildContext
+extension DesignSystemExtension on BuildContext {
+  DesignSystemTheme get ds => DesignSystemTheme._(this);
+}
+
+/// Design System theme access
+class DesignSystemTheme {
+  const DesignSystemTheme._(this._context);
+  final BuildContext _context;
+
+  // Borders
+  Border get borderDefault => Border.all(color: _context.borderColor);
+  Border get borderPrimary => Border.all(color: _context.primary);
+  Border get borderError => Border.all(color: _context.error);
+
+  BorderRadius get radiusSmall =>
+      BorderRadius.circular(DesignSystem.radiusSmall);
+  BorderRadius get radiusMedium =>
+      BorderRadius.circular(DesignSystem.radiusMedium);
+  BorderRadius get radiusLarge =>
+      BorderRadius.circular(DesignSystem.radiusLarge);
+  BorderRadius get radiusXLarge =>
+      BorderRadius.circular(DesignSystem.radiusXLarge);
+
+  // Box Decorations
+  BoxDecoration get cardDecoration => BoxDecoration(
+    color: _context.surface,
+    borderRadius: radiusMedium,
+    border: borderDefault,
+  );
+
+  BoxDecoration get containerDecoration => BoxDecoration(
+    color: _context.surfaceContainerHighest,
+    borderRadius: radiusLarge,
+    border: borderDefault,
+  );
+
+  BoxDecoration get primaryContainerDecoration => BoxDecoration(
+    color: _context.primaryOverlay,
+    borderRadius: radiusMedium,
+    border: Border.all(color: _context.primary.addOpacity(0.3)),
+  );
+
+  BoxDecoration get errorContainerDecoration => BoxDecoration(
+    color: _context.errorOverlay,
+    borderRadius: radiusMedium,
+    border: Border.all(color: _context.error.addOpacity(0.3)),
+  );
+
+  // Shadows
+  List<BoxShadow> get shadowSmall => [
+    BoxShadow(
+      color: _context.shadow.addOpacity(0.05),
+      offset: const Offset(0, 2),
+      blurRadius: 4,
+    ),
+  ];
+
+  List<BoxShadow> get shadowMedium => [
+    BoxShadow(
+      color: _context.shadow.addOpacity(0.1),
+      offset: const Offset(0, 4),
+      blurRadius: 8,
+    ),
+  ];
+
+  List<BoxShadow> get shadowLarge => [
+    BoxShadow(
+      color: _context.shadow.addOpacity(0.15),
+      offset: const Offset(0, 8),
+      blurRadius: 16,
+    ),
+  ];
+
+  // Spacing helpers
+  SizedBox get spaceSmall =>
+      const SizedBox(height: DesignSystem.space8, width: DesignSystem.space8);
+  SizedBox get spaceMedium =>
+      const SizedBox(height: DesignSystem.space16, width: DesignSystem.space16);
+  SizedBox get spaceLarge =>
+      const SizedBox(height: DesignSystem.space24, width: DesignSystem.space24);
+
+  SizedBox spaceHeight(double height) => SizedBox(height: height);
+  SizedBox spaceWidth(double width) => SizedBox(width: width);
+
+  // Common widget styles
+  ButtonStyle get textButtonStyle => TextButton.styleFrom(
+    splashFactory: NoSplash.splashFactory,
+    overlayColor: Colors.transparent,
+    foregroundColor: _context.primary,
+  );
+
+  ButtonStyle get outlinedButtonStyle => OutlinedButton.styleFrom(
+    side: BorderSide(color: _context.primary),
+    splashFactory: NoSplash.splashFactory,
+  );
+
+  ButtonStyle get filledButtonStyle => FilledButton.styleFrom(
+    splashFactory: NoSplash.splashFactory,
+  );
+
+  // Icon button style helper
+  ButtonStyle iconButtonStyle({
+    Color? backgroundColor,
+    Color? foregroundColor,
+  }) => IconButton.styleFrom(
+    backgroundColor: backgroundColor,
+    foregroundColor: foregroundColor,
+    highlightColor: Colors.transparent,
+  );
+}
diff --git a/lib/src/shared/design_system/ds_helpers.dart b/lib/src/shared/design_system/ds_helpers.dart
new file mode 100644
index 0000000..c21a5d3
--- /dev/null
+++ b/lib/src/shared/design_system/ds_helpers.dart
@@ -0,0 +1,113 @@
+part of 'design_system.dart';
+
+/// Helper functions for common UI patterns
+extension DsHelpers on BuildContext {
+  // Snackbar helpers
+  void showOk(String message, {Duration? duration}) {
+    ScaffoldMessenger.of(this).showSnackBar(
+      SnackBar(
+        content: Row(
+          children: [
+            Icon(
+              Icons.check_circle,
+              color: Theme.of(this).colorScheme.onPrimary,
+              size: 20,
+            ),
+            const SizedBox(width: 8),
+            Text(message),
+          ],
+        ),
+        backgroundColor: Theme.of(this).colorScheme.primary,
+        behavior: SnackBarBehavior.floating,
+        duration: duration ?? const Duration(seconds: 2),
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.circular(8),
+        ),
+      ),
+    );
+  }
+
+  void showErr(String message, {Duration? duration}) {
+    ScaffoldMessenger.of(this).showSnackBar(
+      SnackBar(
+        content: Text(message),
+        backgroundColor: Theme.of(this).colorScheme.error,
+        behavior: SnackBarBehavior.floating,
+        duration: duration ?? const Duration(seconds: 3),
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.circular(8),
+        ),
+      ),
+    );
+  }
+
+  void showInfo(String message, {Duration? duration}) {
+    ScaffoldMessenger.of(this).showSnackBar(
+      SnackBar(
+        content: Text(message),
+        backgroundColor: Theme.of(this).colorScheme.surfaceContainerHighest,
+        behavior: SnackBarBehavior.floating,
+        duration: duration ?? const Duration(seconds: 2),
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.circular(8),
+        ),
+      ),
+    );
+  }
+
+  // Dialog helpers
+  Future<bool> showConfirmDialog({
+    required String title,
+    required String message,
+    String confirmText = 'Confirm',
+    String cancelText = 'Cancel',
+    bool isDestructive = false,
+  }) async {
+    final result = await showDialog<bool>(
+      context: this,
+      builder: (context) => AlertDialog(
+        title: Text(title),
+        content: Text(message),
+        actions: [
+          TextButton(
+            onPressed: () => Navigator.of(context).pop(false),
+            child: Text(cancelText),
+          ),
+          TextButton(
+            onPressed: () => Navigator.of(context).pop(true),
+            style: isDestructive
+                ? TextButton.styleFrom(
+                    foregroundColor: Theme.of(context).colorScheme.error,
+                  )
+                : null,
+            child: Text(confirmText),
+          ),
+        ],
+      ),
+    );
+    return result ?? false;
+  }
+}
+
+/// Numeric formatting extensions
+extension NumFormat on num {
+  /// Format number with thousand separators
+  String comma() {
+    return toString().replaceAllMapped(
+      RegExp(r'(\d{1,3})(?=(\d{3})+(?!\d))'),
+      (Match m) => '${m[1]},',
+    );
+  }
+
+  /// Format number in compact form (1.2k, 3.4M, etc)
+  String compact() {
+    if (this < 1000) return '$this';
+    if (this < 10000) return '${(this / 1000).toStringAsFixed(1)}k';
+    if (this < 1000000) return '${(this / 1000).toStringAsFixed(0)}k';
+    if (this < 10000000) return '${(this / 1000000).toStringAsFixed(1)}M';
+    return '${(this / 1000000).toStringAsFixed(0)}M';
+  }
+
+  /// Clamp value between min and max
+  T clampTo<T extends num>(T min, T max) => clamp(min, max) as T;
+}
diff --git a/lib/src/shared/design_system/ds_text_styles.dart b/lib/src/shared/design_system/ds_text_styles.dart
new file mode 100644
index 0000000..80b741a
--- /dev/null
+++ b/lib/src/shared/design_system/ds_text_styles.dart
@@ -0,0 +1,27 @@
+part of 'design_system.dart';
+
+/// Text style utilities
+extension DsTextStyles on BuildContext {
+  // Common text style modifications
+  TextStyle? withWeight(TextStyle? style, FontWeight weight) =>
+      style?.copyWith(fontWeight: weight);
+
+  TextStyle? withColor(TextStyle? style, Color color) =>
+      style?.copyWith(color: color);
+
+  TextStyle? withSize(TextStyle? style, double size) =>
+      style?.copyWith(fontSize: size);
+
+  // Pre-configured text styles
+  TextStyle? get labelBold => withWeight(labelLarge, FontWeight.w600);
+  TextStyle? get labelMuted => withColor(labelMedium, onSurfaceVariant);
+  TextStyle? get bodyMuted =>
+      withColor(bodyMedium, onSurfaceVariant.addOpacity(0.7));
+  TextStyle? get titleBold => withWeight(titleMedium, FontWeight.w600);
+
+  // Monospace text style
+  TextStyle? monoStyle([double? size]) => TextStyle(
+    fontFamily: 'monospace',
+    fontSize: size ?? 14,
+  );
+}
diff --git a/lib/src/shared/design_system/ds_widgets.dart b/lib/src/shared/design_system/ds_widgets.dart
new file mode 100644
index 0000000..90b9299
--- /dev/null
+++ b/lib/src/shared/design_system/ds_widgets.dart
@@ -0,0 +1,681 @@
+part of 'design_system.dart';
+
+/// Base Design System Card widget
+class DsCard extends StatelessWidget {
+  const DsCard({
+    required this.child,
+    super.key,
+    this.padding,
+    this.margin,
+    this.decoration,
+    this.onTap,
+  });
+
+  final Widget child;
+  final EdgeInsetsGeometry? padding;
+  final EdgeInsetsGeometry? margin;
+  final BoxDecoration? decoration;
+  final VoidCallback? onTap;
+
+  @override
+  Widget build(BuildContext context) {
+    final container = Container(
+      padding: padding ?? DsDimensions.paddingMedium,
+      margin: margin,
+      decoration: decoration ?? context.ds.cardDecoration,
+      child: child,
+    );
+
+    if (onTap != null) {
+      return InkWell(
+        onTap: onTap,
+        borderRadius:
+            (decoration ?? context.ds.cardDecoration).borderRadius
+                as BorderRadius?,
+        child: container,
+      );
+    }
+    return container;
+  }
+}
+
+/// Base Design System Tile widget
+class DsTile extends StatelessWidget {
+  const DsTile({
+    required this.title,
+    super.key,
+    this.subtitle,
+    this.leading,
+    this.trailing,
+    this.onTap,
+    this.padding,
+    this.isSelected = false,
+  });
+
+  final Widget title;
+  final Widget? subtitle;
+  final Widget? leading;
+  final Widget? trailing;
+  final VoidCallback? onTap;
+  final EdgeInsetsGeometry? padding;
+  final bool isSelected;
+
+  @override
+  Widget build(BuildContext context) {
+    return Material(
+      color: isSelected ? context.primaryOverlay : Colors.transparent,
+      borderRadius: context.ds.radiusMedium,
+      child: InkWell(
+        onTap: onTap,
+        borderRadius: context.ds.radiusMedium,
+        splashColor: Colors.transparent,
+        highlightColor: Colors.transparent,
+        hoverColor: context.hoverColor,
+        child: Padding(
+          padding: padding ?? DsDimensions.listItemPaddingCompact,
+          child: Row(
+            children: [
+              if (leading != null) ...[
+                leading!,
+                context.ds.spaceWidth(DesignSystem.space12),
+              ],
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    DefaultTextStyle(
+                      style: context.bodyMedium!,
+                      child: title,
+                    ),
+                    if (subtitle != null) ...[
+                      context.ds.spaceHeight(DesignSystem.space4),
+                      DefaultTextStyle(
+                        style: context.bodyMuted!,
+                        child: subtitle!,
+                      ),
+                    ],
+                  ],
+                ),
+              ),
+              if (trailing != null) ...[
+                context.ds.spaceWidth(DesignSystem.space12),
+                trailing!,
+              ],
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+/// Base Design System Switch widget
+class DsSwitch extends StatelessWidget {
+  const DsSwitch({
+    required this.value,
+    required this.onChanged,
+    super.key,
+    this.activeColor,
+  });
+
+  final bool value;
+  final ValueChanged<bool> onChanged;
+  final Color? activeColor;
+
+  @override
+  Widget build(BuildContext context) {
+    return Switch(
+      value: value,
+      onChanged: onChanged,
+      activeColor: activeColor ?? context.primary,
+      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
+    );
+  }
+}
+
+/// Base Design System Dropdown widget
+class DsDropdown<T> extends StatelessWidget {
+  const DsDropdown({
+    required this.value,
+    required this.items,
+    required this.onChanged,
+    super.key,
+    this.isExpanded = true,
+    this.decoration,
+    this.padding,
+  });
+
+  final T value;
+  final List<DropdownMenuItem<T>> items;
+  final ValueChanged<T?> onChanged;
+  final bool isExpanded;
+  final BoxDecoration? decoration;
+  final EdgeInsetsGeometry? padding;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      decoration:
+          decoration ??
+          BoxDecoration(
+            color: context.surface,
+            borderRadius: context.ds.radiusMedium,
+          ),
+      child: DropdownButtonHideUnderline(
+        child: DropdownButton<T>(
+          isExpanded: isExpanded,
+          value: value,
+          items: items,
+          onChanged: onChanged,
+          padding:
+              padding ??
+              const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
+          borderRadius: context.ds.radiusMedium,
+          dropdownColor: context.surface,
+        ),
+      ),
+    );
+  }
+}
+
+/// Base Design System Button widget
+class DsButton extends StatelessWidget {
+  const DsButton({
+    required this.onPressed,
+    required this.child,
+    super.key,
+    this.icon,
+    this.style,
+    this.isOutlined = false,
+    this.isFilled = false,
+  });
+
+  final VoidCallback? onPressed;
+  final Widget child;
+  final Widget? icon;
+  final ButtonStyle? style;
+  final bool isOutlined;
+  final bool isFilled;
+
+  @override
+  Widget build(BuildContext context) {
+    if (icon != null) {
+      if (isFilled) {
+        return FilledButton.icon(
+          onPressed: onPressed,
+          icon: icon,
+          label: child,
+          style: style ?? context.ds.filledButtonStyle,
+        );
+      } else if (isOutlined) {
+        return OutlinedButton.icon(
+          onPressed: onPressed,
+          icon: icon,
+          label: child,
+          style: style ?? context.ds.outlinedButtonStyle,
+        );
+      } else {
+        return TextButton.icon(
+          onPressed: onPressed,
+          icon: icon,
+          label: child,
+          style: style ?? context.ds.textButtonStyle,
+        );
+      }
+    }
+
+    if (isFilled) {
+      return FilledButton(
+        onPressed: onPressed,
+        style: style ?? context.ds.filledButtonStyle,
+        child: child,
+      );
+    } else if (isOutlined) {
+      return OutlinedButton(
+        onPressed: onPressed,
+        style: style ?? context.ds.outlinedButtonStyle,
+        child: child,
+      );
+    } else {
+      return TextButton(
+        onPressed: onPressed,
+        style: style ?? context.ds.textButtonStyle,
+        child: child,
+      );
+    }
+  }
+}
+
+/// Section header widget using Design System
+class DsSectionHeader extends StatelessWidget {
+  const DsSectionHeader({
+    required this.title,
+    super.key,
+    this.subtitle,
+    this.trailing,
+  });
+
+  final String title;
+  final String? subtitle;
+  final Widget? trailing;
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      children: [
+        Expanded(
+          child: Column(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              Text(title, style: context.titleBold),
+              if (subtitle != null) ...[
+                context.ds.spaceHeight(DesignSystem.space4),
+                Text(subtitle!, style: context.bodyMuted),
+              ],
+            ],
+          ),
+        ),
+        if (trailing != null) trailing!,
+      ],
+    );
+  }
+}
+
+/// Divider with consistent styling
+class DsDivider extends StatelessWidget {
+  const DsDivider({super.key, this.height, this.indent, this.endIndent});
+
+  final double? height;
+  final double? indent;
+  final double? endIndent;
+
+  @override
+  Widget build(BuildContext context) {
+    return Divider(
+      color: context.borderColor,
+      height: height ?? 1,
+      indent: indent,
+      endIndent: endIndent,
+    );
+  }
+}
+
+/// Chip/Badge component for status, tags, and labels
+class DsChip extends StatelessWidget {
+  const DsChip({
+    required this.label,
+    super.key,
+    this.backgroundColor,
+    this.textColor,
+    this.icon,
+    this.onTap,
+    this.onDeleted,
+    this.dense = false,
+    this.outlined = false,
+  });
+
+  final String label;
+  final Color? backgroundColor;
+  final Color? textColor;
+  final Widget? icon;
+  final VoidCallback? onTap;
+  final VoidCallback? onDeleted;
+  final bool dense;
+  final bool outlined;
+
+  @override
+  Widget build(BuildContext context) {
+    final bgColor = backgroundColor ?? context.primaryContainer.addOpacity(0.3);
+    final fgColor = textColor ?? context.onSurface;
+
+    final content = Row(
+      mainAxisSize: MainAxisSize.min,
+      children: [
+        if (icon != null) ...[
+          icon!,
+          context.ds.spaceWidth(DesignSystem.space4),
+        ],
+        Text(
+          label,
+          style: (dense ? context.labelSmall : context.labelMedium)?.copyWith(
+            color: fgColor,
+            fontWeight: FontWeight.w500,
+          ),
+        ),
+        if (onDeleted != null) ...[
+          context.ds.spaceWidth(DesignSystem.space4),
+          InkWell(
+            onTap: onDeleted,
+            borderRadius: BorderRadius.circular(10),
+            child: Icon(
+              Icons.close_rounded,
+              size: dense ? 14 : 16,
+              color: fgColor.addOpacity(0.7),
+            ),
+          ),
+        ],
+      ],
+    );
+
+    final chip = Container(
+      padding: EdgeInsets.symmetric(
+        horizontal: dense ? 8 : 12,
+        vertical: dense ? 4 : 6,
+      ),
+      decoration: BoxDecoration(
+        color: outlined ? Colors.transparent : bgColor,
+        borderRadius: BorderRadius.circular(dense ? 4 : 6),
+        border: outlined ? Border.all(color: bgColor, width: 1) : null,
+      ),
+      child: content,
+    );
+
+    if (onTap != null) {
+      return InkWell(
+        onTap: onTap,
+        borderRadius: BorderRadius.circular(dense ? 4 : 6),
+        child: chip,
+      );
+    }
+    return chip;
+  }
+}
+
+/// Progress indicator with optional labels
+class DsProgress extends StatelessWidget {
+  const DsProgress({
+    super.key,
+    this.value,
+    this.label,
+    this.sublabel,
+    this.isLinear = true,
+    this.color,
+    this.backgroundColor,
+    this.height,
+    this.showPercentage = false,
+  });
+
+  final double? value;
+  final String? label;
+  final String? sublabel;
+  final bool isLinear;
+  final Color? color;
+  final Color? backgroundColor;
+  final double? height;
+  final bool showPercentage;
+
+  @override
+  Widget build(BuildContext context) {
+    final progressColor = color ?? context.primary;
+    final bgColor = backgroundColor ?? context.surfaceContainerHighest;
+
+    Widget progress;
+    if (isLinear) {
+      progress = ClipRRect(
+        borderRadius: BorderRadius.circular(height != null ? height! / 2 : 2),
+        child: LinearProgressIndicator(
+          value: value,
+          backgroundColor: bgColor,
+          valueColor: AlwaysStoppedAnimation<Color>(progressColor),
+          minHeight: height ?? 4,
+        ),
+      );
+    } else {
+      progress = CircularProgressIndicator(
+        value: value,
+        backgroundColor: bgColor,
+        valueColor: AlwaysStoppedAnimation<Color>(progressColor),
+        strokeWidth: 3,
+      );
+    }
+
+    if (label == null && sublabel == null && !showPercentage) {
+      return progress;
+    }
+
+    return Column(
+      mainAxisSize: MainAxisSize.min,
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: [
+        if (label != null) ...[
+          Row(
+            children: [
+              Expanded(
+                child: Text(label!, style: context.labelMedium),
+              ),
+              if (showPercentage && value != null)
+                Text(
+                  '${(value! * 100).toInt()}%',
+                  style: context.labelSmall?.copyWith(
+                    color: context.onSurfaceVariant,
+                  ),
+                ),
+            ],
+          ),
+          context.ds.spaceHeight(DesignSystem.space8),
+        ],
+        progress,
+        if (sublabel != null) ...[
+          context.ds.spaceHeight(DesignSystem.space4),
+          Text(
+            sublabel!,
+            style: context.labelSmall?.copyWith(
+              color: context.onSurfaceVariant,
+            ),
+          ),
+        ],
+      ],
+    );
+  }
+}
+
+/// Consistent icon container with background
+class DsIconContainer extends StatelessWidget {
+  const DsIconContainer({
+    required this.icon,
+    super.key,
+    this.iconColor,
+    this.backgroundColor,
+    this.size = DesignSystem.iconSizeMedium,
+    this.padding = DesignSystem.space8,
+    this.borderRadius,
+  });
+
+  final IconData icon;
+  final Color? iconColor;
+  final Color? backgroundColor;
+  final double size;
+  final double padding;
+  final BorderRadius? borderRadius;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      padding: EdgeInsets.all(padding),
+      decoration: BoxDecoration(
+        color: backgroundColor ?? context.primaryContainer.addOpacity(0.2),
+        borderRadius: borderRadius ?? BorderRadius.circular(8),
+      ),
+      child: Icon(
+        icon,
+        size: size,
+        color: iconColor ?? context.primary,
+      ),
+    );
+  }
+}
+
+/// Info row for displaying label-value pairs
+class DsInfoRow extends StatelessWidget {
+  const DsInfoRow({
+    required this.label,
+    required this.value,
+    super.key,
+    this.labelStyle,
+    this.valueStyle,
+    this.spacing = DesignSystem.space8,
+  });
+
+  final String label;
+  final String value;
+  final TextStyle? labelStyle;
+  final TextStyle? valueStyle;
+  final double spacing;
+
+  @override
+  Widget build(BuildContext context) {
+    return Row(
+      children: [
+        Text(
+          label,
+          style: labelStyle ?? context.labelBold,
+        ),
+        SizedBox(width: spacing),
+        Expanded(
+          child: Text(
+            value,
+            style: valueStyle ?? context.bodyMuted,
+            overflow: TextOverflow.ellipsis,
+          ),
+        ),
+      ],
+    );
+  }
+}
+
+/// Empty state widget with icon and optional actions
+class DsEmptyState extends StatelessWidget {
+  const DsEmptyState({
+    required this.icon,
+    required this.title,
+    super.key,
+    this.subtitle,
+    this.actions,
+    this.customIcon,
+    this.iconSize = 64,
+    this.iconColor,
+  });
+
+  final IconData icon;
+  final String title;
+  final String? subtitle;
+  final List<Widget>? actions;
+  final Widget? customIcon;
+  final double iconSize;
+  final Color? iconColor;
+
+  @override
+  Widget build(BuildContext context) {
+    return Center(
+      child: Padding(
+        padding: DsDimensions.paddingLarge,
+        child: Column(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            customIcon ??
+                Icon(
+                  icon,
+                  size: iconSize,
+                  color: iconColor ?? context.onSurfaceVariant.addOpacity(0.5),
+                ),
+            context.ds.spaceHeight(DesignSystem.space24),
+            Text(
+              title,
+              style: context.titleMedium,
+              textAlign: TextAlign.center,
+            ),
+            if (subtitle != null) ...[
+              context.ds.spaceHeight(DesignSystem.space8),
+              Text(
+                subtitle!,
+                style: context.bodyMuted,
+                textAlign: TextAlign.center,
+              ),
+            ],
+            if (actions != null && actions!.isNotEmpty) ...[
+              context.ds.spaceHeight(DesignSystem.space24),
+              ...actions!,
+            ],
+          ],
+        ),
+      ),
+    );
+  }
+}
+
+/// Status card for displaying info with optional progress
+class DsStatusCard extends StatelessWidget {
+  const DsStatusCard({
+    required this.title,
+    super.key,
+    this.leading,
+    this.subtitle,
+    this.trailing,
+    this.backgroundColor,
+    this.showProgress = false,
+    this.progress,
+    this.progressLabel,
+  });
+
+  final Widget? leading;
+  final String title;
+  final String? subtitle;
+  final Widget? trailing;
+  final Color? backgroundColor;
+  final bool showProgress;
+  final double? progress;
+  final String? progressLabel;
+
+  @override
+  Widget build(BuildContext context) {
+    return DsCard(
+      decoration: BoxDecoration(
+        color: backgroundColor ?? context.surface,
+        borderRadius: context.ds.radiusMedium,
+        border: Border.all(
+          color: context.outlineVariant.addOpacity(0.5),
+        ),
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Row(
+            children: [
+              if (leading != null) ...[
+                leading!,
+                context.ds.spaceWidth(DesignSystem.space12),
+              ],
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text(title, style: context.titleSmall),
+                    if (subtitle != null) ...[
+                      context.ds.spaceHeight(DesignSystem.space4),
+                      Text(
+                        subtitle!,
+                        style: context.bodyMuted,
+                      ),
+                    ],
+                  ],
+                ),
+              ),
+              if (trailing != null) ...[
+                context.ds.spaceWidth(DesignSystem.space12),
+                trailing!,
+              ],
+            ],
+          ),
+          if (showProgress) ...[
+            context.ds.spaceHeight(DesignSystem.space12),
+            DsProgress(
+              value: progress,
+              label: progressLabel,
+              showPercentage: progress != null,
+            ),
+          ],
+        ],
+      ),
+    );
+  }
+}
diff --git a/lib/src/shared/shared.dart b/lib/src/shared/shared.dart
index 22eebf6..bb6f679 100644
--- a/lib/src/shared/shared.dart
+++ b/lib/src/shared/shared.dart
@@ -1,5 +1,3 @@
+export 'design_system/design_system.dart';
 export 'theme/app_theme.dart';
 export 'theme/extensions.dart';
-export 'utils/extension_catalog.dart';
-export 'utils/language_mapper.dart';
-export 'widgets/resizable_splitter.dart';
diff --git a/lib/src/shared/theme/app_theme.dart b/lib/src/shared/theme/app_theme.dart
index 50dddf4..554cbaf 100644
--- a/lib/src/shared/theme/app_theme.dart
+++ b/lib/src/shared/theme/app_theme.dart
@@ -3,7 +3,9 @@ import 'package:flutter/material.dart';
 
 class AppTheme {
   // Modern color palette inspired by modern design systems
-  static const Color _primaryColor = Color(0xFF97D0E1); // Modern purple
+  static const Color _primaryColor = Color(
+    0xFF5BA3C7,
+  ); // Darker blue for better readability
   static const Color _secondaryColor = Color(0xFF1C9C96);
   static const Color _accentColor = Color(0xFFFF6B6B); // Coral red
   static const Color _surfaceColor = Color(0xFFF7F9FC); // Cool gray
@@ -153,6 +155,7 @@ class AppTheme {
       ),
       iconTheme: const IconThemeData(
         size: 20,
+        color: Color(0xFF1A1C1E), // Dark gray for light theme
       ),
       progressIndicatorTheme: const ProgressIndicatorThemeData(
         color: _primaryColor,
@@ -315,6 +318,7 @@ class AppTheme {
       ),
       iconTheme: const IconThemeData(
         size: 20,
+        color: Color(0xFFE1E3E8), // Light gray for dark theme
       ),
       progressIndicatorTheme: const ProgressIndicatorThemeData(
         color: _primaryColor,
diff --git a/lib/src/shared/theme/extensions.dart b/lib/src/shared/theme/extensions.dart
index 1f5e0f3..1fd81b9 100644
--- a/lib/src/shared/theme/extensions.dart
+++ b/lib/src/shared/theme/extensions.dart
@@ -1,8 +1,6 @@
 import 'package:flutter/material.dart';
 import 'package:flutter_helper_utils/flutter_helper_utils.dart';
 
-export 'package:flutter_helper_utils/flutter_helper_utils.dart';
-
 /// Extension on BuildContext to provide convenient theme color access
 extension ThemeColorsExtension on BuildContext {
   // ColorScheme colors
@@ -113,14 +111,13 @@ extension TextStylesExtension on BuildContext {
     FontWeight? fontWeight,
     double? height,
     double? letterSpacing,
-  }) =>
-      displayLarge?.copyWith(
-        color: color,
-        fontSize: fontSize,
-        fontWeight: fontWeight,
-        height: height,
-        letterSpacing: letterSpacing,
-      );
+  }) => displayLarge?.copyWith(
+    color: color,
+    fontSize: fontSize,
+    fontWeight: fontWeight,
+    height: height,
+    letterSpacing: letterSpacing,
+  );
 
   TextStyle? titleMediumCopy({
     Color? color,
@@ -128,14 +125,13 @@ extension TextStylesExtension on BuildContext {
     FontWeight? fontWeight,
     double? height,
     double? letterSpacing,
-  }) =>
-      titleMedium?.copyWith(
-        color: color,
-        fontSize: fontSize,
-        fontWeight: fontWeight,
-        height: height,
-        letterSpacing: letterSpacing,
-      );
+  }) => titleMedium?.copyWith(
+    color: color,
+    fontSize: fontSize,
+    fontWeight: fontWeight,
+    height: height,
+    letterSpacing: letterSpacing,
+  );
 
   TextStyle? bodyMediumCopy({
     Color? color,
@@ -143,14 +139,13 @@ extension TextStylesExtension on BuildContext {
     FontWeight? fontWeight,
     double? height,
     double? letterSpacing,
-  }) =>
-      bodyMedium?.copyWith(
-        color: color,
-        fontSize: fontSize,
-        fontWeight: fontWeight,
-        height: height,
-        letterSpacing: letterSpacing,
-      );
+  }) => bodyMedium?.copyWith(
+    color: color,
+    fontSize: fontSize,
+    fontWeight: fontWeight,
+    height: height,
+    letterSpacing: letterSpacing,
+  );
 
   TextStyle? labelSmallCopy({
     Color? color,
@@ -158,12 +153,11 @@ extension TextStylesExtension on BuildContext {
     FontWeight? fontWeight,
     double? height,
     double? letterSpacing,
-  }) =>
-      labelSmall?.copyWith(
-        color: color,
-        fontSize: fontSize,
-        fontWeight: fontWeight,
-        height: height,
-        letterSpacing: letterSpacing,
-      );
+  }) => labelSmall?.copyWith(
+    color: color,
+    fontSize: fontSize,
+    fontWeight: fontWeight,
+    height: height,
+    letterSpacing: letterSpacing,
+  );
 }
diff --git a/lib/src/shared/utils/docx_to_markdown.dart b/lib/src/shared/utils/docx_to_markdown.dart
new file mode 100644
index 0000000..90d9946
--- /dev/null
+++ b/lib/src/shared/utils/docx_to_markdown.dart
@@ -0,0 +1,1015 @@
+// lib/docx_to_markdown.dart
+
+import 'dart:convert';
+import 'dart:io';
+
+import 'package:archive/archive.dart';
+import 'package:collection/collection.dart' show IterableExtension;
+import 'package:path/path.dart' as path;
+import 'package:xml/xml.dart';
+
+///  Example usage with configuration
+/// final config = DocxToMarkdownConfig.defaults.copyWith(
+///   extractImages: false,
+///   underlineMode: UnderlineMode.ignore,
+///   useStreaming: true, // For large files
+/// );
+/// final markdown = await 'document.docx'.docxToMarkdown(config: config);
+/// Configuration for DocxToMarkdownConverter
+class DocxToMarkdownConfig {
+  const DocxToMarkdownConfig({
+    this.styleMapping = const {
+      'Heading1': '# ',
+      'Heading2': '## ',
+      'Heading3': '### ',
+      'Heading4': '#### ',
+      'Heading5': '##### ',
+      'Heading6': '###### ',
+      'Title': '# ',
+      'Subtitle': '## ',
+      'Quote': '> ',
+      'IntenseQuote': '> ',
+      'Code': '```',
+    },
+    this.bulletStyles = const ['-', '*', '+'],
+    this.extractImages = true,
+    this.includeComments = false,
+    this.preserveEmptyParagraphs = false,
+    this.maxImageWidth = 0,
+    this.codeBlockStyle = 'Code',
+    this.customStyleHandlers = const {},
+    this.underlineMode = UnderlineMode.html,
+    this.useStreaming = false,
+  });
+  final Map<String, String> styleMapping;
+  final List<String> bulletStyles;
+  final bool extractImages;
+  final bool includeComments;
+  final bool preserveEmptyParagraphs;
+  final int maxImageWidth;
+  final String codeBlockStyle;
+  final Map<String, String> customStyleHandlers;
+  final UnderlineMode underlineMode;
+  final bool useStreaming;
+
+  /// Default configuration with sensible defaults
+  static const defaults = DocxToMarkdownConfig();
+
+  DocxToMarkdownConfig copyWith({
+    Map<String, String>? styleMapping,
+    List<String>? bulletStyles,
+    bool? extractImages,
+    bool? includeComments,
+    bool? preserveEmptyParagraphs,
+    int? maxImageWidth,
+    String? codeBlockStyle,
+    Map<String, String>? customStyleHandlers,
+    UnderlineMode? underlineMode,
+    bool? useStreaming,
+  }) {
+    return DocxToMarkdownConfig(
+      styleMapping: styleMapping ?? this.styleMapping,
+      bulletStyles: bulletStyles ?? this.bulletStyles,
+      extractImages: extractImages ?? this.extractImages,
+      includeComments: includeComments ?? this.includeComments,
+      preserveEmptyParagraphs:
+          preserveEmptyParagraphs ?? this.preserveEmptyParagraphs,
+      maxImageWidth: maxImageWidth ?? this.maxImageWidth,
+      codeBlockStyle: codeBlockStyle ?? this.codeBlockStyle,
+      customStyleHandlers: customStyleHandlers ?? this.customStyleHandlers,
+      underlineMode: underlineMode ?? this.underlineMode,
+      useStreaming: useStreaming ?? this.useStreaming,
+    );
+  }
+}
+
+/// How to handle underline formatting
+enum UnderlineMode {
+  /// Output as HTML <u> tags
+  html,
+
+  /// Output as ++text++ (some markdown flavors)
+  plusPlus,
+
+  /// Ignore underlines
+  ignore,
+}
+
+/// Tracks list state across paragraphs
+class ListState {
+  final Map<String, ListInfo> _activeLists = {};
+  final Map<String, int> _counters = {};
+
+  void updateList(String numId, String ilvl, String? numFmt) {
+    final level = int.tryParse(ilvl) ?? 0;
+    final key = '$numId:$ilvl';
+
+    if (!_counters.containsKey(key) || numFmt == 'bullet') {
+      _counters[key] = 0;
+    }
+
+    if (numFmt != 'bullet') {
+      _counters[key] = (_counters[key] ?? 0) + 1;
+    }
+
+    _activeLists[numId] = ListInfo(
+      level: level,
+      format: numFmt,
+      lastIndex: _counters[key] ?? 1,
+    );
+  }
+
+  void clearList(String numId) {
+    _activeLists.remove(numId);
+  }
+
+  void clearAll() {
+    _activeLists.clear();
+    _counters.clear();
+  }
+
+  ListInfo? getList(String numId) => _activeLists[numId];
+}
+
+class ListInfo {
+  ListInfo({
+    required this.level,
+    this.format,
+    required this.lastIndex,
+  });
+  final int level;
+  final String? format;
+  final int lastIndex;
+}
+
+/// Main class for converting DOCX files to Markdown
+class DocxToMarkdownConverter {
+  /// Creates a new converter instance
+  DocxToMarkdownConverter({
+    this.outputMediaPath,
+    DocxToMarkdownConfig? config,
+  }) : config = config ?? DocxToMarkdownConfig.defaults;
+  final Map<String, String> _mediaFiles = {};
+  final Map<String, Relationship> _relationships = {};
+  final Map<String, String> _numbering = {};
+  final Map<String, String> _numToAbstract = {};
+  final Map<String, CommentInfo> _comments = {};
+  final List<String> _activeComments = [];
+  final List<FootnoteInfo> _footnotes = [];
+  final List<VerticalMergeCell> _verticalMerges = [];
+  final StringBuffer _output = StringBuffer();
+  final String? outputMediaPath;
+  final DocxToMarkdownConfig config;
+  final ListState _listState = ListState();
+
+  /// Converts a DOCX file to Markdown format
+  /// Throws [DocxException] for any conversion errors
+  ///
+  /// For very large DOCX files, consider setting [config.useStreaming] to true
+  /// to reduce memory usage.
+  Future<String> convertFile(String filePath) async {
+    final file = File(filePath);
+
+    if (!file.existsSync()) {
+      throw FileSystemException('File not found', filePath);
+    }
+
+    // Check file extension
+    final ext = path.extension(filePath).toLowerCase();
+    if (ext == '.doc') {
+      throw UnsupportedFormatException(
+        'Old .doc format is not supported. Please convert to .docx first.',
+      );
+    }
+    if (ext != '.docx') {
+      throw UnsupportedFormatException(
+        'Unsupported file format: $ext. Only .docx files are supported.',
+      );
+    }
+
+    if (config.useStreaming) {
+      return _processDocxStreaming(filePath);
+    } else {
+      return _processDocx(file);
+    }
+  }
+
+  Future<String> _processDocx(File docxFile) async {
+    _resetState();
+
+    final bytes = await docxFile.readAsBytes();
+    final archive = ZipDecoder().decodeBytes(bytes);
+
+    await _processArchive(archive);
+
+    return _output.toString().trim();
+  }
+
+  Future<String> _processDocxStreaming(String filePath) async {
+    _resetState();
+
+    final inputStream = InputFileStream(filePath);
+    final archive = ZipDecoder().decodeStream(inputStream);
+
+    await _processArchive(archive);
+    await inputStream.close();
+
+    return _output.toString().trim();
+  }
+
+  void _resetState() {
+    _output.clear();
+    _mediaFiles.clear();
+    _relationships.clear();
+    _numbering.clear();
+    _numToAbstract.clear();
+    _comments.clear();
+    _activeComments.clear();
+    _footnotes.clear();
+    _verticalMerges.clear();
+    _listState.clearAll();
+  }
+
+  Future<void> _processArchive(Archive archive) async {
+    // Extract relationships
+    await _parseRelationships(archive);
+
+    // Extract numbering definitions
+    await _parseNumbering(archive);
+
+    // Extract comments if enabled
+    if (config.includeComments) {
+      await _parseComments(archive);
+    }
+
+    // Extract footnotes
+    await _parseFootnotes(archive);
+
+    // Extract media files
+    if (config.extractImages && outputMediaPath != null) {
+      await _extractMediaFiles(archive);
+    }
+
+    // Extract and parse main document
+    final docFile = archive.files.firstWhere(
+      (f) => f.name == 'word/document.xml',
+      orElse: () => throw DocxParsingException('Missing word/document.xml'),
+    );
+
+    // FIX: The argument type 'Uint8List?' can't be assigned to the parameter type 'List<int>'. (Documentation)
+    final xmlDoc = XmlDocument.parse(
+      const Utf8Decoder().convert(docFile.readBytes() ?? []),
+    );
+
+    // Process document body
+    final body = xmlDoc.findAllElements('w:body').firstOrNull;
+    if (body == null) {
+      throw DocxParsingException('Document body not found');
+    }
+
+    // Track code block state
+    bool inCodeBlock = false;
+
+    for (final element in body.children) {
+      if (element is XmlElement) {
+        inCodeBlock = await _processElement(element, inCodeBlock);
+      }
+    }
+
+    // Close any open code block
+    if (inCodeBlock) {
+      _output
+        ..writeln('```')
+        ..writeln();
+    }
+
+    // Append footnotes if any
+    if (_footnotes.isNotEmpty) {
+      _output.writeln('\n---\n');
+      for (final footnote in _footnotes) {
+        _output.writeln('[^${footnote.id}]: ${footnote.text}');
+      }
+    }
+  }
+
+  Future<void> _parseRelationships(Archive archive) async {
+    final relsFile = archive.files.firstWhereOrNull(
+      (f) => f.name == 'word/_rels/document.xml.rels',
+    );
+
+    if (relsFile == null) return;
+
+    // FIX: The argument type 'Uint8List?' can't be assigned to the parameter type 'List<int>'. (Documentation)
+    final relsDoc = XmlDocument.parse(
+      const Utf8Decoder().convert(relsFile.readBytes() ?? []),
+    );
+
+    for (final rel in relsDoc.findAllElements('Relationship')) {
+      final id = rel.getAttribute('Id');
+      final type = rel.getAttribute('Type');
+      final target = rel.getAttribute('Target');
+
+      if (id != null && target != null) {
+        _relationships[id] = Relationship(
+          id: id,
+          type: type ?? '',
+          target: target,
+        );
+      }
+    }
+  }
+
+  Future<void> _parseNumbering(Archive archive) async {
+    final numFile = archive.files.firstWhereOrNull(
+      (f) => f.name == 'word/numbering.xml',
+    );
+
+    if (numFile == null) return;
+
+    final numDoc = XmlDocument.parse(
+      const Utf8Decoder().convert(numFile.readBytes() ?? []),
+    );
+
+    // Parse abstract numbering definitions
+    for (final abstractNum in numDoc.findAllElements('w:abstractNum')) {
+      final abstractNumId = abstractNum.getAttribute('w:abstractNumId');
+      if (abstractNumId != null) {
+        for (final lvl in abstractNum.findAllElements('w:lvl')) {
+          final ilvl = lvl.getAttribute('w:ilvl');
+          final numFmt = lvl
+              .findElements('w:numFmt')
+              .firstOrNull
+              ?.getAttribute('w:val');
+          if (ilvl != null) {
+            _numbering['$abstractNumId:$ilvl'] = numFmt ?? 'bullet';
+          }
+        }
+      }
+    }
+
+    // Parse num to abstractNum mapping
+    for (final num in numDoc.findAllElements('w:num')) {
+      final numId = num.getAttribute('w:numId');
+      final abstractNumId = num.findElements(
+        'w:abstractNumId',
+      ).firstOrNull?.getAttribute('w:val');
+      if (numId != null && abstractNumId != null) {
+        _numToAbstract[numId] = abstractNumId;
+      }
+    }
+  }
+
+  Future<void> _parseComments(Archive archive) async {
+    final commentsFile = archive.files.firstWhereOrNull(
+      (f) => f.name == 'word/comments.xml',
+    );
+
+    if (commentsFile == null) return;
+
+    final commentsDoc = XmlDocument.parse(
+      const Utf8Decoder().convert(commentsFile.readBytes() ?? []),
+    );
+
+    for (final comment in commentsDoc.findAllElements('w:comment')) {
+      final id = comment.getAttribute('w:id');
+      final author = comment.getAttribute('w:author');
+
+      // Extract comment text properly with paragraph boundaries
+      final paragraphs = comment.findAllElements('w:p');
+      final textParts = <String>[];
+
+      for (final p in paragraphs) {
+        final text = p.findAllElements('w:t').map((e) => e.innerText).join();
+        if (text.isNotEmpty) {
+          textParts.add(text);
+        }
+      }
+
+      if (id != null) {
+        _comments[id] = CommentInfo(
+          id: id,
+          author: author ?? 'Unknown',
+          text: textParts.join(' '),
+        );
+      }
+    }
+  }
+
+  Future<void> _parseFootnotes(Archive archive) async {
+    final footnotesFile = archive.files.firstWhereOrNull(
+      (f) => f.name == 'word/footnotes.xml',
+    );
+
+    if (footnotesFile == null) return;
+
+    final footnotesDoc = XmlDocument.parse(
+      const Utf8Decoder().convert(footnotesFile.readBytes() ?? []),
+    );
+
+    for (final footnote in footnotesDoc.findAllElements('w:footnote')) {
+      final id = footnote.getAttribute('w:id');
+      if (id != null && id != '0' && id != '-1') {
+        // Skip separator and continuation
+        // Extract footnote text properly
+        final paragraphs = footnote.findAllElements('w:p');
+        final textParts = <String>[];
+
+        for (final p in paragraphs) {
+          final text = _extractParagraphContent(p);
+          if (text.isNotEmpty) {
+            textParts.add(text);
+          }
+        }
+
+        _footnotes.add(FootnoteInfo(id: id, text: textParts.join(' ')));
+      }
+    }
+  }
+
+  Future<void> _extractMediaFiles(Archive archive) async {
+    if (outputMediaPath == null) return;
+
+    final mediaDir = Directory(outputMediaPath!);
+    if (!mediaDir.existsSync()) {
+      await mediaDir.create(recursive: true);
+    }
+
+    for (final file in archive.files) {
+      if (file.name.startsWith('word/media/')) {
+        final fileName = path.basename(file.name);
+        final outputFile = File(path.join(outputMediaPath!, fileName));
+
+        // Use streaming write for large images
+        final outputStream = OutputFileStream(outputFile.path);
+        file.writeContent(outputStream);
+        await outputStream.close();
+
+        // Map both the full path and just the filename
+        _mediaFiles[file.name] = fileName;
+        _mediaFiles[fileName] = fileName;
+      }
+    }
+  }
+
+  Future<bool> _processElement(XmlElement element, bool inCodeBlock) async {
+    switch (element.name.local) {
+      case 'p':
+        return _processParagraph(element, inCodeBlock);
+      case 'tbl':
+        _processTable(element);
+        return false;
+      default:
+        return inCodeBlock;
+    }
+  }
+
+  bool _processParagraph(XmlElement p, bool inCodeBlock) {
+    var isInCodeBlock = inCodeBlock;
+    final pPr = p.getElement('w:pPr');
+    final styleEl = pPr?.getElement('w:pStyle')?.getAttribute('w:val');
+    final numPr = pPr?.getElement('w:numPr');
+
+    // Check if this is a code block style
+    final bool isCodeBlockStyle = styleEl == config.codeBlockStyle;
+
+    // Handle code blocks
+    if (isCodeBlockStyle) {
+      final content = _extractParagraphContent(p);
+
+      if (!isInCodeBlock) {
+        // Start new code block
+        _output
+          ..writeln('```')
+          ..writeln(content);
+        return true;
+      } else {
+        // Continue code block
+        _output.writeln(content);
+        return true;
+      }
+    } else if (isInCodeBlock) {
+      // End code block
+      _output
+        ..writeln('```')
+        ..writeln();
+      isInCodeBlock = false;
+    }
+
+    // Determine paragraph prefix
+    String prefix = '';
+    if (styleEl != null && config.styleMapping.containsKey(styleEl)) {
+      prefix = config.styleMapping[styleEl]!;
+    } else if (styleEl != null &&
+        config.customStyleHandlers.containsKey(styleEl)) {
+      prefix = config.customStyleHandlers[styleEl]!;
+    } else if (numPr != null) {
+      prefix = _getListPrefix(numPr);
+    }
+
+    // Process content
+    final content = _extractParagraphContent(p);
+
+    // Handle horizontal rules
+    if (content == '---' || content == '***' || content == '___') {
+      _output
+        ..writeln(content)
+        ..writeln();
+      return false;
+    }
+
+    if (content.isNotEmpty ||
+        (config.preserveEmptyParagraphs && prefix.isEmpty)) {
+      _output.writeln('$prefix$content');
+
+      // Add spacing
+      if (prefix.startsWith('#')) {
+        _output.writeln();
+      } else if (!_isListItem(prefix) && prefix != '> ') {
+        _output.writeln();
+      }
+    }
+
+    return false;
+  }
+
+  String _getListPrefix(XmlElement numPr) {
+    final ilvl = numPr.getElement('w:ilvl')?.getAttribute('w:val') ?? '0';
+    final numId = numPr.getElement('w:numId')?.getAttribute('w:val');
+
+    if (numId == null) return '';
+
+    final level = int.tryParse(ilvl) ?? 0;
+    final indent = ' ' * (level * 2);
+
+    // Look up numbering format through the num -> abstract mapping
+    final abstractId = _numToAbstract[numId];
+    String? numFmt;
+    if (abstractId != null) {
+      numFmt = _numbering['$abstractId:$ilvl'];
+    }
+
+    // Update list state
+    _listState.updateList(numId, ilvl, numFmt);
+    final listInfo = _listState.getList(numId);
+
+    if (numFmt == 'decimal') {
+      return '$indent${listInfo?.lastIndex ?? 1}. ';
+    } else if (numFmt == 'lowerLetter') {
+      final letter = String.fromCharCode(96 + (listInfo?.lastIndex ?? 1));
+      return '$indent$letter. ';
+    } else if (numFmt == 'upperLetter') {
+      final letter = String.fromCharCode(64 + (listInfo?.lastIndex ?? 1));
+      return '$indent$letter. ';
+    } else {
+      // Bulleted list
+      final bullet = config.bulletStyles[level % config.bulletStyles.length];
+      return '$indent$bullet ';
+    }
+  }
+
+  bool _isListItem(String prefix) {
+    return prefix.trimLeft().startsWith('-') ||
+        prefix.trimLeft().startsWith('*') ||
+        prefix.trimLeft().startsWith('+') ||
+        RegExp(r'^\s*(\d+|[a-zA-Z])\.\s').hasMatch(prefix);
+  }
+
+  String _extractParagraphContent(XmlElement p) {
+    final parts = <String>[];
+
+    for (final child in p.children) {
+      if (child is XmlElement) {
+        switch (child.name.local) {
+          case 'r':
+            parts.add(_processRun(child));
+          case 'hyperlink':
+            parts.add(_processHyperlink(child));
+          case 'commentRangeStart':
+            if (config.includeComments) {
+              final id = child.getAttribute('w:id');
+              if (id != null) {
+                _activeComments.add(id);
+              }
+            }
+          case 'commentRangeEnd':
+            if (config.includeComments) {
+              final id = child.getAttribute('w:id');
+              if (id != null && _activeComments.contains(id)) {
+                _activeComments.remove(id);
+                if (_comments.containsKey(id)) {
+                  final comment = _comments[id]!;
+                  parts.add('^[${comment.author}: ${comment.text}]');
+                }
+              }
+            }
+        }
+      }
+    }
+
+    return parts.join();
+  }
+
+  String _processRun(XmlElement r) {
+    final textBuffer = StringBuffer();
+
+    // Check for footnote reference
+    final footnoteRef = r.getElement('w:footnoteReference');
+    if (footnoteRef != null) {
+      final id = footnoteRef.getAttribute('w:id');
+      if (id != null) {
+        return '[^$id]';
+      }
+    }
+
+    // Extract text
+    for (final t in r.findAllElements('w:t')) {
+      textBuffer.write(t.innerText);
+    }
+
+    // Handle breaks
+    if (r.findElements('w:br').isNotEmpty) {
+      textBuffer.write('  \n'); // Markdown line break
+    }
+
+    // Handle tabs
+    if (r.findElements('w:tab').isNotEmpty) {
+      textBuffer.write('\t');
+    }
+
+    // Handle images
+    final drawing = r.getElement('w:drawing');
+    if (drawing != null) {
+      final image = _extractImage(drawing);
+      if (image != null) {
+        return image;
+      }
+    }
+
+    // Handle embedded objects
+    final object = r.getElement('w:object');
+    if (object != null) {
+      return '[Embedded Object]';
+    }
+
+    // Apply formatting
+    final rPr = r.getElement('w:rPr');
+    final text = textBuffer.toString();
+    if (rPr != null && text.isNotEmpty) {
+      return _applyFormatting(text, rPr);
+    }
+
+    return text;
+  }
+
+  String _applyFormatting(String text, XmlElement rPr) {
+    var txt = text;
+
+    final isBold =
+        rPr.findElements('w:b').isNotEmpty &&
+        rPr.findElements('w:b').first.getAttribute('w:val') != 'false';
+    final isItalic =
+        rPr.findElements('w:i').isNotEmpty &&
+        rPr.findElements('w:i').first.getAttribute('w:val') != 'false';
+    final isStrike = rPr.findElements('w:strike').isNotEmpty;
+    final isUnderline = rPr.findElements('w:u').isNotEmpty;
+    final isSubscript = rPr
+        .findElements('w:vertAlign')
+        .any((e) => e.getAttribute('w:val') == 'subscript');
+    final isSuperscript = rPr
+        .findElements('w:vertAlign')
+        .any((e) => e.getAttribute('w:val') == 'superscript');
+    final isCode = _isCodeFormatting(rPr);
+
+    // Apply code formatting first
+    if (isCode) {
+      return '`$txt`';
+    }
+
+    // Apply other formatting
+    if (isSubscript) {
+      txt = '<sub>$txt</sub>';
+    } else if (isSuperscript) {
+      txt = '<sup>$txt</sup>';
+    }
+
+    if (isBold && isItalic) {
+      txt = '***$txt***';
+    } else if (isBold) {
+      txt = '**$txt**';
+    } else if (isItalic) {
+      txt = '*$txt*';
+    }
+
+    if (isStrike) {
+      txt = '~~$txt~~';
+    }
+
+    if (isUnderline) {
+      switch (config.underlineMode) {
+        case UnderlineMode.html:
+          txt = '<u>$txt</u>';
+        case UnderlineMode.plusPlus:
+          txt = '++$txt++';
+        case UnderlineMode.ignore:
+          // Do nothing
+          break;
+      }
+    }
+
+    return txt;
+  }
+
+  bool _isCodeFormatting(XmlElement rPr) {
+    // Check for courier fonts
+    final font = rPr
+        .getElement('w:rFonts')
+        ?.getAttribute('w:ascii')
+        ?.toLowerCase();
+    if (font != null &&
+        (font.contains('courier') ||
+            font.contains('consolas') ||
+            font.contains('monaco'))) {
+      return true;
+    }
+
+    // Check for shading (often used for inline code)
+    if (rPr.findElements('w:shd').isNotEmpty) {
+      return true;
+    }
+
+    return false;
+  }
+
+  String? _extractImage(XmlElement drawing) {
+    try {
+      // Skip shapes and diagrams
+      if (_isShape(drawing)) {
+        return null;
+      }
+
+      // Extract image data
+      final picProps = drawing.findAllElements('pic:cNvPr').firstOrNull;
+      final altText =
+          picProps?.getAttribute('descr') ??
+          picProps?.getAttribute('name') ??
+          'Image';
+
+      final blip = drawing.findAllElements('a:blip').firstOrNull;
+      final embed = blip?.getAttribute('r:embed');
+
+      if (embed != null) {
+        // Look up in relationships
+        final rel = _relationships[embed];
+        if (rel != null) {
+          final imagePath = _resolveImagePath(rel.target);
+
+          // Add width constraint if configured
+          if (config.maxImageWidth > 0) {
+            return '![$altText]($imagePath =${config.maxImageWidth}x)';
+          }
+          return '![$altText]($imagePath)';
+        }
+      }
+
+      return '![$altText](embedded-image)';
+    } catch (e) {
+      return null;
+    }
+  }
+
+  bool _isShape(XmlElement drawing) {
+    return drawing.findAllElements('wps:wsp').isNotEmpty ||
+        drawing.findAllElements('v:shape').isNotEmpty ||
+        drawing.findAllElements('mc:AlternateContent').isNotEmpty;
+  }
+
+  String _resolveImagePath(String target) {
+    if (_mediaFiles.isNotEmpty) {
+      // Check if we have this media file
+      final mediaKey = 'word/$target';
+      if (_mediaFiles.containsKey(mediaKey)) {
+        return _mediaFiles[mediaKey]!;
+      }
+
+      // Try just the filename
+      final filename = path.basename(target);
+      if (_mediaFiles.containsKey(filename)) {
+        return _mediaFiles[filename]!;
+      }
+    }
+
+    return target;
+  }
+
+  String _processHyperlink(XmlElement hyperlink) {
+    final rid = hyperlink.getAttribute('r:id');
+    final anchor = hyperlink.getAttribute('w:anchor');
+
+    final linkTextBuffer = StringBuffer();
+    for (final r in hyperlink.findAllElements('w:r')) {
+      linkTextBuffer.write(_processRun(r));
+    }
+    final linkText = linkTextBuffer.toString();
+
+    if (anchor != null) {
+      return '[$linkText](#$anchor)';
+    } else if (rid != null) {
+      final rel = _relationships[rid];
+      if (rel != null) {
+        return '[$linkText](${rel.target})';
+      }
+    }
+
+    return linkText;
+  }
+
+  void _processTable(XmlElement table) {
+    final rows = table.findAllElements('w:tr').toList();
+    if (rows.isEmpty) return;
+
+    // Reset vertical merge tracking
+    _verticalMerges.clear();
+
+    // Analyze table for column alignment
+    final columnAlignments = _analyzeTableAlignment(table);
+
+    // Process all rows
+    for (var i = 0; i < rows.length; i++) {
+      final row = rows[i];
+      final cells = row.findAllElements('w:tc').toList();
+      final cellTexts = <String>[];
+      var colIndex = 0;
+
+      for (final cell in cells) {
+        // Check for vertical merge
+        final vMerge = cell.getElement('w:tcPr')?.getElement('w:vMerge');
+
+        if (vMerge != null && vMerge.getAttribute('w:val') != 'restart') {
+          // This is a continuation of a vertical merge
+          cellTexts.add(' ');
+        } else {
+          // Normal cell or start of vertical merge
+          final cellText = StringBuffer();
+          final paragraphs = cell.findAllElements('w:p').toList();
+
+          for (var j = 0; j < paragraphs.length; j++) {
+            final p = paragraphs[j];
+            final paragraphText = _extractParagraphContent(p);
+            if (paragraphText.isNotEmpty) {
+              if (cellText.isNotEmpty) cellText.write('<br>');
+              cellText.write(paragraphText);
+            }
+          }
+
+          final content = cellText.toString().trim();
+          cellTexts.add(content.isEmpty ? ' ' : content.replaceAll('|', r'\|'));
+
+          // Track vertical merge start
+          if (vMerge != null && vMerge.getAttribute('w:val') == 'restart') {
+            _verticalMerges.add(VerticalMergeCell(row: i, col: colIndex));
+          }
+        }
+
+        // Handle column spans
+        final gridSpan = cell
+            .getElement('w:tcPr')
+            ?.getElement('w:gridSpan')
+            ?.getAttribute('w:val');
+        final spanCount = int.tryParse(gridSpan ?? '1') ?? 1;
+
+        // Add empty cells for column spans
+        for (var k = 1; k < spanCount; k++) {
+          cellTexts.add(' ');
+          colIndex++;
+        }
+
+        colIndex++;
+      }
+
+      _output.writeln('| ${cellTexts.join(' | ')} |');
+
+      // Add separator after first row
+      if (i == 0) {
+        final separators = <String>[];
+        for (var j = 0; j < cellTexts.length; j++) {
+          final alignment = j < columnAlignments.length
+              ? columnAlignments[j]
+              : 'left';
+          switch (alignment) {
+            case 'center':
+              separators.add(':---:');
+            case 'right':
+              separators.add('---:');
+            default:
+              separators.add('---');
+          }
+        }
+        _output.writeln('|${separators.join('|')}|');
+      }
+    }
+
+    _output.writeln();
+  }
+
+  List<String> _analyzeTableAlignment(XmlElement table) {
+    final alignments = <String>[];
+
+    // Get first row to analyze columns
+    final firstRow = table.findAllElements('w:tr').firstOrNull;
+    if (firstRow != null) {
+      for (final cell in firstRow.findAllElements('w:tc')) {
+        final jc = cell
+            .getElement('w:tcPr')
+            ?.getElement('w:jc')
+            ?.getAttribute('w:val');
+        alignments.add(jc ?? 'left');
+      }
+    }
+
+    return alignments;
+  }
+}
+
+// Helper classes
+class Relationship {
+  Relationship({
+    required this.id,
+    required this.type,
+    required this.target,
+  });
+  final String id;
+  final String type;
+  final String target;
+}
+
+class CommentInfo {
+  CommentInfo({
+    required this.id,
+    required this.author,
+    required this.text,
+  });
+  final String id;
+  final String author;
+  final String text;
+}
+
+class FootnoteInfo {
+  FootnoteInfo({
+    required this.id,
+    required this.text,
+  });
+  final String id;
+  final String text;
+}
+
+class VerticalMergeCell {
+  VerticalMergeCell({
+    required this.row,
+    required this.col,
+  });
+  final int row;
+  final int col;
+}
+
+/// Base exception for all DOCX conversion errors
+abstract class DocxException implements Exception {
+  String get message;
+
+  @override
+  String toString() => message;
+}
+
+/// Exception thrown when file format is not supported
+class UnsupportedFormatException extends DocxException {
+  UnsupportedFormatException(this.message);
+  @override
+  final String message;
+
+  @override
+  String toString() => 'UnsupportedFormatException: $message';
+}
+
+/// Exception thrown when DOCX parsing fails
+class DocxParsingException extends DocxException {
+  DocxParsingException(this.message);
+  @override
+  final String message;
+
+  @override
+  String toString() => 'DocxParsingException: $message';
+}
+
+// Extension method for convenience
+extension DocxToMarkdown on String {
+  /// Converts this file path (must be .docx) to markdown
+  Future<String> docxToMarkdown({
+    String? outputMediaPath,
+    DocxToMarkdownConfig? config,
+  }) async {
+    final converter = DocxToMarkdownConverter(
+      outputMediaPath: outputMediaPath,
+      config: config,
+    );
+    return converter.convertFile(this);
+  }
+}
diff --git a/lib/src/shared/utils/drop_file_resolver.dart b/lib/src/shared/utils/drop_file_resolver.dart
deleted file mode 100644
index 3dc6913..0000000
--- a/lib/src/shared/utils/drop_file_resolver.dart
+++ /dev/null
@@ -1,252 +0,0 @@
-import 'dart:io';
-
-import 'package:path/path.dart' as path;
-
-/// Utility class to handle desktop_drop temporary files
-///
-/// When files are dragged from certain applications (like VSCode),
-/// desktop_drop creates temporary files in the app's sandboxed container
-/// that may lose their original extensions.
-class DropFileResolver {
-  /// Check if a file path is a desktop_drop temporary file
-  static bool isTemporaryDropFile(String filePath) {
-    return filePath.contains('/tmp/Drops/') ||
-        filePath.contains(r'\tmp\Drops\') ||
-        filePath.contains(
-            '/Containers/com.omarhanafy.context.collector/Data/tmp/Drops/');
-  }
-
-  /// Try to resolve the original file information from a temporary drop file
-  /// Returns a map with 'extension' and 'originalName' if inference is successful
-  static Map<String, String?> resolveFileInfo(String filePath) {
-    final fileName = path.basename(filePath);
-    final result = <String, String?>{
-      'extension': null,
-      'originalName': null,
-    };
-
-    // If the file already has an extension, use it
-    final currentExtension = path.extension(filePath);
-    if (currentExtension.isNotEmpty) {
-      result['extension'] = currentExtension;
-      return result;
-    }
-
-    // Common patterns for temporary files from VSCode drops
-    // e.g., "lib-1" might be "lib.dart", "index-2" might be "index.js"
-    final patterns = [
-      // Pattern: name-number (e.g., lib-1, index-2)
-      RegExp(r'^(.+)-(\d+)$'),
-    ];
-
-    for (final pattern in patterns) {
-      final match = pattern.firstMatch(fileName);
-      if (match != null) {
-        final baseName = match.group(1);
-        if (baseName != null) {
-          // Try to infer extension based on common file names
-          final extension = _inferExtensionFromName(baseName);
-          if (extension != null) {
-            result['extension'] = extension;
-            result['originalName'] = '$baseName$extension';
-            return result;
-          }
-        }
-      }
-    }
-
-    // Try to infer from file content if name-based inference fails
-    final contentExtension = _inferExtensionFromContent(filePath);
-    if (contentExtension != null) {
-      result['extension'] = contentExtension;
-    }
-
-    return result;
-  }
-
-  /// Infer file extension based on common file names
-  static String? _inferExtensionFromName(String baseName) {
-    final commonExtensions = {
-      // Common config files
-      'package': '.json',
-      'tsconfig': '.json',
-      'eslintrc': '.json',
-      'prettierrc': '.json',
-      'babel.config': '.js',
-      'webpack.config': '.js',
-      'vite.config': '.js',
-      'jest.config': '.js',
-      'rollup.config': '.js',
-
-      // Common source files
-      'index': '.js', // Could also be .ts, .tsx, .jsx, .html
-      'main': '.dart', // In Flutter context
-      'app': '.dart',
-      'test': '.dart',
-      'spec': '.js',
-
-      // Build files
-      'makefile': '',
-      'dockerfile': '',
-      'readme': '.md',
-      'changelog': '.md',
-      'license': '',
-
-      // Shell scripts
-      'build': '.sh',
-      'deploy': '.sh',
-      'setup': '.sh',
-      'install': '.sh',
-    };
-
-    final lowerName = baseName.toLowerCase();
-    return commonExtensions[lowerName];
-  }
-
-  /// Try to infer file extension from content
-  static String? _inferExtensionFromContent(String filePath) {
-    try {
-      final file = File(filePath);
-      if (!file.existsSync()) return null;
-
-      // Read first few lines to detect file type
-      final lines = file.readAsLinesSync().take(10).toList();
-      if (lines.isEmpty) return null;
-
-      final firstLine = lines.first.trim();
-      final content = lines.join('\n');
-
-      // Shebang detection
-      if (firstLine.startsWith('#!')) {
-        if (firstLine.contains('python')) return '.py';
-        if (firstLine.contains('node')) return '.js';
-        if (firstLine.contains('bash') || firstLine.contains('sh')) {
-          return '.sh';
-        }
-        if (firstLine.contains('ruby')) return '.rb';
-        if (firstLine.contains('perl')) return '.pl';
-        if (firstLine.contains('php')) return '.php';
-      }
-
-      // Language-specific patterns
-      if (_isDartCode(content)) return '.dart';
-      if (_isJavaScriptCode(content)) return '.js';
-      if (_isPythonCode(content)) return '.py';
-      if (_isJavaCode(content)) return '.java';
-      if (_isCppCode(content)) return '.cpp';
-      if (_isHtmlCode(content)) return '.html';
-      if (_isCssCode(content)) return '.css';
-      if (_isJsonCode(content)) return '.json';
-      if (_isXmlCode(content)) return '.xml';
-      if (_isMarkdownCode(content)) return '.md';
-      if (_isYamlCode(content)) return '.yaml';
-      if (_isShellScript(content)) return '.sh';
-
-      // Default to .txt if it's readable text
-      return '.txt';
-    } catch (e) {
-      // If we can't read the file as text, it might be binary
-      return null;
-    }
-  }
-
-  static bool _isDartCode(String content) {
-    return content.contains("import 'dart:") ||
-        content.contains("import 'package:") ||
-        content.contains('class ') && content.contains(' extends ') ||
-        content.contains('void main()') ||
-        content.contains('Widget build(');
-  }
-
-  static bool _isJavaScriptCode(String content) {
-    return content.contains('function ') ||
-        content.contains('const ') ||
-        content.contains('let ') ||
-        content.contains('var ') ||
-        content.contains('=>') ||
-        content.contains('require(') ||
-        content.contains('import ') && content.contains(' from ');
-  }
-
-  static bool _isPythonCode(String content) {
-    return content.contains('def ') ||
-        content.contains('class ') && content.contains(':') ||
-        content.contains('import ') ||
-        content.contains('from ') && content.contains(' import ') ||
-        content.contains('if __name__');
-  }
-
-  static bool _isJavaCode(String content) {
-    return content.contains('public class ') ||
-        content.contains('private ') ||
-        content.contains('protected ') ||
-        content.contains('package ') ||
-        content.contains('import java.');
-  }
-
-  static bool _isCppCode(String content) {
-    return content.contains('#include ') ||
-        content.contains('using namespace ') ||
-        content.contains('int main(') ||
-        content.contains('std::');
-  }
-
-  static bool _isHtmlCode(String content) {
-    return content.contains('<!DOCTYPE') ||
-        content.contains('<html') ||
-        content.contains('<head>') ||
-        content.contains('<body>') ||
-        (content.contains('<div') && content.contains('</div>'));
-  }
-
-  static bool _isCssCode(String content) {
-    return (content.contains('{') &&
-            content.contains('}') &&
-            content.contains(':') &&
-            content.contains(';')) &&
-        (content.contains('color:') ||
-            content.contains('background:') ||
-            content.contains('margin:') ||
-            content.contains('padding:') ||
-            content.contains('font-'));
-  }
-
-  static bool _isJsonCode(String content) {
-    final trimmed = content.trim();
-    return (trimmed.startsWith('{') && trimmed.contains('}')) ||
-        (trimmed.startsWith('[') && trimmed.contains(']'));
-  }
-
-  static bool _isXmlCode(String content) {
-    return content.contains('<?xml') ||
-        (content.contains('<') &&
-            content.contains('>') &&
-            content.contains('</'));
-  }
-
-  static bool _isMarkdownCode(String content) {
-    return content.contains('# ') ||
-        content.contains('## ') ||
-        content.contains('```') ||
-        content.contains('- ') ||
-        content.contains('* ') ||
-        content.contains('[') && content.contains('](');
-  }
-
-  static bool _isYamlCode(String content) {
-    return content.contains(':') &&
-        (content.contains('  ') || content.contains('\t')) &&
-        !content.contains('{') &&
-        !content.contains('}');
-  }
-
-  static bool _isShellScript(String content) {
-    return content.contains('#!/bin/') ||
-        content.contains('echo ') ||
-        content.contains('export ') ||
-        content.contains('if [') ||
-        content.contains('then') ||
-        content.contains('fi') ||
-        content.contains('for ') && content.contains('do');
-  }
-}
diff --git a/lib/src/shared/utils/extension_catalog.dart b/lib/src/shared/utils/extension_catalog.dart
deleted file mode 100644
index 060c9ec..0000000
--- a/lib/src/shared/utils/extension_catalog.dart
+++ /dev/null
@@ -1,482 +0,0 @@
-import 'package:flutter/material.dart';
-
-/// Catalog of supported file extensions and their categories
-class ExtensionCatalog {
-  static const Map<String, FileCategory> _extensionCategories = {
-    // Programming Languages
-    '.dart': FileCategory.programming,
-    '.py': FileCategory.programming,
-    '.js': FileCategory.programming,
-    '.ts': FileCategory.programming,
-    '.jsx': FileCategory.programming,
-    '.tsx': FileCategory.programming,
-    '.java': FileCategory.programming,
-    '.kt': FileCategory.programming,
-    '.swift': FileCategory.programming,
-    '.cpp': FileCategory.programming,
-    '.c': FileCategory.programming,
-    '.h': FileCategory.programming,
-    '.hpp': FileCategory.programming,
-    '.cs': FileCategory.programming,
-    '.php': FileCategory.programming,
-    '.rb': FileCategory.programming,
-    '.go': FileCategory.programming,
-    '.rs': FileCategory.programming,
-    '.scala': FileCategory.programming,
-    '.r': FileCategory.programming,
-    '.m': FileCategory.programming,
-    '.mm': FileCategory.programming,
-    '.lua': FileCategory.programming,
-    '.pl': FileCategory.programming,
-    '.ex': FileCategory.programming,
-    '.exs': FileCategory.programming,
-    '.elm': FileCategory.programming,
-    '.clj': FileCategory.programming,
-    '.coffee': FileCategory.programming,
-    '.vb': FileCategory.programming,
-    '.fs': FileCategory.programming,
-    '.hs': FileCategory.programming,
-    '.nim': FileCategory.programming,
-    '.cr': FileCategory.programming,
-    '.jl': FileCategory.programming,
-    '.pas': FileCategory.programming,
-    '.d': FileCategory.programming,
-    '.zig': FileCategory.programming,
-    '.v': FileCategory.programming,
-    '.sol': FileCategory.programming,
-    '.f90': FileCategory.programming,
-    '.f95': FileCategory.programming,
-    '.f03': FileCategory.programming,
-    '.f08': FileCategory.programming,
-    '.for': FileCategory.programming,
-    '.ml': FileCategory.programming,
-    '.mli': FileCategory.programming,
-    '.erl': FileCategory.programming,
-    '.hrl': FileCategory.programming,
-    '.rkt': FileCategory.programming,
-    '.scm': FileCategory.programming,
-    '.ss': FileCategory.programming,
-    '.lisp': FileCategory.programming,
-    '.lsp': FileCategory.programming,
-    '.cl': FileCategory.programming,
-    '.cob': FileCategory.programming,
-    '.cbl': FileCategory.programming,
-    '.ada': FileCategory.programming,
-    '.adb': FileCategory.programming,
-    '.ads': FileCategory.programming,
-    '.prolog': FileCategory.programming,
-    '.pro': FileCategory.programming,
-    '.tcl': FileCategory.programming,
-    '.awk': FileCategory.programming,
-    '.sed': FileCategory.programming,
-
-    // Web Technologies
-    '.html': FileCategory.web,
-    '.htm': FileCategory.web,
-    '.css': FileCategory.web,
-    '.scss': FileCategory.web,
-    '.sass': FileCategory.web,
-    '.less': FileCategory.web,
-    '.vue': FileCategory.web,
-    '.svelte': FileCategory.web,
-    '.astro': FileCategory.web,
-    '.svg': FileCategory.web,
-    '.webp': FileCategory.web,
-    '.woff': FileCategory.web,
-    '.woff2': FileCategory.web,
-    '.ttf': FileCategory.web,
-    '.eot': FileCategory.web,
-    '.otf': FileCategory.web,
-
-    // Data & Config
-    '.json': FileCategory.data,
-    '.xml': FileCategory.data,
-    '.yaml': FileCategory.data,
-    '.yml': FileCategory.data,
-    '.toml': FileCategory.data,
-    '.ini': FileCategory.data,
-    '.conf': FileCategory.data,
-    '.cfg': FileCategory.data,
-    '.properties': FileCategory.data,
-    '.env': FileCategory.data,
-    '.env.local': FileCategory.data,
-    '.env.development': FileCategory.data,
-    '.env.production': FileCategory.data,
-    '.csv': FileCategory.data,
-    '.tsv': FileCategory.data,
-    '.plist': FileCategory.data,
-    '.xls': FileCategory.data,
-    '.xlsx': FileCategory.data,
-    '.ods': FileCategory.data,
-    '.xlsm': FileCategory.data,
-    '.xlsb': FileCategory.data,
-    '.parquet': FileCategory.data,
-    '.avro': FileCategory.data,
-    '.orc': FileCategory.data,
-    '.feather': FileCategory.data,
-    '.arrow': FileCategory.data,
-    '.ndjson': FileCategory.data,
-    '.jsonl': FileCategory.data,
-    '.geojson': FileCategory.data,
-    '.gpx': FileCategory.data,
-    '.kml': FileCategory.data,
-    '.kmz': FileCategory.data,
-    '.prisma': FileCategory.data,
-    '.graphql': FileCategory.data,
-    '.gql': FileCategory.data,
-    '.proto': FileCategory.data,
-    '.thrift': FileCategory.data,
-    '.pkl': FileCategory.data,
-    '.joblib': FileCategory.data,
-    '.h5': FileCategory.data,
-    '.safetensors': FileCategory.data,
-    '.ckpt': FileCategory.data,
-    '.pth': FileCategory.data,
-
-    // Scripts
-    '.sh': FileCategory.script,
-    '.bash': FileCategory.script,
-    '.zsh': FileCategory.script,
-    '.fish': FileCategory.script,
-    '.ps1': FileCategory.script,
-    '.psm1': FileCategory.script,
-    '.psd1': FileCategory.script,
-    '.bat': FileCategory.script,
-    '.cmd': FileCategory.script,
-    '.vbs': FileCategory.script,
-    '.ahk': FileCategory.script,
-
-    // Documentation
-    '.md': FileCategory.documentation,
-    '.markdown': FileCategory.documentation,
-    '.mdx': FileCategory.documentation,
-    '.rst': FileCategory.documentation,
-    '.adoc': FileCategory.documentation,
-    '.asciidoc': FileCategory.documentation,
-    '.tex': FileCategory.documentation,
-    '.latex': FileCategory.documentation,
-    '.txt': FileCategory.documentation,
-    '.rtf': FileCategory.documentation,
-    '.org': FileCategory.documentation,
-    '.pod': FileCategory.documentation,
-    '.man': FileCategory.documentation,
-    '.info': FileCategory.documentation,
-    '.texi': FileCategory.documentation,
-    '.texinfo': FileCategory.documentation,
-    '.ipynb': FileCategory.documentation,
-    '.rmd': FileCategory.documentation,
-    '.qmd': FileCategory.documentation,
-    '.1': FileCategory.documentation,
-    '.2': FileCategory.documentation,
-    '.3': FileCategory.documentation,
-    '.4': FileCategory.documentation,
-    '.5': FileCategory.documentation,
-    '.6': FileCategory.documentation,
-    '.7': FileCategory.documentation,
-    '.8': FileCategory.documentation,
-    '.9': FileCategory.documentation,
-
-    // Database
-    '.sql': FileCategory.database,
-    '.psql': FileCategory.database,
-    '.mysql': FileCategory.database,
-    '.sqlite': FileCategory.database,
-    '.mongodb': FileCategory.database,
-    '.cql': FileCategory.database,
-    '.db': FileCategory.database,
-    '.db3': FileCategory.database,
-    '.sqlite3': FileCategory.database,
-    '.mdb': FileCategory.database,
-    '.accdb': FileCategory.database,
-
-    // DevOps & Build
-    '.dockerfile': FileCategory.devops,
-    '.containerfile': FileCategory.devops,
-    '.makefile': FileCategory.devops,
-    '.mk': FileCategory.devops,
-    '.gradle': FileCategory.devops,
-    '.gradle.kts': FileCategory.devops,
-    '.groovy': FileCategory.devops,
-    '.jenkinsfile': FileCategory.devops,
-    '.travis.yml': FileCategory.devops,
-    '.gitlab-ci.yml': FileCategory.devops,
-    '.github': FileCategory.devops,
-    '.circleci': FileCategory.devops,
-    '.drone.yml': FileCategory.devops,
-    '.buildkite': FileCategory.devops,
-    '.teamcity': FileCategory.devops,
-    '.appveyor.yml': FileCategory.devops,
-    '.azure-pipelines.yml': FileCategory.devops,
-    '.bitbucket-pipelines.yml': FileCategory.devops,
-    '.codeship-services.yml': FileCategory.devops,
-    '.codeship-steps.yml': FileCategory.devops,
-    '.wercker.yml': FileCategory.devops,
-    '.semaphore.yml': FileCategory.devops,
-    '.buildspec.yml': FileCategory.devops,
-    '.cloudbuild.yaml': FileCategory.devops,
-    '.terraform': FileCategory.devops,
-    '.tf': FileCategory.devops,
-    '.tfvars': FileCategory.devops,
-    '.hcl': FileCategory.devops,
-    '.nomad': FileCategory.devops,
-    '.consul': FileCategory.devops,
-    '.vault': FileCategory.devops,
-    '.ansible': FileCategory.devops,
-    '.playbook.yml': FileCategory.devops,
-    '.inventory': FileCategory.devops,
-    '.puppet': FileCategory.devops,
-    '.pp': FileCategory.devops,
-    '.chef': FileCategory.devops,
-    '.cookbook': FileCategory.devops,
-    '.recipe.rb': FileCategory.devops,
-    '.salt': FileCategory.devops,
-    '.sls': FileCategory.devops,
-    '.vagrantfile': FileCategory.devops,
-    '.packer.json': FileCategory.devops,
-    '.pkr.hcl': FileCategory.devops,
-    '.vite': FileCategory.devops,
-    '.webpack': FileCategory.devops,
-    '.rollup': FileCategory.devops,
-    '.esbuild': FileCategory.devops,
-    '.swc': FileCategory.devops,
-    '.turbo': FileCategory.devops,
-    '.nx': FileCategory.devops,
-    '.jest': FileCategory.devops,
-    '.vitest': FileCategory.devops,
-    '.cypress': FileCategory.devops,
-    '.playwright': FileCategory.devops,
-    '.podfile': FileCategory.devops,
-    '.podspec': FileCategory.devops,
-    '.xcconfig': FileCategory.devops,
-
-    // Other
-    '.gitignore': FileCategory.other,
-    '.gitattributes': FileCategory.other,
-    '.gitkeep': FileCategory.other,
-    '.editorconfig': FileCategory.other,
-    '.prettierrc': FileCategory.other,
-    '.prettierignore': FileCategory.other,
-    '.eslintrc': FileCategory.other,
-    '.eslintignore': FileCategory.other,
-    '.stylelintrc': FileCategory.other,
-    '.npmrc': FileCategory.other,
-    '.npmignore': FileCategory.other,
-    '.nvmrc': FileCategory.other,
-    '.rvmrc': FileCategory.other,
-    '.ruby-version': FileCategory.other,
-    '.python-version': FileCategory.other,
-    '.node-version': FileCategory.other,
-    '.tool-versions': FileCategory.other,
-    '.babelrc': FileCategory.other,
-    '.browserslistrc': FileCategory.other,
-    '.huskyrc': FileCategory.other,
-    '.lintstagedrc': FileCategory.other,
-    '.commitlintrc': FileCategory.other,
-    '.renovaterc': FileCategory.other,
-    '.dependabot': FileCategory.other,
-    '.dockerignore': FileCategory.other,
-    '.yarnrc': FileCategory.other,
-    '.pnpm': FileCategory.other,
-    'bun.lockb': FileCategory.other,
-    '.mdc': FileCategory.other,
-    '.cursorrules': FileCategory.other,
-    '.claude': FileCategory.other,
-    '.copilot': FileCategory.other,
-    '.aider': FileCategory.other,
-    '.promptfile': FileCategory.other,
-    '.prompt': FileCategory.other,
-    '.log': FileCategory.other,
-    '.lock': FileCategory.other,
-    '.pid': FileCategory.other,
-    '.cache': FileCategory.other,
-    '.tmp': FileCategory.other,
-    '.temp': FileCategory.other,
-    '.bak': FileCategory.other,
-    '.backup': FileCategory.other,
-    '.old': FileCategory.other,
-    '.orig': FileCategory.other,
-    '.rej': FileCategory.other,
-    '.diff': FileCategory.other,
-    '.patch': FileCategory.other,
-    '.pub': FileCategory.other,
-    '.pem': FileCategory.other,
-    '.key': FileCategory.other,
-    '.crt': FileCategory.other,
-    '.cer': FileCategory.other,
-    '.p12': FileCategory.other,
-    '.pfx': FileCategory.other,
-    '.jks': FileCategory.other,
-    '.license': FileCategory.other,
-    '.lic': FileCategory.other,
-    '.authors': FileCategory.other,
-    '.contributors': FileCategory.other,
-    '.notice': FileCategory.other,
-    '.patents': FileCategory.other,
-    '.changelog': FileCategory.other,
-    '.changes': FileCategory.other,
-    '.history': FileCategory.other,
-    '.news': FileCategory.other,
-    '.releases': FileCategory.other,
-    '.todo': FileCategory.other,
-    '.tasks': FileCategory.other,
-    '.fixme': FileCategory.other,
-    '.bugs': FileCategory.other,
-    '.issues': FileCategory.other,
-    '.notes': FileCategory.other,
-    '.memo': FileCategory.other,
-    '.manifest': FileCategory.other,
-    '.version': FileCategory.other,
-    '.ver': FileCategory.other,
-    '.rev': FileCategory.other,
-    '.revision': FileCategory.other,
-    '.build': FileCategory.other,
-    '.dist': FileCategory.other,
-    '.out': FileCategory.other,
-    '.output': FileCategory.other,
-    '.result': FileCategory.other,
-    '.results': FileCategory.other,
-    '.test': FileCategory.other,
-    '.tests': FileCategory.other,
-    '.spec': FileCategory.other,
-    '.specs': FileCategory.other,
-    '.example': FileCategory.other,
-    '.examples': FileCategory.other,
-    '.sample': FileCategory.other,
-    '.samples': FileCategory.other,
-    '.demo': FileCategory.other,
-    '.demos': FileCategory.other,
-    '.template': FileCategory.other,
-    '.templates': FileCategory.other,
-    '.stub': FileCategory.other,
-    '.stubs': FileCategory.other,
-    '.mock': FileCategory.other,
-    '.mocks': FileCategory.other,
-    '.fixture': FileCategory.other,
-    '.fixtures': FileCategory.other,
-    '.snapshot': FileCategory.other,
-    '.snapshots': FileCategory.other,
-    '.coverage': FileCategory.other,
-    '.report': FileCategory.other,
-    '.reports': FileCategory.other,
-    '.analysis': FileCategory.other,
-    '.analyses': FileCategory.other,
-    '.metrics': FileCategory.other,
-    '.measure': FileCategory.other,
-    '.measures': FileCategory.other,
-    '.stat': FileCategory.other,
-    '.stats': FileCategory.other,
-    '.perf': FileCategory.other,
-    '.performance': FileCategory.other,
-    '.benchmark': FileCategory.other,
-    '.benchmarks': FileCategory.other,
-    '.profile': FileCategory.other,
-    '.profiles': FileCategory.other,
-    '.trace': FileCategory.other,
-    '.traces': FileCategory.other,
-    '.dump': FileCategory.other,
-    '.dumps': FileCategory.other,
-    '.core': FileCategory.other,
-    '.crash': FileCategory.other,
-    '.err': FileCategory.other,
-    '.error': FileCategory.other,
-    '.errors': FileCategory.other,
-    '.warn': FileCategory.other,
-    '.warning': FileCategory.other,
-    '.warnings': FileCategory.other,
-    '.debug': FileCategory.other,
-    '.verbose': FileCategory.other,
-    '.stacktrace': FileCategory.other,
-    '.backtrace': FileCategory.other,
-    '.coredump': FileCategory.other,
-    '.heapdump': FileCategory.other,
-    '.threaddump': FileCategory.other,
-    '.memdump': FileCategory.other,
-  };
-
-  /// Get all supported extensions from the catalog
-  static Map<String, FileCategory> get extensionCategories =>
-      Map.unmodifiable(_extensionCategories);
-
-  /// Get all supported extensions
-  static Set<String> get supportedExtensions =>
-      _extensionCategories.keys.toSet();
-
-  /// Check if a file extension is supported for text extraction
-  static bool supportsText(String extension) {
-    return _extensionCategories.containsKey(extension.toLowerCase());
-  }
-
-  /// Get the category for a file extension
-  static FileCategory? getCategory(String extension) {
-    return _extensionCategories[extension.toLowerCase()];
-  }
-
-  /// Get all extensions for a specific category
-  static List<String> getExtensionsByCategory(FileCategory category) {
-    return _extensionCategories.entries
-        .where((entry) => entry.value == category)
-        .map((entry) => entry.key)
-        .toList()
-      ..sort();
-  }
-
-  /// Get extensions grouped by category
-  static Map<FileCategory, List<String>> getGroupedExtensions() {
-    final grouped = <FileCategory, List<String>>{};
-
-    for (final category in FileCategory.values) {
-      final extensions = getExtensionsByCategory(category);
-      if (extensions.isNotEmpty) {
-        grouped[category] = extensions;
-      }
-    }
-
-    return grouped;
-  }
-}
-
-/// File category enumeration
-enum FileCategory {
-  programming('Programming Languages', Icons.code),
-  web('Web Technologies', Icons.web),
-  data('Data & Config', Icons.data_object),
-  script('Scripts', Icons.terminal),
-  documentation('Documentation', Icons.description),
-  database('Database', Icons.storage),
-  devops('DevOps & Build', Icons.build_circle),
-  other('Other', Icons.insert_drive_file);
-
-  const FileCategory(this.displayName, this.icon);
-
-  final String displayName;
-  final IconData icon;
-}
-
-/// Top-level function to check if an extension supports text extraction
-/// This is the clean API mentioned in the roadmap
-bool supportsTextHelper(
-    String extension, Map<String, FileCategory>? customExtensions) {
-  final ext = extension.toLowerCase();
-
-  // Check custom extensions first (user preferences)
-  if (customExtensions != null && customExtensions.containsKey(ext)) {
-    return true;
-  }
-
-  // Fall back to catalog
-  return ExtensionCatalog.supportsText(ext);
-}
-
-/// Get category for an extension, considering user preferences
-FileCategory? getExtensionCategory(
-    String extension, Map<String, FileCategory>? customExtensions) {
-  final ext = extension.toLowerCase();
-
-  // Check custom extensions first
-  if (customExtensions != null && customExtensions.containsKey(ext)) {
-    return customExtensions[ext];
-  }
-
-  // Fall back to catalog
-  return ExtensionCatalog.getCategory(ext);
-}
diff --git a/lib/src/shared/utils/language_mapper.dart b/lib/src/shared/utils/language_mapper.dart
deleted file mode 100644
index 266877a..0000000
--- a/lib/src/shared/utils/language_mapper.dart
+++ /dev/null
@@ -1,446 +0,0 @@
-import 'dart:io';
-
-import 'package:path/path.dart' as path;
-
-/// Maps file extensions to language identifiers for syntax highlighting
-/// Enhanced version based on the Python implementation
-class LanguageMapper {
-  /// Maps file extensions to language identifiers for code snippets
-  /// Only includes mappings where extension != language identifier
-  static const Map<String, String> _extensionToLanguage = {
-    // Systems Programming - Headers and alternate extensions
-    '.h': 'c',
-    '.cc': 'cpp',
-    '.cxx': 'cpp',
-    '.c++': 'cpp',
-    '.hpp': 'cpp',
-    '.hxx': 'cpp',
-    '.h++': 'cpp',
-    '.hh': 'cpp',
-    '.rlib': 'rust',
-    '.rs.in': 'rust',
-
-    // JVM Languages - Alternate extensions
-    '.jar': 'java',
-    '.class': 'java',
-    '.jav': 'java',
-    '.kts': 'kotlin', // Kotlin script
-    '.ktm': 'kotlin',
-    '.sc': 'scala',
-    '.sbt': 'scala',
-    '.gvy': 'groovy',
-    '.gy': 'groovy',
-    '.gradle': 'groovy',
-    '.jenkinsfile': 'groovy',
-
-    // Scripting Languages - Alternate extensions
-    '.pyw': 'python', // Python Windows
-    '.pyx': 'python', // Cython
-    '.py': 'python', // python
-    '.pxd': 'python', // Cython
-    '.pyi': 'python', // Python stub
-    '.py3': 'python',
-    '.rpy': 'python', // Ren'Py
-    '.sage': 'python',
-    '.wsgi': 'python',
-    '.mjs': 'javascript', // ES modules
-    '.cjs': 'javascript', // CommonJS
-    '.jsx': 'javascript', // React JSX (some prefer jsx highlighting)
-    '.tsx': 'typescript', // TypeScript JSX
-    '.d.ts': 'typescript', // TypeScript definitions
-    '.rbw': 'ruby', // Ruby Windows
-    '.erb': 'ruby', // Embedded Ruby
-    '.gemspec': 'ruby',
-    '.podspec': 'ruby',
-    '.rake': 'ruby',
-    '.ru': 'ruby', // Rack config
-    '.thor': 'ruby',
-    '.pm': 'perl', // Perl module
-    '.pod': 'perl', // Perl documentation
-    '.t': 'perl', // Perl test
-    '.phtml': 'php',
-    '.php3': 'php',
-    '.php4': 'php',
-    '.php5': 'php',
-    '.php7': 'php',
-    '.phps': 'php',
-    '.phar': 'php',
-    '.bash': 'shell',
-    '.zsh': 'shell',
-    '.fish': 'shell',
-    '.ksh': 'shell',
-    '.csh': 'shell',
-    '.tcsh': 'shell',
-    '.ash': 'shell',
-    '.dash': 'shell',
-    '.bashrc': 'shell',
-    '.zshrc': 'shell',
-    '.profile': 'shell',
-    '.ps1': 'powershell',
-    '.psm1': 'powershell',
-    '.psd1': 'powershell',
-    '.pssc': 'powershell',
-
-    // Mobile Development
-    '.m': 'objective-c',
-    '.mm': 'objective-c',
-
-    // Web Technologies - Alternate extensions and frameworks
-    '.htm': 'html',
-    '.xhtml': 'html',
-    '.shtml': 'html',
-    '.cshtml': 'html', // Razor
-    '.vue': 'html', // Vue.js (or could be 'vue' if supported)
-    '.svelte': 'html',
-    '.hbs': 'handlebars',
-    '.handlebars': 'handlebars',
-    '.mustache': 'handlebars',
-    '.ejs': 'html', // EJS templates
-    '.pug': 'pug', // Pug templates
-    '.slim': 'slim', // Slim templates
-    '.scss': 'scss',
-    '.sass': 'sass',
-    '.less': 'less',
-    '.styl': 'stylus',
-    '.stylus': 'stylus',
-
-    // Data & Config Formats - Alternate extensions
-    '.jsonl': 'json', // JSON Lines
-    '.json5': 'json', // JSON5
-    '.jsonc': 'json', // JSON with comments
-    '.yml': 'yaml',
-    '.yaml-tmpl': 'yaml',
-    '.yml.tmpl': 'yaml',
-    '.toml': 'toml',
-    '.tml': 'toml',
-    '.xsl': 'xml',
-    '.xslt': 'xml',
-    '.plist': 'xml',
-    '.rss': 'xml',
-    '.atom': 'xml',
-    '.svg': 'xml',
-    '.cfg': 'ini',
-    '.conf': 'ini',
-    '.config': 'ini',
-    '.properties': 'ini',
-    '.env': 'ini', // Environment files
-    '.dotenv': 'ini',
-    '.gql': 'graphql',
-    '.graphqls': 'graphql',
-    '.proto': 'protobuf',
-    '.proto3': 'protobuf',
-
-    // Documentation - Alternate extensions
-    '.markdown': 'markdown',
-    '.mdown': 'markdown',
-    '.md': 'markdown',
-    '.mkd': 'markdown',
-    '.mkdn': 'markdown',
-    '.mdwn': 'markdown',
-    '.mdx': 'markdown', // MDX (Markdown + JSX)
-    '.rst': 'restructuredtext',
-    '.rest': 'restructuredtext',
-    '.restx': 'restructuredtext',
-    '.rtxt': 'restructuredtext',
-    '.adoc': 'asciidoc',
-    '.asciidoc': 'asciidoc',
-    '.asc': 'asciidoc',
-    '.tex': 'latex',
-    '.ltx': 'latex',
-    '.latex': 'latex',
-    '.sty': 'latex',
-    '.cls': 'latex',
-
-    // Database - Alternate extensions
-    '.mysql': 'sql',
-    '.pgsql': 'sql',
-    '.sqlite': 'sql',
-    '.psql': 'sql',
-    '.plsql': 'sql',
-    '.cypher': 'cypher',
-    '.cql': 'cypher', // Cypher Query Language
-    '.sparql': 'sparql',
-    '.rq': 'sparql',
-
-    // Build & Package - Alternate extensions
-    '.cmake': 'cmake',
-    '.make': 'makefile',
-    '.mak': 'makefile',
-    '.mk': 'makefile',
-    '.gmk': 'makefile',
-    '.dockerfile': 'dockerfile',
-    '.docker': 'dockerfile',
-    '.containerfile': 'dockerfile',
-
-    // .NET and Windows
-    '.csproj': 'xml',
-    '.vbproj': 'xml',
-    '.fsproj': 'xml',
-    '.vcxproj': 'xml',
-    '.targets': 'xml',
-    '.props': 'xml',
-    '.vb': 'vb',
-    '.bas': 'vb',
-    '.frm': 'vb',
-    '.razor': 'razor',
-    '.bat': 'bat',
-    '.cmd': 'bat',
-
-    // Other Languages - Alternate extensions
-    '.rmd': 'markdown', // R Markdown
-    '.rnw': 'latex', // R Sweave
-    '.fs': 'fsharp',
-    '.fsx': 'fsharp',
-    '.fsi': 'fsharp',
-    '.ex': 'elixir',
-    '.exs': 'elixir',
-    '.eex': 'elixir', // Embedded Elixir
-    '.leex': 'elixir',
-    '.erl': 'erlang',
-    '.hrl': 'erlang',
-    '.clj': 'clojure',
-    '.cljs': 'clojure',
-    '.cljc': 'clojure',
-    '.edn': 'clojure',
-    '.hs': 'haskell',
-    '.lhs': 'haskell',
-    '.cabal': 'haskell',
-    '.tf': 'hcl', // Terraform
-    '.tfvars': 'hcl',
-    '.hcl': 'hcl',
-    '.nomad': 'hcl',
-    '.v': 'verilog',
-    '.sv': 'systemverilog',
-    '.svh': 'systemverilog',
-    '.ml': 'ocaml',
-    '.mli': 'ocaml',
-    '.wat': 'wasm', // WebAssembly text
-    '.wast': 'wasm',
-    '.glsl': 'glsl',
-    '.vert': 'glsl',
-    '.frag': 'glsl',
-    '.geom': 'glsl',
-    '.comp': 'glsl',
-    '.tesc': 'glsl',
-    '.tese': 'glsl',
-    '.hlsl': 'hlsl',
-    '.fx': 'hlsl',
-    '.fxh': 'hlsl',
-
-    // Cloud & Infrastructure
-    '.bicep': 'bicep',
-    '.azcli': 'azcli',
-    '.k8s': 'yaml', // Kubernetes manifests
-    '.kube': 'yaml',
-
-    // Dart specific (since you love Dart!)
-    '.dart.js': 'javascript', // Compiled Dart to JS
-    '.g.dart': 'dart', // Generated Dart files
-    '.freezed.dart': 'dart',
-    '.chopper.dart': 'dart',
-
-    // Additional scripting (since you love scripting!)
-    '.awk': 'awk',
-    '.sed': 'sed',
-    '.expect': 'expect',
-    '.applescript': 'applescript',
-    '.scpt': 'applescript',
-    '.osascript': 'applescript',
-    '.jq': 'jq', // jq query language
-    '.nu': 'nu', // Nushell
-    '.just': 'just', // Justfile
-    '.justfile': 'just',
-  };
-
-  /// Special case for files without extensions but with specific names
-  static const Map<String, String> _filenameToLanguage = {
-    'dockerfile': 'dockerfile',
-    'Dockerfile': 'dockerfile',
-    'makefile': 'makefile',
-    'Makefile': 'makefile',
-    'gnumakefile': 'makefile',
-    'GNUmakefile': 'makefile',
-    'cmakelists.txt': 'cmake',
-    'CMakeLists.txt': 'cmake',
-    '.gitignore': 'gitignore',
-    '.gitattributes': 'gitattributes',
-    '.editorconfig': 'ini',
-    'package.json': 'json',
-    'package-lock.json': 'json',
-    'tsconfig.json': 'json',
-    'jsconfig.json': 'json',
-    '.eslintrc': 'json',
-    '.eslintrc.json': 'json',
-    '.prettierrc': 'json',
-    '.prettierrc.json': 'json',
-    'pubspec.yaml': 'yaml',
-    'pubspec.yml': 'yaml',
-    'app.yaml': 'yaml',
-    'app.yml': 'yaml',
-    'docker-compose.yml': 'yaml',
-    'docker-compose.yaml': 'yaml',
-    '.travis.yml': 'yaml',
-    '.github/workflows/main.yml': 'yaml',
-    'requirements.txt': 'plaintext',
-    'Pipfile': 'toml',
-    'Cargo.toml': 'toml',
-    'go.mod': 'go',
-    'go.sum': 'go',
-  };
-
-  /// Get language identifier for a file based on its extension or name
-  static String getLanguageForFile(String filePath) {
-    final fileName = path.basename(filePath).toLowerCase();
-    final extension = path.extension(filePath).toLowerCase();
-
-    // First check if we have a specific mapping for this exact filename
-    if (_filenameToLanguage.containsKey(fileName)) {
-      return _filenameToLanguage[fileName]!;
-    }
-
-    // Then check extension mapping
-    if (_extensionToLanguage.containsKey(extension)) {
-      return _extensionToLanguage[extension]!;
-    }
-
-    // Some special cases for shebang files (when no extension)
-    if (extension.isEmpty) {
-      try {
-        final file = File(filePath);
-        if (file.existsSync()) {
-          final firstLine = file.readAsLinesSync().firstOrNull ?? '';
-          if (firstLine.startsWith('#!')) {
-            if (firstLine.contains('python')) return 'python';
-            if (firstLine.contains('node')) return 'javascript';
-            if (firstLine.contains('bash') || firstLine.contains('/sh')) {
-              return 'shell';
-            }
-            if (firstLine.contains('ruby')) return 'ruby';
-            if (firstLine.contains('perl')) return 'perl';
-            if (firstLine.contains('php')) return 'php';
-            if (firstLine.contains('lua')) return 'lua';
-          }
-        }
-      } catch (_) {
-        // Ignore file read errors
-      }
-      return 'plaintext'; // No extension and no shebang
-    }
-
-    // Default: return extension without the dot (e.g., .java -> java, .cpp -> cpp)
-    return extension.substring(1);
-  }
-
-  /// Get language identifier for a file extension
-  static String getLanguageForExtension(String extension) {
-    // Ensure extension starts with a dot
-    final normalizedExt = extension.startsWith('.') ? extension : '.$extension';
-    final extLower = normalizedExt.toLowerCase();
-
-    // Return mapped language or extension without dot as fallback
-    return _extensionToLanguage[extLower] ?? extLower.substring(1);
-  }
-
-  /// Check if a language is supported for syntax highlighting
-  /// This includes both explicitly mapped languages and any valid extension
-  static bool isLanguageSupported(String language) {
-    final languageLower = language.toLowerCase();
-
-    // Check if it's in our explicit mapping
-    if (_extensionToLanguage.values.contains(languageLower)) {
-      return true;
-    }
-
-    // Check if it's in filename mappings
-    if (_filenameToLanguage.values.contains(languageLower)) {
-      return true;
-    }
-
-    // Accept any non-empty language identifier (since we fallback to extensions)
-    return languageLower.isNotEmpty && languageLower != 'plaintext';
-  }
-
-  /// Get all supported languages (including common extensions)
-  static Set<String> getSupportedLanguages() {
-    final languages = <String>{}
-
-      // Add explicitly mapped languages
-      ..addAll(_extensionToLanguage.values)
-      ..addAll(_filenameToLanguage.values);
-
-    // Add common programming language extensions that would be auto-detected
-    final commonExtensions = {
-      'java',
-      'cpp',
-      'dart',
-      'swift',
-      'go',
-      'rust',
-      'kotlin',
-      'scala',
-      'python',
-      'ruby',
-      'php',
-      'perl',
-      'lua',
-      'javascript',
-      'typescript',
-      'html',
-      'css',
-      'xml',
-      'json',
-      'yaml',
-      'sql',
-      'markdown',
-      'c',
-    };
-    languages.addAll(commonExtensions);
-
-    return languages;
-  }
-
-  /// Get all supported file extensions (from the explicit mapping)
-  static Set<String> getSupportedExtensions() {
-    return _extensionToLanguage.keys.toSet();
-  }
-
-  /// Get the appropriate language display name (for UI)
-  static String getLanguageDisplayName(String language) {
-    final displayNames = {
-      'c': 'C',
-      'cpp': 'C++',
-      'csharp': 'C#',
-      'css': 'CSS',
-      'dart': 'Dart',
-      'dockerfile': 'Dockerfile',
-      'fsharp': 'F#',
-      'go': 'Go',
-      'html': 'HTML',
-      'java': 'Java',
-      'javascript': 'JavaScript',
-      'json': 'JSON',
-      'kotlin': 'Kotlin',
-      'markdown': 'Markdown',
-      'objective-c': 'Objective-C',
-      'php': 'PHP',
-      'plaintext': 'Plain Text',
-      'powershell': 'PowerShell',
-      'python': 'Python',
-      'ruby': 'Ruby',
-      'rust': 'Rust',
-      'scss': 'SCSS',
-      'shell': 'Shell',
-      'sql': 'SQL',
-      'swift': 'Swift',
-      'typescript': 'TypeScript',
-      'vb': 'Visual Basic',
-      'xml': 'XML',
-      'yaml': 'YAML',
-    };
-
-    final languageLower = language.toLowerCase();
-    return displayNames[languageLower] ??
-        language.substring(0, 1).toUpperCase() +
-            (language.length > 1 ? language.substring(1).toLowerCase() : '');
-  }
-}
diff --git a/lib/src/shared/utils/vscode_drop_detector.dart b/lib/src/shared/utils/vscode_drop_detector.dart
deleted file mode 100644
index 22230f2..0000000
--- a/lib/src/shared/utils/vscode_drop_detector.dart
+++ /dev/null
@@ -1,57 +0,0 @@
-import 'dart:io';
-
-/// Utility class to detect and handle VS Code directory drops
-///
-/// When dragging a directory from VS Code's file tree, VS Code creates
-/// a temporary HTML file containing a JavaScript listing of the directory.
-/// This class extracts the actual directory path from that listing.
-class VSCodeDropDetector {
-  /// Extract directory path from VS Code's HTML listing file
-  ///
-  /// Looks for: <script>start("/path/to/directory/");</script>
-  static String? extractDirectoryPath(String content) {
-    final match =
-        RegExp(r'<script>start\("([^"]+)"\);</script>').firstMatch(content);
-    return match?.group(1);
-  }
-
-  /// Check if this is a VS Code directory listing file
-  static bool isVSCodeDirectoryListing(String filePath, String content) {
-    return filePath.contains('/tmp/Drops/') &&
-        content.contains('<script>start("') &&
-        content.contains('addRow(');
-  }
-
-  /// Try to extract directory path from a potential VS Code drop file
-  /// Returns null if not a VS Code directory listing or if extraction fails
-  static Future<String?> tryExtractVSCodeDirectory(String filePath) async {
-    // Quick check if it's in the temp drops folder
-    if (!filePath.contains('/tmp/Drops/')) {
-      return null;
-    }
-
-    try {
-      final file = File(filePath);
-      if (!file.existsSync()) {
-        return null;
-      }
-
-      final content = await file.readAsString();
-
-      if (!isVSCodeDirectoryListing(filePath, content)) {
-        return null;
-      }
-
-      final directoryPath = extractDirectoryPath(content);
-
-      // Verify the directory actually exists
-      if (directoryPath != null && Directory(directoryPath).existsSync()) {
-        return directoryPath;
-      }
-    } catch (_) {
-      // Any error means this isn't a VS Code directory listing
-    }
-
-    return null;
-  }
-}
diff --git a/lib/src/shared/widgets/resizable_splitter.dart b/lib/src/shared/widgets/resizable_splitter.dart
index 1034a98..748b950 100644
--- a/lib/src/shared/widgets/resizable_splitter.dart
+++ b/lib/src/shared/widgets/resizable_splitter.dart
@@ -1,123 +1,574 @@
-import 'dart:developer';
+// ignore_for_file: use_setters_to_change_properties
+// Production-ready Flutter splitter with bulletproof pointer handling
+// Version: 1.0.0
 
-import 'package:context_collector/src/shared/theme/extensions.dart';
 import 'package:flutter/material.dart';
+import 'package:flutter/services.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
 
-/// A widget that allows resizing two panels with a draggable divider
+// Re-export for clean imports
+export 'package:flutter/material.dart' show Axis;
+
+/// Axis helpers to eliminate H/V duplication
+extension _AxisHelpers on Axis {
+  bool get isH => this == Axis.horizontal;
+
+  double pos(Offset o) => isH ? o.dx : o.dy;
+
+  double size(Size s) => isH ? s.width : s.height;
+
+  SystemMouseCursor get cursor =>
+      isH ? SystemMouseCursors.resizeColumn : SystemMouseCursors.resizeRow;
+}
+
+/// A controller for managing splitter position with automatic persistence support.
+///
+/// The controller maintains the split ratio (0.0 to 1.0) and provides
+/// methods for programmatic control. It automatically handles global
+/// pointer events to prevent stuck drags.
+///
+/// Example:
+/// ```dart
+/// final controller = SplitterController(initialRatio: 0.3);
+/// // Later...
+/// controller.reset(); // Returns to default position
+/// ```
+class SplitterController extends ValueNotifier<double> {
+  /// Creates a splitter controller with the given initial ratio.
+  ///
+  /// The [initialRatio] must be between 0.0 and 1.0.
+  SplitterController({double initialRatio = 0.5})
+    : assert(
+        initialRatio >= 0.0 && initialRatio <= 1.0,
+        'initialRatio >= 0.0 && initialRatio <= 1.0',
+      ),
+      super(initialRatio) {
+    _globalRouter.register(this);
+  }
+
+  static final _globalRouter = _GlobalPointerRouter();
+
+  @override
+  void dispose() {
+    _globalRouter.unregister(this);
+    super.dispose();
+  }
+
+  /// Updates the ratio with optional threshold to prevent chatty updates.
+  ///
+  /// Only notifies listeners if the change exceeds [threshold].
+  void updateRatio(double newRatio, {double threshold = 0.002}) {
+    final clamped = newRatio.clamp(0.0, 1.0);
+    if ((clamped - value).abs() > threshold) {
+      value = clamped;
+    }
+  }
+
+  /// Resets the splitter to the specified position.
+  ///
+  /// If [to] is not provided, defaults to 0.5 (center).
+  void reset([double to = 0.5]) {
+    assert(to >= 0.0 && to <= 1.0, 'to >= 0.0 && to <= 1.0');
+    value = to;
+  }
+
+  // Internal methods for global router
+  void _stopDrag() {
+    _dragCallback?.call();
+    _dragCallback = null;
+  }
+
+  void _setDragCallback(VoidCallback? cb) => _dragCallback = cb;
+  VoidCallback? _dragCallback;
+
+  /// Resets the global pointer router. For testing only.
+  @visibleForTesting
+  static void resetGlobalRouter() => _globalRouter.dispose();
+}
+
+/// Singleton global pointer router with drag throttling.
+/// Handles pointer events globally to prevent stuck drags.
+class _GlobalPointerRouter {
+  factory _GlobalPointerRouter() => _instance;
+
+  _GlobalPointerRouter._() {
+    _initialize();
+  }
+
+  static final _instance = _GlobalPointerRouter._();
+
+  final _controllers = <SplitterController>{};
+  SplitterController? _currentlyDragging;
+  bool _initialized = false;
+
+  void _initialize() {
+    if (!_initialized) {
+      WidgetsBinding.instance.pointerRouter.addGlobalRoute(_handleGlobal);
+      _initialized = true;
+    }
+  }
+
+  void register(SplitterController c) {
+    _initialize();
+    _controllers.add(c);
+  }
+
+  void unregister(SplitterController c) {
+    _controllers.remove(c);
+    if (c == _currentlyDragging) {
+      _currentlyDragging = null;
+    }
+  }
+
+  void setDragging(SplitterController? c) {
+    _currentlyDragging = c;
+  }
+
+  void _handleGlobal(PointerEvent event) {
+    // Note: Firefox may send PointerCancel without PointerUp
+    if (event is PointerUpEvent || event is PointerCancelEvent) {
+      // Throttled: only notify the currently dragging controller
+      _currentlyDragging?._stopDrag();
+      _currentlyDragging = null;
+    }
+  }
+
+  void dispose() {
+    if (_initialized) {
+      WidgetsBinding.instance.pointerRouter.removeGlobalRoute(_handleGlobal);
+      _initialized = false;
+      _controllers.clear();
+      _currentlyDragging = null;
+    }
+  }
+}
+
+/// A high-performance resizable splitter widget with native-like behavior.
+///
+/// This splitter provides smooth dragging, keyboard navigation, and proper
+/// handling of edge cases like stuck drags. It works correctly inside
+/// scrollable widgets and supports both mouse and touch input.
+///
+/// Example:
+/// ```dart
+/// ResizableSplitter(
+///   startPanel: LeftPanel(),
+///   endPanel: RightPanel(),
+///   onRatioChanged: (ratio) => savePreference('split_ratio', ratio),
+/// )
+/// ```
 class ResizableSplitter extends StatefulWidget {
+  /// Creates a resizable splitter widget.
+  ///
+  /// The [startPanel] and [endPanel] are required and represent the
+  /// two panels being split.
   const ResizableSplitter({
     required this.startPanel,
     required this.endPanel,
     super.key,
-    this.initialRatio = 0.4,
-    this.minRatio = 0.2,
-    this.maxRatio = 0.8,
-    this.dividerThickness = 8,
+    this.controller,
+    this.axis = Axis.horizontal,
+    this.initialRatio = 0.5,
+    this.minRatio = 0.1,
+    this.maxRatio = 0.9,
+    this.minPanelSize = 100.0,
+    this.dividerThickness = 6.0,
+    this.dividerColor,
+    this.dividerHoverColor,
+    this.dividerActiveColor,
     this.onRatioChanged,
-  });
+    this.enableKeyboard = true,
+    this.semanticsLabel,
+  }) : assert(
+         initialRatio >= 0.0 && initialRatio <= 1.0,
+         'initialRatio >= 0.0 && initialRatio <= 1.0',
+       ),
+       assert(
+         minRatio >= 0.0 && minRatio <= 1.0,
+         'minRatio >= 0.0 && minRatio <= 1.0',
+       ),
+       assert(
+         maxRatio >= 0.0 && maxRatio <= 1.0,
+         'maxRatio >= 0.0 && maxRatio <= 1.0',
+       ),
+       assert(minRatio < maxRatio, 'minRatio < maxRatio');
 
+  /// The widget to display in the start position (left/top).
   final Widget startPanel;
+
+  /// The widget to display in the end position (right/bottom).
   final Widget endPanel;
+
+  /// Optional controller for programmatic control and persistence.
+  final SplitterController? controller;
+
+  /// The axis along which to split (horizontal or vertical).
+  final Axis axis;
+
+  /// Initial split ratio if no controller is provided.
   final double initialRatio;
+
+  /// Minimum allowed ratio (0.0 to 1.0).
   final double minRatio;
+
+  /// Maximum allowed ratio (0.0 to 1.0).
   final double maxRatio;
+
+  /// Minimum size in pixels for either panel.
+  final double minPanelSize;
+
+  /// Thickness of the divider handle in pixels.
   final double dividerThickness;
+
+  /// Color of the divider in idle state.
+  final Color? dividerColor;
+
+  /// Color of the divider when hovered.
+  final Color? dividerHoverColor;
+
+  /// Color of the divider when being dragged.
+  final Color? dividerActiveColor;
+
+  /// Called when the split ratio changes.
   final ValueChanged<double>? onRatioChanged;
 
+  /// Whether to enable keyboard navigation with arrow keys.
+  final bool enableKeyboard;
+
+  /// Accessibility label for the divider.
+  final String? semanticsLabel;
+
   @override
   State<ResizableSplitter> createState() => _ResizableSplitterState();
 }
 
 class _ResizableSplitterState extends State<ResizableSplitter> {
-  late double _ratio;
-  bool _isDragging = false;
+  late final FocusNode _focusNode;
+  SplitterController? _internalController;
+
+  SplitterController get _effectiveController =>
+      widget.controller ??
+      (_internalController ??= SplitterController(
+        initialRatio: widget.initialRatio,
+      ));
 
   @override
   void initState() {
     super.initState();
-    _ratio = widget.initialRatio;
+    _focusNode = FocusNode();
   }
 
-  void _handleDragUpdate(DragUpdateDetails details) {
-    RenderBox? box;
-    try {
-      box = context.findRenderObject() as RenderBox?;
-    } catch (e, s) {
-      log('Error finding render object: $e', error: e, stackTrace: s);
+  @override
+  void didUpdateWidget(ResizableSplitter oldWidget) {
+    super.didUpdateWidget(oldWidget);
+
+    // Clean up focus node if widget is being replaced
+    if (oldWidget.controller != widget.controller && !mounted) {
+      _focusNode.dispose();
     }
+  }
 
-    final width = box?.size.width ?? 0;
+  @override
+  void dispose() {
+    _focusNode.dispose();
+    _internalController?.dispose();
+    super.dispose();
+  }
 
-    setState(() {
-      _ratio += details.delta.dx / width;
-      _ratio = _ratio.clamp(widget.minRatio, widget.maxRatio);
-    });
+  @override
+  Widget build(BuildContext context) {
+    return LayoutBuilder(
+      builder: (context, constraints) {
+        final maxSize = widget.axis.size(constraints.biggest);
+
+        if (!maxSize.isFinite || maxSize <= 0) {
+          return Flex(
+            direction: widget.axis,
+            children: [
+              Expanded(child: widget.startPanel),
+              Expanded(child: widget.endPanel),
+            ],
+          );
+        }
+
+        return ValueListenableBuilder<double>(
+          valueListenable: _effectiveController,
+          builder: (_, ratio, _) {
+            // Account for divider thickness to prevent overflow
+            final availableSize = maxSize - widget.dividerThickness;
+
+            // Calculate panel sizes based on available space
+            var first = availableSize * ratio;
+            var second = availableSize - first;
+
+            // Ensure minimum panel sizes are respected
+            final effectiveMinPanelSize = widget.minPanelSize.clamp(
+              0.0,
+              availableSize / 2,
+            );
+
+            if (first < effectiveMinPanelSize) {
+              first = effectiveMinPanelSize;
+              second = availableSize - first;
+            } else if (second < effectiveMinPanelSize) {
+              second = effectiveMinPanelSize;
+              first = availableSize - second;
+            }
 
-    widget.onRatioChanged?.call(_ratio);
+            return Flex(
+              direction: widget.axis,
+              children: [
+                SizedBox(
+                  width: widget.axis.isH ? first : null,
+                  height: widget.axis.isH ? null : first,
+                  child: widget.startPanel,
+                ),
+                _DividerHandle(
+                  axis: widget.axis,
+                  controller: _effectiveController,
+                  thickness: widget.dividerThickness,
+                  minRatio: widget.minRatio,
+                  maxRatio: widget.maxRatio,
+                  minPanelSize: widget.minPanelSize,
+                  maxSize: availableSize,
+                  // Pass available size, not total
+                  dividerColor: widget.dividerColor,
+                  dividerHoverColor: widget.dividerHoverColor,
+                  dividerActiveColor: widget.dividerActiveColor,
+                  onRatioChanged: widget.onRatioChanged,
+                  enableKeyboard: widget.enableKeyboard,
+                  focusNode: _focusNode,
+                  semanticsLabel: widget.semanticsLabel,
+                ),
+                SizedBox(
+                  width: widget.axis.isH ? second : null,
+                  height: widget.axis.isH ? null : second,
+                  child: widget.endPanel,
+                ),
+              ],
+            );
+          },
+        );
+      },
+    );
   }
+}
 
-  void _handleDragStart(DragStartDetails details) {
-    setState(() {
-      _isDragging = true;
-    });
+/// Internal divider handle widget
+class _DividerHandle extends StatefulWidget {
+  const _DividerHandle({
+    required this.axis,
+    required this.controller,
+    required this.thickness,
+    required this.minRatio,
+    required this.maxRatio,
+    required this.minPanelSize,
+    required this.maxSize,
+    required this.dividerColor,
+    required this.dividerHoverColor,
+    required this.dividerActiveColor,
+    required this.onRatioChanged,
+    required this.enableKeyboard,
+    required this.focusNode,
+    required this.semanticsLabel,
+  });
+
+  final Axis axis;
+  final SplitterController controller;
+  final double thickness;
+  final double minRatio;
+  final double maxRatio;
+  final double minPanelSize;
+  final double maxSize;
+  final Color? dividerColor;
+  final Color? dividerHoverColor;
+  final Color? dividerActiveColor;
+  final ValueChanged<double>? onRatioChanged;
+  final bool enableKeyboard;
+  final FocusNode focusNode;
+  final String? semanticsLabel;
+
+  @override
+  State<_DividerHandle> createState() => _DividerHandleState();
+}
+
+class _DividerHandleState extends State<_DividerHandle> {
+  bool _isDragging = false;
+  double? _dragStartPosition;
+  double? _dragStartRatio;
+
+  // Cached decorations
+  late BoxDecoration _idleDecoration;
+  late BoxDecoration _activeDecoration;
+
+  @override
+  void initState() {
+    super.initState();
+    // Decorations will be initialized in didChangeDependencies
+  }
+
+  @override
+  void didChangeDependencies() {
+    super.didChangeDependencies();
+
+    // Safe to access Theme here
+    final theme = Theme.of(context);
+    final isDark = theme.brightness == Brightness.dark;
+
+    final baseColor =
+        widget.dividerColor ?? (isDark ? Colors.grey[800]! : Colors.grey[300]!);
+    final activeColor = widget.dividerActiveColor ?? theme.primaryColor;
+
+    _idleDecoration = BoxDecoration(color: baseColor);
+    _activeDecoration = BoxDecoration(
+      color: activeColor,
+      boxShadow: [
+        BoxShadow(
+          color: Colors.black.addOpacity(0.1),
+          blurRadius: 2,
+        ),
+      ],
+    );
   }
 
-  void _handleDragEnd(DragEndDetails details) {
-    setState(() {
-      _isDragging = false;
+  void _startDrag(Offset globalPosition) {
+    setState(() => _isDragging = true);
+    _dragStartRatio = widget.controller.value;
+    _dragStartPosition = widget.axis.pos(globalPosition);
+
+    // Register as currently dragging for throttling
+    SplitterController._globalRouter.setDragging(widget.controller);
+
+    widget.controller._setDragCallback(() {
+      if (mounted) setState(() => _isDragging = false);
     });
+
+    HapticFeedback.selectionClick();
+    widget.focusNode.requestFocus();
+  }
+
+  void _updateDrag(Offset globalPosition) {
+    if (_dragStartPosition == null || _dragStartRatio == null) return;
+
+    final currentPos = widget.axis.pos(globalPosition);
+    final delta = currentPos - _dragStartPosition!;
+    // Use the available size (excluding divider) for ratio calculation
+    final deltaRatio = delta / widget.maxSize;
+
+    var newRatio = _dragStartRatio! + deltaRatio;
+
+    // Apply constraints with proper min panel size calculation
+    final minSizeRatio = widget.minPanelSize / widget.maxSize;
+    final maxSizeRatio = 1.0 - minSizeRatio;
+
+    newRatio = newRatio.clamp(
+      widget.minRatio.clamp(minSizeRatio, maxSizeRatio),
+      widget.maxRatio.clamp(minSizeRatio, maxSizeRatio),
+    );
+
+    widget.controller.updateRatio(newRatio);
+    widget.onRatioChanged?.call(widget.controller.value);
   }
 
   @override
   Widget build(BuildContext context) {
-    return LayoutBuilder(
-      builder: (context, constraints) {
-        final startWidth =
-            constraints.maxWidth * _ratio - widget.dividerThickness / 2;
-        final endWidth =
-            constraints.maxWidth * (1 - _ratio) - widget.dividerThickness / 2;
-
-        return Row(
-          children: [
-            // Start panel
-            SizedBox(
-              width: startWidth,
-              child: widget.startPanel,
-            ),
-
-            // Draggable divider
-            MouseRegion(
-              cursor: SystemMouseCursors.resizeColumn,
-              child: GestureDetector(
-                onHorizontalDragStart: _handleDragStart,
-                onHorizontalDragUpdate: _handleDragUpdate,
-                onHorizontalDragEnd: _handleDragEnd,
-                child: Container(
-                  width: widget.dividerThickness,
-                  color: Colors.transparent,
-                  child: Center(
-                    child: Container(
-                      width: _isDragging ? 3 : 1,
-                      decoration: BoxDecoration(
-                        color: _isDragging
-                            ? context.primary
-                            : context.onSurface.addOpacity(0.2),
-                        borderRadius: BorderRadius.circular(2),
-                      ),
+    final theme = Theme.of(context);
+    final hoverColor =
+        widget.dividerHoverColor ?? theme.primaryColor.addOpacity(0.6);
+
+    Widget divider = MouseRegion(
+      cursor: widget.axis.cursor,
+      child: GestureDetector(
+        behavior: HitTestBehavior.opaque,
+        // Use onPan for better scroll compatibility
+        onPanStart: (details) => _startDrag(details.globalPosition),
+        onPanUpdate: (details) => _updateDrag(details.globalPosition),
+        child: TweenAnimationBuilder<Color?>(
+          duration: const Duration(milliseconds: 120),
+          tween: ColorTween(
+            begin: _idleDecoration.color,
+            end: _isDragging ? _activeDecoration.color : hoverColor,
+          ),
+          builder: (context, color, _) {
+            return Container(
+              width: widget.axis.isH ? widget.thickness : null,
+              height: !widget.axis.isH ? widget.thickness : null,
+              decoration: _isDragging
+                  ? _activeDecoration
+                  : BoxDecoration(
+                      color: color,
                     ),
-                  ),
-                ),
-              ),
-            ),
-
-            // End panel
-            SizedBox(
-              width: endWidth,
-              child: widget.endPanel,
-            ),
-          ],
-        );
-      },
+              child: _isDragging || color != _idleDecoration.color
+                  ? Center(
+                      child: Container(
+                        width: widget.axis.isH ? 2 : 24,
+                        height: !widget.axis.isH ? 2 : 24,
+                        decoration: BoxDecoration(
+                          color: theme.brightness == Brightness.dark
+                              ? Colors.white.addOpacity(0.3)
+                              : Colors.black.addOpacity(0.3),
+                          borderRadius: BorderRadius.circular(1),
+                        ),
+                      ),
+                    )
+                  : null,
+            );
+          },
+        ),
+      ),
     );
+
+    // Wrap with semantics (without focused parameter)
+    divider = Semantics(
+      label:
+          widget.semanticsLabel ??
+          'Drag to resize panels. Use arrow keys to adjust.',
+      child: divider,
+    );
+
+    if (widget.enableKeyboard) {
+      divider = FocusableActionDetector(
+        focusNode: widget.focusNode,
+        shortcuts: {
+          LogicalKeySet(
+            widget.axis.isH
+                ? LogicalKeyboardKey.arrowLeft
+                : LogicalKeyboardKey.arrowUp,
+          ): const _AdjustIntent(
+            -0.01,
+          ),
+          LogicalKeySet(
+            widget.axis.isH
+                ? LogicalKeyboardKey.arrowRight
+                : LogicalKeyboardKey.arrowDown,
+          ): const _AdjustIntent(
+            0.01,
+          ),
+        },
+        actions: {
+          _AdjustIntent: CallbackAction<_AdjustIntent>(
+            onInvoke: (intent) {
+              final newRatio = (widget.controller.value + intent.delta).clamp(
+                widget.minRatio,
+                widget.maxRatio,
+              );
+              widget.controller.value = newRatio;
+              widget.onRatioChanged?.call(newRatio);
+              HapticFeedback.selectionClick();
+              return null;
+            },
+          ),
+        },
+        child: divider,
+      );
+    }
+
+    return divider;
   }
 }
+
+class _AdjustIntent extends Intent {
+  const _AdjustIntent(this.delta);
+
+  final double delta;
+}
diff --git a/lib/src/shared/widgets/shared_drop_zone.dart b/lib/src/shared/widgets/shared_drop_zone.dart
new file mode 100644
index 0000000..ced33ca
--- /dev/null
+++ b/lib/src/shared/widgets/shared_drop_zone.dart
@@ -0,0 +1,50 @@
+// lib/src/features/scan/presentation/ui/shared_drop_zone.dart
+import 'package:context_collector/context_collector.dart';
+import 'package:desktop_drop/desktop_drop.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_helper_utils/flutter_helper_utils.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+
+/// A reusable widget that provides a drop zone for files and directories,
+/// with visual feedback during a drag operation.
+class DropZone extends ConsumerStatefulWidget {
+  const DropZone({required this.child, super.key});
+
+  final Widget child;
+
+  @override
+  ConsumerState<DropZone> createState() => _SharedDropZoneState();
+}
+
+class _SharedDropZoneState extends ConsumerState<DropZone> {
+  bool _isDragging = false;
+
+  @override
+  Widget build(BuildContext context) {
+    final selectionNotifier = ref.read(selectionProvider.notifier);
+
+    return DropTarget(
+      onDragEntered: (details) => setState(() => _isDragging = true),
+      onDragExited: (details) => setState(() => _isDragging = false),
+      onDragDone: (details) async {
+        setState(() => _isDragging = false);
+        if (details.files.isEmpty) return;
+        await selectionNotifier.processDroppedItems(details.files);
+      },
+      child: AnimatedContainer(
+        duration: const Duration(milliseconds: 200),
+        decoration: BoxDecoration(
+          color: _isDragging ? context.primary.addOpacity(0.05) : null,
+          border: _isDragging
+              ? Border.all(
+                  color: context.primary.addOpacity(0.3),
+                  width: 2,
+                )
+              : null,
+          borderRadius: _isDragging ? BorderRadius.circular(4) : null,
+        ),
+        child: widget.child,
+      ),
+    );
+  }
+}
