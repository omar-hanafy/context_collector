<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'none'; style-src 'self' 'unsafe-inline'; font-src 'self'; script-src 'self';"
    />
    <style>
      html, body, #editor-container {
        width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="editor-container"></div>

    <script>
      var require = { paths: { vs: '__VS_PATH__' } };
      console.log('[Monaco HTML] Require config set. VS_PATH is: ' + '__VS_PATH__');
    </script>

    <script src="__VS_PATH__/loader.js"
            onload="console.log('[Monaco HTML] loader.js successfully loaded.')"
            onerror="console.error('[Monaco HTML] FATAL: loader.js FAILED TO LOAD.')"
    ></script>

    <script>
      console.log('[Monaco HTML] Attempting to require editor.main...');
      try {
        // This is the standard Monaco loader pattern, now with an error callback.
        require(
          ['vs/editor/editor.main'],
          function () { // SUCCESS CALLBACK
            console.log('[Monaco] SUCCESS: editor.main.js has loaded. Initializing editor...');

            function postMessageToFlutter(message) {
              if (typeof message !== 'string') {
                message = JSON.stringify(message);
              }
              if (window.flutterChannel && window.flutterChannel.postMessage) {
                window.flutterChannel.postMessage(message);
              } else {
                console.error('[Monaco] Flutter communication channel is not available.');
              }
            }

            monaco.editor.onDidCreateEditor(function (editor) {
              window.editor = editor;
              window.setEditorContent = (content) => editor.setValue(content || '');
              window.setEditorLanguage = (language) => monaco.editor.setModelLanguage(editor.getModel(), language);
              window.setEditorTheme = (theme) => monaco.editor.setTheme(theme);
              window.setEditorOptions = (options) => editor.updateOptions(options);

              const sendStats = () => {
                if (!editor.getModel() || !editor.getSelection()) return;
                const model = editor.getModel(), selection = editor.getSelection(), selections = editor.getSelections() || [];
                postMessageToFlutter({
                  event: 'stats',
                  lineCount: model.getLineCount(),
                  charCount: model.getValueLength(),
                  selLines: selection.endLineNumber - selection.startLineNumber + 1,
                  selChars: model.getValueInRange(selection).length,
                  caretCount: selections.length,
                });
              };
              editor.onDidChangeModelContent(sendStats);
              editor.onDidChangeCursorSelection(sendStats);
              sendStats();

              postMessageToFlutter({ event: 'onEditorReady' });
              console.log('[Monaco] Editor is ready and has sent the onEditorReady event.');
            });

            monaco.editor.create(document.getElementById('editor-container'), {
              value: '// Context Collector is ready.',
              language: 'markdown',
              theme: 'vs-dark',
              automaticLayout: true,
              wordWrap: 'on',
              padding: { top: 10 },
              minimap: { enabled: false }
            });
          },
          function (error) { // ERROR CALLBACK
            console.error('[Monaco] FATAL: require() failed to load editor.main.js. Error:', error);
          }
        );
      } catch (e) {
        console.error('[Monaco] FATAL: A critical error occurred trying to call require(). Error:', e);
      }
    </script>
  </body>
</html>
