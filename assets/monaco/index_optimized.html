<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' file: asset: data: https://cdnjs.cloudflare.com;">
    <title>Monaco Editor</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1e1e1e;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: light) {
            html, body { background: #ffffff; }
        }
        
        #container {
            width: 100%;
            height: 100%;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
        }
        
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
            text-align: center;
            max-width: 80%;
        }
    </style>
    <script>
        // Configuration injected by Flutter
        const MONACO_CONFIG = __MONACO_CONFIG__;
        
        // VS Path - will be replaced by Flutter
        const VS_PATH = "__VS_PATH__";
        
        // Setup require.js
        var require = { paths: { 'vs': VS_PATH } };
    </script>
</head>
<body>
    <div id="container">
        <div class="loading">Loading Monaco Editor...</div>
    </div>
    
    <script>
        // Monaco Editor wrapper with original API
window.monacoEditor = {
        editor: null,
        
        setContent: function(content) {
        if (this.editor) {
            this.editor.setValue(content);
                window.detectLanguage();
            }
        },
        
        getContent: function() {
            return this.editor ? this.editor.getValue() : '';
        },
        
        setLanguage: function(language) {
        if (this.editor) {
            monaco.editor.setModelLanguage(this.editor.getModel(), language);
        }
        },
        
        setTheme: function(theme) {
        if (this.editor) {
        monaco.editor.setTheme(theme);
        }
        },
        
        updateOptions: function(options) {
        if (this.editor) {
            this.editor.updateOptions(options);
        }
        },
        
        format: function() {
        if (this.editor) {
        this.editor.getAction('editor.action.formatDocument').run();
        }
        },
        
        find: function() {
            if (this.editor) {
                this.editor.getAction('actions.find').run();
            }
        },
        
        goToLine: function(line) {
        if (this.editor) {
            this.editor.revealLineInCenter(line);
        this.editor.setPosition({ lineNumber: line, column: 1 });
        }
        },
        
        scrollToTop: function() {
        if (this.editor) {
        this.editor.setScrollPosition({ scrollTop: 0, scrollLeft: 0 });
        }
        },
        
        saveState: function() {
        if (!this.editor) return null;
        
        const position = this.editor.getPosition();
        const selection = this.editor.getSelection();
        
        return {
        position: position ? { 
            lineNumber: position.lineNumber, 
            column: position.column 
            } : null,
            selection: selection ? {
                startLineNumber: selection.startLineNumber,
                startColumn: selection.startColumn,
                endLineNumber: selection.endLineNumber,
                endColumn: selection.endColumn
            } : null,
            scrollTop: this.editor.getScrollTop(),
            scrollLeft: this.editor.getScrollLeft()
        };
        },
        
        restoreState: function(state) {
        if (!this.editor || !state) return;
        
        if (state.position) {
            this.editor.setPosition(state.position);
            }
        
        if (state.selection) {
            this.editor.setSelection(state.selection);
        }
        
        if (state.scrollTop !== undefined) {
            this.editor.setScrollPosition({
                scrollTop: state.scrollTop,
                scrollLeft: state.scrollLeft || 0
            });
        }
    }
};

// Compatibility aliases
window.setEditorContent = function(content) {
    window.monacoEditor.setContent(content);
};

window.setEditorLanguage = function(lang) {
    window.monacoEditor.setLanguage(lang);
};

window.getEditorContent = function() {
    return window.monacoEditor.getContent();
};

window.setEditorTheme = function(theme) {
    window.monacoEditor.setTheme(theme);
};

window.setEditorOptions = function(options) {
    window.monacoEditor.updateOptions(options);
};

// Initialize Monaco when ready
function initEditor() {
    require(['vs/editor/editor.main'], function() {
        // Create editor
        window.monacoEditor.editor = monaco.editor.create(document.getElementById('container'), {
            value: '',
            language: 'plaintext',
            theme: 'vs-dark',
            fontSize: 13,
            wordWrap: 'off',
            lineNumbers: 'on',
            readOnly: true,
            automaticLayout: true,
            minimap: { enabled: false },
            scrollBeyondLastLine: false,
            padding: { top: 10 },
            fontFamily: 'JetBrains Mono, SF Mono, Menlo, Consolas, monospace',
            renderWhitespace: 'selection',
            lightbulb: { enabled: false },
            parameterHints: { enabled: false },
            suggestOnTriggerCharacters: false,
            acceptSuggestionOnCommitCharacter: false,
            snippetSuggestions: 'none',
            wordBasedSuggestions: false,
        });
        
        // Alias for compatibility
        window.editor = window.monacoEditor.editor;
        
        // Setup keyboard shortcuts
        window.monacoEditor.editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_F, () => {
            window.monacoEditor.find();
        });
        
        // Notify Flutter  
        if (window.flutterChannel) {
            window.flutterChannel.postMessage(JSON.stringify({event: 'onEditorReady'}));
        }
        
        console.log("Monaco editor instance created successfully");
    });
}
            
            setupKeyboardShortcuts() {
                // Override browser find with Monaco find
                this.editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_F, () => {
                    this.editor.getAction('actions.find').run();
                });
                
                // Format document
                this.editor.addCommand(monaco.KeyMod.Alt | monaco.KeyMod.Shift | monaco.KeyCode.KEY_F, () => {
                    this.editor.getAction('editor.action.formatDocument').run();
                });
            }
            
            setupLanguageDetection() {
                // Language patterns for detection
                this.languageDetector = {
                    patterns: [
                        { lang: 'dart', regex: /import\s+['"]package:flutter|class\s+\w+\s+extends\s+(StatefulWidget|StatelessWidget)|void\s+main\(\)/ },
                        { lang: 'html', regex: /<!DOCTYPE\s+html>|<html[\s>]|<body[\s>]|<head[\s>]/ },
                        { lang: 'css', regex: /@import|@media|^[.#]?\w+\s*{[\s\S]*}/ },
                        { lang: 'javascript', regex: /import\s+.*\s+from\s+['"]|function\s+\w+\s*\(|const\s+\w+\s*=|=>\s*{/ },
                        { lang: 'typescript', regex: /interface\s+\w+|type\s+\w+\s*=|export\s+(class|interface|type)|:\s*(string|number|boolean)/ },
                        { lang: 'python', regex: /def\s+\w+\s*\(.*\):|import\s+\w+|from\s+\w+\s+import|if\s+__name__\s*==\s*['"]__main__['"]/ },
                        { lang: 'json', regex: /^\s*{[\s\S]*}\s*$|^\s*\[[\s\S]*\]\s*$/ },
                        { lang: 'yaml', regex: /^---\s*$|^\w+:\s*$/m },
                        { lang: 'markdown', regex: /^#{1,6}\s+|^\*{3,}$|^-{3,}$|^\[\w+\]:\s+http/ },
                        { lang: 'xml', regex: /<\?xml|<\w+[\s>].*<\/\w+>|xmlns/ },
                        { lang: 'sql', regex: /SELECT\s+.*\s+FROM|CREATE\s+TABLE|INSERT\s+INTO|UPDATE\s+\w+\s+SET/ },
                        { lang: 'shell', regex: /^#!/|^\$\s+|echo\s+|export\s+\w+=/ },
                    ]
                };
            }
            
            async detectAndSetLanguage(content) {
                if (!content || content.trim() === '') return;
                
                // Try to detect language
                for (const pattern of this.languageDetector.patterns) {
                    if (pattern.regex.test(content)) {
                        await this.setLanguage(pattern.lang);
                        return;
                    }
                }
            }
            
            async setContent(content) {
                if (this.editor) {
                    this.editor.setValue(content);
                    // Auto-detect language
                    await this.detectAndSetLanguage(content);
                }
            }
            
            getContent() {
                return this.editor ? this.editor.getValue() : '';
            }
            
            async setLanguage(language) {
                if (!this.editor || this.language === language) return;
                
                this.language = language;
                
                // Lazy load language if not already loaded
                if (!this.loadedLanguages.has(language)) {
                    await this.loadLanguage(language);
                }
                
                monaco.editor.setModelLanguage(this.editor.getModel(), language);
            }
            
            async loadLanguage(language) {
                const languageModules = {
                    'dart': ['vs/basic-languages/dart/dart.contribution'],
                    'typescript': [
                        'vs/basic-languages/typescript/typescript.contribution',
                        'vs/language/typescript/tsMode'
                    ],
                    'javascript': [
                        'vs/basic-languages/javascript/javascript.contribution'
                    ],
                    'html': [
                        'vs/basic-languages/html/html.contribution',
                        'vs/language/html/htmlMode'
                    ],
                    'css': [
                        'vs/basic-languages/css/css.contribution',
                        'vs/language/css/cssMode'
                    ],
                    'json': [
                        'vs/basic-languages/json/json.contribution',
                        'vs/language/json/jsonMode'
                    ],
                    'python': ['vs/basic-languages/python/python.contribution'],
                    'yaml': ['vs/basic-languages/yaml/yaml.contribution'],
                    'markdown': ['vs/basic-languages/markdown/markdown.contribution'],
                    'xml': ['vs/basic-languages/xml/xml.contribution'],
                    'sql': ['vs/basic-languages/sql/sql.contribution'],
                    'shell': ['vs/basic-languages/shell/shell.contribution'],
                };
                
                const modules = languageModules[language];
                if (modules) {
                    try {
                        await new Promise((resolve, reject) => {
                            require(modules, resolve, reject);
                        });
                        this.loadedLanguages.add(language);
                    } catch (e) {
                        console.warn(`Failed to load language modules for ${language}:`, e);
                    }
                }
            }
            
            setTheme(theme) {
                if (this.editor) {
                    monaco.editor.setTheme(theme);
                }
            }
            
            updateOptions(options) {
                if (this.editor) {
                    this.editor.updateOptions(options);
                }
            }
            
            format() {
                if (this.editor) {
                    this.editor.getAction('editor.action.formatDocument').run();
                }
            }
            
            find() {
                if (this.editor) {
                    this.editor.getAction('actions.find').run();
                }
            }
            
            goToLine(line) {
                if (this.editor) {
                    this.editor.revealLineInCenter(line);
                    this.editor.setPosition({ lineNumber: line, column: 1 });
                }
            }
            
            scrollToTop() {
                if (this.editor) {
                    this.editor.setScrollPosition({ scrollTop: 0, scrollLeft: 0 });
                }
            }
            
            saveState() {
                if (!this.editor) return null;
                
                const position = this.editor.getPosition();
                const selection = this.editor.getSelection();
                
                return {
                    position: position ? { 
                        lineNumber: position.lineNumber, 
                        column: position.column 
                    } : null,
                    selection: selection ? {
                        startLineNumber: selection.startLineNumber,
                        startColumn: selection.startColumn,
                        endLineNumber: selection.endLineNumber,
                        endColumn: selection.endColumn
                    } : null,
                    scrollTop: this.editor.getScrollTop(),
                    scrollLeft: this.editor.getScrollLeft()
                };
            }
            
            restoreState(state) {
                if (!this.editor || !state) return;
                
                if (state.position) {
                    this.editor.setPosition(state.position);
                }
                
                if (state.selection) {
                    this.editor.setSelection(state.selection);
                }
                
                if (state.scrollTop !== undefined) {
                    this.editor.setScrollPosition({
                        scrollTop: state.scrollTop,
                        scrollLeft: state.scrollLeft || 0
                    });
                }
            }
            
            sendMessage(event, data) {
                if (window.monacoFlutter) {
                    window.monacoFlutter.postMessage(JSON.stringify({ event, data }));
                }
            }
        }
        
        // Initialize editor
        window.monacoEditor = new MonacoEditor();
        window.monacoEditor.init();
    </script>
</body>
</html>
