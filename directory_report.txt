# Directory Analysis Report

Generated: 2025-05-24 02:38:00
Source: /Users/omarhanafy/scripts/context_collector/lib
Processing time: 0.01 seconds

## Directory Structure

```
└── lib
    ├── config
    │   └── file_extensions.dart
    ├── extensions
    │   └── theme_extensions.dart
    ├── models
    │   ├── extension_settings.dart
    │   └── file_item.dart
    ├── providers
    │   ├── file_collector_provider.dart
    │   └── settings_provider.dart
    ├── screens
    │   ├── home_screen.dart
    │   └── settings_screen.dart
    ├── theme
    │   └── app_theme.dart
    ├── widgets
    │   ├── action_buttons_widget.dart
    │   ├── combined_content_widget.dart
    │   ├── drop_zone_widget.dart
    │   ├── editor_settings_dialog.dart
    │   ├── enhanced_text_editor.dart
    │   ├── file_list_widget.dart
    │   ├── monaco_editor_embedded.dart
    │   └── monaco_editor_widget.dart
    └── main.dart
```

## File Contents

### config/file_extensions.dart
- Language: dart
```dart
import 'package:flutter/material.dart';

class FileExtensionConfig {
  static const Map<String, FileCategory> extensionCategories = {
    // Programming Languages
    '.dart': FileCategory.programming,
    '.py': FileCategory.programming,
    '.js': FileCategory.programming,
    '.ts': FileCategory.programming,
    '.jsx': FileCategory.programming,
    '.tsx': FileCategory.programming,
    '.java': FileCategory.programming,
    '.kt': FileCategory.programming,
    '.swift': FileCategory.programming,
    '.cpp': FileCategory.programming,
    '.c': FileCategory.programming,
    '.h': FileCategory.programming,
    '.hpp': FileCategory.programming,
    '.cs': FileCategory.programming,
    '.php': FileCategory.programming,
    '.rb': FileCategory.programming,
    '.go': FileCategory.programming,
    '.rs': FileCategory.programming,
    '.scala': FileCategory.programming,
    '.r': FileCategory.programming,
    '.m': FileCategory.programming,
    '.mm': FileCategory.programming,
    '.lua': FileCategory.programming,
    '.pl': FileCategory.programming,
    '.ex': FileCategory.programming,
    '.exs': FileCategory.programming,
    '.elm': FileCategory.programming,
    '.clj': FileCategory.programming,
    '.coffee': FileCategory.programming,
    '.vb': FileCategory.programming,
    '.fs': FileCategory.programming,
    '.hs': FileCategory.programming,
    '.nim': FileCategory.programming,
    '.cr': FileCategory.programming,
    '.jl': FileCategory.programming,
    '.pas': FileCategory.programming,
    '.d': FileCategory.programming,
    '.zig': FileCategory.programming,
    '.v': FileCategory.programming,
    '.sol': FileCategory.programming,

    // Web Technologies
    '.html': FileCategory.web,
    '.htm': FileCategory.web,
    '.css': FileCategory.web,
    '.scss': FileCategory.web,
    '.sass': FileCategory.web,
    '.less': FileCategory.web,
    '.vue': FileCategory.web,
    '.svelte': FileCategory.web,
    '.astro': FileCategory.web,

    // Data & Config
    '.json': FileCategory.data,
    '.xml': FileCategory.data,
    '.yaml': FileCategory.data,
    '.yml': FileCategory.data,
    '.toml': FileCategory.data,
    '.ini': FileCategory.data,
    '.conf': FileCategory.data,
    '.cfg': FileCategory.data,
    '.properties': FileCategory.data,
    '.env': FileCategory.data,
    '.csv': FileCategory.data,
    '.tsv': FileCategory.data,
    '.plist': FileCategory.data,

    // Scripts
    '.sh': FileCategory.script,
    '.bash': FileCategory.script,
    '.zsh': FileCategory.script,
    '.fish': FileCategory.script,
    '.ps1': FileCategory.script,
    '.psm1': FileCategory.script,
    '.psd1': FileCategory.script,
    '.bat': FileCategory.script,
    '.cmd': FileCategory.script,
    '.vbs': FileCategory.script,
    '.ahk': FileCategory.script,

    // Documentation
    '.md': FileCategory.documentation,
    '.markdown': FileCategory.documentation,
    '.rst': FileCategory.documentation,
    '.adoc': FileCategory.documentation,
    '.asciidoc': FileCategory.documentation,
    '.tex': FileCategory.documentation,
    '.latex': FileCategory.documentation,
    '.txt': FileCategory.documentation,
    '.rtf': FileCategory.documentation,
    '.org': FileCategory.documentation,

    // Database
    '.sql': FileCategory.database,
    '.psql': FileCategory.database,
    '.mysql': FileCategory.database,
    '.sqlite': FileCategory.database,
    '.mongodb': FileCategory.database,
    '.cql': FileCategory.database,

    // DevOps & Build
    '.dockerfile': FileCategory.devops,
    '.containerfile': FileCategory.devops,
    '.makefile': FileCategory.devops,
    '.mk': FileCategory.devops,
    '.gradle': FileCategory.devops,
    '.groovy': FileCategory.devops,
    '.jenkinsfile': FileCategory.devops,
    '.travis.yml': FileCategory.devops,
    '.gitlab-ci.yml': FileCategory.devops,
    '.github': FileCategory.devops,
    '.circleci': FileCategory.devops,
    '.drone.yml': FileCategory.devops,

    // Other
    '.gitignore': FileCategory.other,
    '.gitattributes': FileCategory.other,
    '.editorconfig': FileCategory.other,
    '.prettierrc': FileCategory.other,
    '.eslintrc': FileCategory.other,
    '.stylelintrc': FileCategory.other,
    '.npmrc': FileCategory.other,
    '.nvmrc': FileCategory.other,
    '.rvmrc': FileCategory.other,
    '.ruby-version': FileCategory.other,
    '.python-version': FileCategory.other,
    '.node-version': FileCategory.other,
    '.tool-versions': FileCategory.other,
    '.babelrc': FileCategory.other,
    '.browserslistrc': FileCategory.other,
    '.huskyrc': FileCategory.other,
    '.lintstagedrc': FileCategory.other,
    '.commitlintrc': FileCategory.other,
    '.renovaterc': FileCategory.other,
    '.dependabot': FileCategory.other,
    '.log': FileCategory.other,
    '.lock': FileCategory.other,
    '.pid': FileCategory.other,
    '.cache': FileCategory.other,
    '.tmp': FileCategory.other,
    '.temp': FileCategory.other,
    '.bak': FileCategory.other,
    '.backup': FileCategory.other,
    '.old': FileCategory.other,
    '.orig': FileCategory.other,
    '.rej': FileCategory.other,
    '.diff': FileCategory.other,
    '.patch': FileCategory.other,
    '.pub': FileCategory.other,
    '.pem': FileCategory.other,
    '.key': FileCategory.other,
    '.crt': FileCategory.other,
    '.cer': FileCategory.other,
    '.p12': FileCategory.other,
    '.pfx': FileCategory.other,
    '.jks': FileCategory.other,
  };

  static Set<String> get supportedExtensions =>
      extensionCategories.keys.toSet();

  static bool isTextFile(String extension) {
    return extensionCategories.containsKey(extension.toLowerCase());
  }

  static FileCategory? getCategory(String extension) {
    return extensionCategories[extension.toLowerCase()];
  }
  
  // These will be used as fallbacks when settings provider is not available
  static bool isTextFileWithSettings(String extension, Map<String, FileCategory>? activeExtensions) {
    final ext = extension.toLowerCase();
    if (activeExtensions != null) {
      return activeExtensions.containsKey(ext);
    }
    return isTextFile(ext);
  }
  
  static FileCategory? getCategoryWithSettings(String extension, Map<String, FileCategory>? activeExtensions) {
    final ext = extension.toLowerCase();
    if (activeExtensions != null) {
      return activeExtensions[ext];
    }
    return getCategory(ext);
  }

  static List<String> getExtensionsByCategory(FileCategory category) {
    return extensionCategories.entries
        .where((entry) => entry.value == category)
        .map((entry) => entry.key)
        .toList()
      ..sort();
  }

  static Map<FileCategory, List<String>> getGroupedExtensions() {
    final Map<FileCategory, List<String>> grouped = {};

    for (final category in FileCategory.values) {
      final extensions = getExtensionsByCategory(category);
      if (extensions.isNotEmpty) {
        grouped[category] = extensions;
      }
    }

    return grouped;
  }
}

enum FileCategory {
  programming('Programming Languages', Icons.code),
  web('Web Technologies', Icons.web),
  data('Data & Config', Icons.data_object),
  script('Scripts', Icons.terminal),
  documentation('Documentation', Icons.description),
  database('Database', Icons.storage),
  devops('DevOps & Build', Icons.build_circle),
  other('Other', Icons.insert_drive_file);

  const FileCategory(this.displayName, this.icon);

  final String displayName;
  final IconData icon;
}
```

### extensions/theme_extensions.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';

export 'package:flutter_helper_utils/flutter_helper_utils.dart';

/// Extension on BuildContext to provide convenient theme color access
extension ThemeColorsExtension on BuildContext {
  // ColorScheme colors
  Color get primary => themeData.primary;

  Color get onPrimary => themeData.onPrimary;

  Color get primaryContainer => themeData.primaryContainer;

  Color get onPrimaryContainer => themeData.onPrimaryContainer;

  Color get secondary => themeData.secondary;

  Color get onSecondary => themeData.onSecondary;

  Color get secondaryContainer => themeData.secondaryContainer;

  Color get onSecondaryContainer => themeData.onSecondaryContainer;

  Color get tertiary => themeData.tertiary;

  Color get onTertiary => themeData.onTertiary;

  Color get tertiaryContainer => themeData.tertiaryContainer;

  Color get onTertiaryContainer => themeData.onTertiaryContainer;

  Color get error => themeData.error;

  Color get onError => themeData.onError;

  Color get errorContainer => themeData.errorContainer;

  Color get onErrorContainer => themeData.onErrorContainer;

  Color get background => themeData.surface;

  Color get onBackground => themeData.onSurface;

  Color get surface => themeData.surface;

  Color get surfaceContainerHighest => themeData.surfaceContainerHighest;

  Color get onSurface => themeData.onSurface;

  Color get onSurfaceVariant => themeData.onSurfaceVariant;

  Color get outline => themeData.outline;

  Color get outlineVariant => themeData.outlineVariant;

  Color get shadow => themeData.shadow;

  Color get scrim => themeData.scrim;

  Color get inverseSurface => themeData.inverseSurface;

  Color get onInverseSurface => themeData.onInverseSurface;

  Color get inversePrimary => themeData.inversePrimary;

  Color get surfaceTint => themeData.surfaceTint;

  TextTheme get textTheme => themeData.textTheme;
}

/// Extension on BuildContext to provide convenient text style access
extension TextStylesExtension on BuildContext {
  // Display styles
  TextStyle? get displayLarge => textTheme.displayLarge;

  TextStyle? get displayMedium => textTheme.displayMedium;

  TextStyle? get displaySmall => textTheme.displaySmall;

  // Headline styles
  TextStyle? get headlineLarge => textTheme.headlineLarge;

  TextStyle? get headlineMedium => textTheme.headlineMedium;

  TextStyle? get headlineSmall => textTheme.headlineSmall;

  // Title styles
  TextStyle? get titleLarge => textTheme.titleLarge;

  TextStyle? get titleMedium => textTheme.titleMedium;

  TextStyle? get titleSmall => textTheme.titleSmall;

  // Label styles
  TextStyle? get labelLarge => textTheme.labelLarge;

  TextStyle? get labelMedium => textTheme.labelMedium;

  TextStyle? get labelSmall => textTheme.labelSmall;

  // Body styles
  TextStyle? get bodyLarge => textTheme.bodyLarge;

  TextStyle? get bodyMedium => textTheme.bodyMedium;

  TextStyle? get bodySmall => textTheme.bodySmall;

  // Copy methods for convenience (mirrors the fhu pattern)
  TextStyle? displayLargeCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      displayLarge?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );

  TextStyle? titleMediumCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      titleMedium?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );

  TextStyle? bodyMediumCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      bodyMedium?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );

  TextStyle? labelSmallCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      labelSmall?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );
}
```

### main.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:window_manager/window_manager.dart';

import 'providers/file_collector_provider.dart';
import 'providers/settings_provider.dart';
import 'screens/home_screen.dart';
import 'theme/app_theme.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Configure window for desktop
  await windowManager.ensureInitialized();

  const WindowOptions windowOptions = WindowOptions(
    size: Size(1000, 700),
    minimumSize: Size(600, 400),
    center: true,
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.normal,
    title: 'Context Collector',
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    await windowManager.show();
    await windowManager.focus();
  });

  runApp(const ContextCollectorApp());
}

class ContextCollectorApp extends StatelessWidget {
  const ContextCollectorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => SettingsProvider()),
        ChangeNotifierProvider(create: (context) => FileCollectorProvider()),
      ],
      child: MaterialApp(
        title: 'Context Collector',
        theme: AppTheme.lightTheme,
        darkTheme: AppTheme.darkTheme,
        themeMode: ThemeMode.system,
        home: const HomeScreen(),
        debugShowCheckedModeBanner: false,
      ),
    );
  }
}
```

### models/extension_settings.dart
- Language: dart
```dart
import 'dart:convert';

import 'package:dart_helper_utils/dart_helper_utils.dart';
import 'package:flutter/cupertino.dart';

import '../config/file_extensions.dart';

@immutable
class ExtensionSettings {
  const ExtensionSettings({
    this.customExtensions = const {},
    this.disabledExtensions = const {},
  });

  factory ExtensionSettings.fromJson(Map<String, dynamic> json) {
    return ExtensionSettings(
      customExtensions: _parseCustomExtensions(json),
      disabledExtensions: _parseDisabledExtensions(json),
    );
  }

  factory ExtensionSettings.fromJsonString(String jsonString) {
    try {
      final decoded = jsonString.tryDecode();
      if (decoded == null) return const ExtensionSettings();

      return ExtensionSettings.fromJson(toMap<String, dynamic>(decoded));
    } catch (e) {
      return const ExtensionSettings();
    }
  }

  final Map<String, FileCategory> customExtensions;
  final Set<String> disabledExtensions;

  // Helper method to parse custom extensions using dart_helper_utils
  static Map<String, FileCategory> _parseCustomExtensions(
    Map<String, dynamic> json,
  ) {
    final customMap = json.tryGetMap<String, dynamic>('customExtensions');
    if (customMap == null) return const {};

    final result = <String, FileCategory>{};

    for (final entry in customMap.entries) {
      final categoryName = entry.value.toString();
      final category =
          FileCategory.values.firstWhereOrNull((c) => c.name == categoryName) ??
              FileCategory.other;

      result[entry.key] = category;
    }

    return result;
  }

  // Helper method to parse disabled extensions using dart_helper_utils
  static Set<String> _parseDisabledExtensions(Map<String, dynamic> json) {
    final disabledList = json.tryGetList<String>('disabledExtensions');
    return disabledList?.toSet() ?? const <String>{};
  }

  Map<String, dynamic> toJson() {
    return {
      'customExtensions': customExtensions.map(
        (key, value) => MapEntry(key, value.name),
      ),
      'disabledExtensions': disabledExtensions.toList(),
    };
  }

  String toJsonString() => jsonEncode(toJson());

  ExtensionSettings copyWith({
    Map<String, FileCategory>? customExtensions,
    Set<String>? disabledExtensions,
  }) {
    return ExtensionSettings(
      customExtensions: customExtensions ?? this.customExtensions,
      disabledExtensions: disabledExtensions ?? this.disabledExtensions,
    );
  }

  // Get all active extensions (default + custom - disabled)
  Map<String, FileCategory> get activeExtensions {
    final result = Map<String, FileCategory>.from(
      FileExtensionConfig.extensionCategories,
    );

    // Remove disabled extensions
    for (final ext in disabledExtensions) {
      result.remove(ext);
    }

    // Add custom extensions (these override defaults)
    result.addAll(customExtensions);

    return result;
  }

  // Check if an extension is supported
  bool isSupported(String extension) {
    final ext = extension.toLowerCase();
    return activeExtensions.containsKey(ext);
  }

  // Get category for an extension
  FileCategory? getCategory(String extension) {
    final ext = extension.toLowerCase();
    return activeExtensions[ext];
  }

  // Additional utility methods

  /// Add a custom extension mapping
  ExtensionSettings addCustomExtension(
      String extension, FileCategory category) {
    final newCustom = Map<String, FileCategory>.from(customExtensions);
    newCustom[extension.toLowerCase()] = category;
    return copyWith(customExtensions: newCustom);
  }

  /// Remove a custom extension mapping
  ExtensionSettings removeCustomExtension(String extension) {
    final newCustom = Map<String, FileCategory>.from(customExtensions)
      ..remove(extension.toLowerCase());
    return copyWith(customExtensions: newCustom);
  }

  /// Disable an extension
  ExtensionSettings disableExtension(String extension) {
    final newDisabled = Set<String>.from(disabledExtensions)
      ..add(extension.toLowerCase());
    return copyWith(disabledExtensions: newDisabled);
  }

  /// Enable a previously disabled extension
  ExtensionSettings enableExtension(String extension) {
    final newDisabled = Set<String>.from(disabledExtensions)
      ..remove(extension.toLowerCase());
    return copyWith(disabledExtensions: newDisabled);
  }

  /// Get all extensions for a specific category
  Set<String> getExtensionsForCategory(FileCategory category) {
    return activeExtensions.entries
        .where((entry) => entry.value == category)
        .map((entry) => entry.key)
        .toSet();
  }

  /// Check if any extensions are configured for a category
  bool hasCategorySupport(FileCategory category) {
    return activeExtensions.values.contains(category);
  }

  /// Get statistics about the configuration
  Map<String, int> get statistics {
    final stats = <String, int>{};

    // Count by category
    for (final category in FileCategory.values) {
      final count =
          activeExtensions.values.where((cat) => cat == category).length;
      if (count > 0) {
        stats[category.name] = count;
      }
    }

    stats['total'] = activeExtensions.length;
    stats['custom'] = customExtensions.length;
    stats['disabled'] = disabledExtensions.length;

    return stats;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is ExtensionSettings &&
        other.customExtensions.length == customExtensions.length &&
        other.disabledExtensions.length == disabledExtensions.length &&
        other.customExtensions.entries.every(
          (entry) => customExtensions[entry.key] == entry.value,
        ) &&
        other.disabledExtensions.every(disabledExtensions.contains);
  }

  @override
  int get hashCode {
    return Object.hash(
      customExtensions.entries
          .map((e) => Object.hash(e.key, e.value))
          .fold(0, (a, b) => a is num ? a.toInt() ^ b : 0),
      disabledExtensions.fold(
          0, (a, b) => a is num ? a.toInt() ^ b.hashCode : 0),
    );
  }

  @override
  String toString() {
    return 'ExtensionSettings('
        'customExtensions: ${customExtensions.length}, '
        'disabledExtensions: ${disabledExtensions.length}, '
        'totalActive: ${activeExtensions.length}'
        ')';
  }
}
```

### models/file_item.dart
- Language: dart
```dart
import 'dart:io';

import 'package:flutter/cupertino.dart';
import 'package:path/path.dart' as path;

import '../config/file_extensions.dart';

@immutable
class FileItem {
  const FileItem({
    required this.name,
    required this.fullPath,
    required this.extension,
    required this.size,
    required this.lastModified,
    this.content,
    this.isSelected = true,
    this.isLoading = false,
    this.error,
  });

  factory FileItem.fromFile(File file) {
    final stat = file.statSync();
    return FileItem(
      name: path.basename(file.path),
      fullPath: file.path,
      extension: path.extension(file.path).toLowerCase(),
      size: stat.size,
      lastModified: stat.modified,
    );
  }

  final String name;
  final String fullPath;
  final String extension;
  final int size;
  final DateTime lastModified;
  final String? content;
  final bool isSelected;
  final bool isLoading;
  final String? error;

  String get sizeFormatted {
    if (size < 1024) return '${size}B';
    if (size < 1024 * 1024) return '${(size / 1024).toStringAsFixed(1)}KB';
    if (size < 1024 * 1024 * 1024) {
      return '${(size / (1024 * 1024)).toStringAsFixed(1)}MB';
    }
    return '${(size / (1024 * 1024 * 1024)).toStringAsFixed(1)}GB';
  }

  bool get isTextFile => FileExtensionConfig.isTextFile(extension);

  FileCategory? get category => FileExtensionConfig.getCategory(extension);
  
  bool isTextFileWithSettings(Map<String, FileCategory>? activeExtensions) {
    return FileExtensionConfig.isTextFileWithSettings(extension, activeExtensions);
  }
  
  FileCategory? getCategoryWithSettings(Map<String, FileCategory>? activeExtensions) {
    return FileExtensionConfig.getCategoryWithSettings(extension, activeExtensions);
  }

  Future<FileItem> loadContent({Map<String, FileCategory>? activeExtensions}) async {
    final isSupported = activeExtensions != null 
        ? isTextFileWithSettings(activeExtensions)
        : isTextFile;
        
    if (!isSupported) {
      return copyWith(
        error: 'File type not supported for text extraction',
        isLoading: false,
      );
    }

    try {
      final file = File(fullPath);
      if (!file.existsSync()) {
        return copyWith(
          error: 'File not found',
          isLoading: false,
        );
      }

      final fileContent = await file.readAsString();
      return copyWith(
        content: fileContent,
        isLoading: false,
        error: null,
      );
    } catch (e) {
      return copyWith(
        error: 'Error reading file: $e',
        content: null,
        isLoading: false,
      );
    }
  }

  String generateReference() {
    return '// File: $fullPath\n// Size: $sizeFormatted\n// Modified: ${lastModified.toIso8601String()}\n';
  }

  FileItem copyWith({
    String? name,
    String? fullPath,
    String? extension,
    int? size,
    DateTime? lastModified,
    String? content,
    bool? isSelected,
    bool? isLoading,
    String? error,
  }) {
    return FileItem(
      name: name ?? this.name,
      fullPath: fullPath ?? this.fullPath,
      extension: extension ?? this.extension,
      size: size ?? this.size,
      lastModified: lastModified ?? this.lastModified,
      content: content ?? this.content,
      isSelected: isSelected ?? this.isSelected,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is FileItem && other.fullPath == fullPath;
  }

  @override
  int get hashCode => fullPath.hashCode;
}
```

### providers/file_collector_provider.dart
- Language: dart
```dart
import 'dart:io';

import 'package:file_selector/file_selector.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../config/file_extensions.dart';
import '../models/file_item.dart';
import 'settings_provider.dart';

class FileCollectorProvider with ChangeNotifier {
  final List<FileItem> _files = [];
  bool _isProcessing = false;
  String? _error;
  String _combinedContent = '';
  SettingsProvider? _settingsProvider;

  List<FileItem> get files => List.unmodifiable(_files);
  bool get isProcessing => _isProcessing;
  String? get error => _error;
  String get combinedContent => _combinedContent;

  List<FileItem> get selectedFiles =>
      _files.where((f) => f.isSelected).toList();

  int get selectedFilesCount => selectedFiles.length;
  int get totalFilesCount => _files.length;

  bool get hasFiles => _files.isNotEmpty;
  bool get hasSelectedFiles => selectedFiles.isNotEmpty;

  set settingsProvider(SettingsProvider settingsProvider) {
    _settingsProvider = settingsProvider;
  }

  Map<String, FileCategory>? get _activeExtensions =>
      _settingsProvider?.activeExtensions;

  void addFiles(List<String> filePaths) {
    _error = null;
    bool newFilesAdded = false;

    for (final filePath in filePaths) {
      final file = File(filePath);
      if (file.existsSync()) {
        final fileItem = FileItem.fromFile(file);
        if (!_files.contains(fileItem)) {
          _files.add(fileItem); // By default, isSelected is true in FileItem
          newFilesAdded = true;
        }
      }
    }

    if (newFilesAdded) {
      notifyListeners();
      _updateCombinedContent(); // Update content for newly added files (references)
      loadFileContents(); // Automatically load content for new files
    } else {
      notifyListeners(); // Still notify if no new files but paths were processed
    }
  }

  Future<void> addDirectory(String directoryPath) async {
    _error = null;
    bool newFilesAdded = false;
    try {
      final directory = Directory(directoryPath);
      if (!directory.existsSync()) {
        _error = 'Directory not found: $directoryPath';
        notifyListeners();
        return;
      }

      final activeExtensions =
          _activeExtensions ?? FileExtensionConfig.extensionCategories;
      final foundFilePaths = <String>[];

      await for (final entity
          in directory.list(recursive: true, followLinks: false)) {
        if (entity is File) {
          final extension = entity.path.split('.').last.toLowerCase();
          if (activeExtensions.containsKey('.$extension')) {
            foundFilePaths.add(entity.path);
          }
        }
      }

      if (foundFilePaths.isNotEmpty) {
        // Temporarily collect files to check which are truly new
        final tempNewFiles = <FileItem>[];
        for (final filePath in foundFilePaths) {
          final file = File(filePath);
          if (file.existsSync()) {
            final fileItem = FileItem.fromFile(file);
            if (!_files.contains(fileItem)) {
              tempNewFiles.add(fileItem);
            }
          }
        }

        if (tempNewFiles.isNotEmpty) {
          _files.addAll(tempNewFiles);
          newFilesAdded = true;
        }
      }
    } catch (e) {
      _error = 'Error scanning directory: $e';
    }

    if (newFilesAdded) {
      notifyListeners();
      _updateCombinedContent();
      await loadFileContents(); // Automatically load content
    } else {
      notifyListeners(); // Notify for errors or if no new files were found
    }
  }

  void removeFile(FileItem fileItem) {
    _files.remove(fileItem);
    notifyListeners();
    _updateCombinedContent();
  }

  void clearFiles() {
    _files.clear();
    _combinedContent = '';
    _error = null;
    notifyListeners();
  }

  void toggleFileSelection(FileItem fileItem) {
    final index = _files.indexOf(fileItem);
    if (index != -1) {
      _files[index] = fileItem.copyWith(isSelected: !fileItem.isSelected);
      notifyListeners();
      _updateCombinedContent();
    }
  }

  void selectAll() {
    for (int i = 0; i < _files.length; i++) {
      _files[i] = _files[i].copyWith(isSelected: true);
    }
    notifyListeners();
    _updateCombinedContent();
  }

  void deselectAll() {
    for (int i = 0; i < _files.length; i++) {
      _files[i] = _files[i].copyWith(isSelected: false);
    }
    notifyListeners();
    _updateCombinedContent();
  }

  Future<void> loadFileContents() async {
    // Only process files that are selected, have no content, and are not already loading
    final filesToLoad = _files
        .where((f) => f.isSelected && f.content == null && !f.isLoading)
        .toList();

    if (filesToLoad.isEmpty) return;

    _isProcessing = true;
    _error = null;
    notifyListeners();

    try {
      bool contentChanged = false;
      for (final fileToLoad in filesToLoad) {
        final index = _files.indexOf(fileToLoad);
        if (index != -1) {
          // Should always be true here
          _files[index] = _files[index].copyWith(isLoading: true);
          // No need to notify here, will notify after each load or batch at end

          final updatedFile = await _files[index].loadContent(
            activeExtensions: _activeExtensions,
          );
          _files[index] = updatedFile;
          if (updatedFile.content != null || updatedFile.error != null) {
            contentChanged = true;
          }
          notifyListeners(); // Notify after each file is processed to update UI progressively
        }
      }

      if (contentChanged) {
        _updateCombinedContent(); // This will re-generate the combined text
      }
    } catch (e) {
      _error = 'Error loading files: $e';
    } finally {
      _isProcessing = false;
      notifyListeners(); // Final notification for isProcessing and any errors
    }
  }

  void _updateCombinedContent() {
    final buffer = StringBuffer()
      ..writeln('# Context Collection')
      ..writeln('Generated on: ${DateTime.now().toIso8601String()}')
      ..writeln('Total selected files: ${selectedFiles.length}')
      ..writeln();

    for (final file in selectedFiles) {
      buffer
        ..writeln('=' * 80)
        ..writeln(file.generateReference())
        ..writeln('=' * 80);

      if (file.isLoading) {
        buffer.writeln('LOADING CONTENT...');
      } else if (file.content != null) {
        buffer.writeln(file.content);
      } else if (file.error != null) {
        buffer.writeln('ERROR: ${file.error}');
      } else if (!file.isTextFileWithSettings(_activeExtensions)) {
        buffer.writeln('SKIPPED: Binary file');
      } else {
        buffer.writeln('PENDING: Content not loaded (or file is empty)');
      }

      buffer
        ..writeln()
        ..writeln();
    }

    _combinedContent = buffer.toString();
  }

  Future<void> copyToClipboard() async {
    if (_combinedContent.isEmpty) {
      await loadFileContents();
    }

    try {
      await Clipboard.setData(ClipboardData(text: _combinedContent));
    } catch (e) {
      _error = 'Error copying to clipboard: $e';
      notifyListeners();
    }
  }

  Future<void> saveToFile() async {
    if (_combinedContent.isEmpty) {
      await loadFileContents();
    }

    try {
      final fileName =
          'context_collection_${DateTime.now().millisecondsSinceEpoch}.txt';

      final filePath = await getSaveLocation(
        suggestedName: fileName,
        acceptedTypeGroups: [
          const XTypeGroup(
            label: 'Text files',
            extensions: ['txt'],
          ),
        ],
      );

      if (filePath != null) {
        final file = File(filePath.path);
        await file.writeAsString(_combinedContent);
      }
    } catch (e) {
      _error = 'Error saving file: $e';
      notifyListeners();
    }
  }

  Future<void> pickFiles() async {
    try {
      final List<XFile> files = await openFiles(
        acceptedTypeGroups: [
          const XTypeGroup(
            label: 'Text files',
            extensions: <String>[
              'txt',
              'dart',
              'py',
              'js',
              'ts',
              'jsx',
              'tsx',
              'java',
              'kt',
              'swift',
              'cpp',
              'c',
              'h',
              'hpp',
              'cs',
              'php',
              'rb',
              'go',
              'rs',
              'html',
              'css',
              'scss',
              'json',
              'xml',
              'yaml',
              'yml',
              'md',
              'sql'
            ],
          ),
          const XTypeGroup(
            label: 'All files',
          ),
        ],
      );

      if (files.isNotEmpty) {
        final filePaths = files.map((file) => file.path).toList();
        addFiles(filePaths);
      }
    } catch (e) {
      _error = 'Error picking files: $e';
      notifyListeners();
    }
  }

  Future<void> pickDirectory() async {
    try {
      final String? directoryPath = await getDirectoryPath();

      if (directoryPath != null) {
        await addDirectory(directoryPath);
      }
    } catch (e) {
      _error = 'Error picking directory: $e';
      notifyListeners();
    }
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }
}
```

### providers/settings_provider.dart
- Language: dart
```dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../config/file_extensions.dart';
import '../models/extension_settings.dart';

class SettingsProvider with ChangeNotifier {
  SettingsProvider() {
    _loadSettings();
  }

  static const String _prefsKey = 'extension_settings';

  ExtensionSettings _settings = const ExtensionSettings();
  bool _isLoading = true;

  ExtensionSettings get settings => _settings;

  bool get isLoading => _isLoading;

  // Get all active extensions
  Map<String, FileCategory> get activeExtensions => _settings.activeExtensions;

  // Get all available extensions grouped by category
  Map<FileCategory, List<MapEntry<String, bool>>> get groupedExtensions {
    final result = <FileCategory, List<MapEntry<String, bool>>>{};

    // Add default extensions
    for (final entry in FileExtensionConfig.extensionCategories.entries) {
      final category = entry.value;
      final isEnabled = !_settings.disabledExtensions.contains(entry.key);

      result.putIfAbsent(category, () => []);
      result[category]!.add(MapEntry(entry.key, isEnabled));
    }

    // Add custom extensions
    for (final entry in _settings.customExtensions.entries) {
      final category = entry.value;

      result.putIfAbsent(category, () => []);
      result[category]!.add(MapEntry(entry.key, true));
    }

    // Sort extensions within each category
    for (final list in result.values) {
      list.sort((a, b) => a.key.compareTo(b.key));
    }

    return result;
  }

  Future<void> _loadSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final settingsJson = prefs.getString(_prefsKey);

      if (settingsJson != null) {
        _settings = ExtensionSettings.fromJsonString(settingsJson);
      }
    } catch (e) {
      debugPrint('Error loading settings: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _saveSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_prefsKey, _settings.toJsonString());
    } catch (e) {
      debugPrint('Error saving settings: $e');
    }
  }

  // Toggle extension enabled/disabled state
  Future<void> toggleExtension(String extension) async {
    final isDefault =
        FileExtensionConfig.extensionCategories.containsKey(extension);

    if (isDefault) {
      // For default extensions, add/remove from disabled list
      final newDisabled = Set<String>.from(_settings.disabledExtensions);

      if (newDisabled.contains(extension)) {
        newDisabled.remove(extension);
      } else {
        newDisabled.add(extension);
      }

      _settings = _settings.copyWith(disabledExtensions: newDisabled);
    } else {
      // For custom extensions, remove from custom list
      final newCustom =
          Map<String, FileCategory>.from(_settings.customExtensions)
            ..remove(extension);

      _settings = _settings.copyWith(customExtensions: newCustom);
    }

    await _saveSettings();
    notifyListeners();
  }

  // Add a custom extension
  Future<void> addCustomExtension(
      String extension, FileCategory category) async {
    if (extension.isEmpty || !extension.startsWith('.')) {
      throw ArgumentError('Invalid extension format');
    }

    final ext = extension.toLowerCase();

    // Check if it already exists
    if (FileExtensionConfig.extensionCategories.containsKey(ext) ||
        _settings.customExtensions.containsKey(ext)) {
      throw ArgumentError('Extension already exists');
    }

    final newCustom =
        Map<String, FileCategory>.from(_settings.customExtensions);
    newCustom[ext] = category;

    // Remove from disabled if it was there
    final newDisabled = Set<String>.from(_settings.disabledExtensions)
      ..remove(ext);

    _settings = _settings.copyWith(
      customExtensions: newCustom,
      disabledExtensions: newDisabled,
    );

    await _saveSettings();
    notifyListeners();
  }

  // Reset to default settings
  Future<void> resetToDefaults() async {
    _settings = const ExtensionSettings();
    await _saveSettings();
    notifyListeners();
  }

  // Enable all extensions
  Future<void> enableAll() async {
    _settings = _settings.copyWith(disabledExtensions: {});
    await _saveSettings();
    notifyListeners();
  }

  // Disable all extensions (except custom ones)
  Future<void> disableAll() async {
    _settings = _settings.copyWith(
      disabledExtensions: FileExtensionConfig.extensionCategories.keys.toSet(),
    );
    await _saveSettings();
    notifyListeners();
  }
}
```

### screens/home_screen.dart
- Language: dart
```dart
import 'dart:io';

import 'package:desktop_drop/desktop_drop.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../extensions/theme_extensions.dart';
import '../providers/file_collector_provider.dart';
import '../providers/settings_provider.dart';
import '../widgets/action_buttons_widget.dart';
import '../widgets/combined_content_widget.dart';
import '../widgets/drop_zone_widget.dart';
import '../widgets/file_list_widget.dart';
import 'settings_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool _isDragging = false;

  @override
  void initState() {
    super.initState();
    // Connect the settings provider to file collector provider
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final fileProvider = context.read<FileCollectorProvider>();
      final settingsProvider = context.read<SettingsProvider>();
      fileProvider.settingsProvider = settingsProvider;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: context.surface,
      appBar: AppBar(
        title: Row(
          children: [
            Container(
              padding: const EdgeInsetsDirectional.all(8),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    context.primary,
                    context.primary.addOpacity(0.8),
                  ],
                ),
                borderRadius: BorderRadius.circular(10),
              ),
              child: const Icon(
                Icons.collections_bookmark_rounded,
                color: Colors.white,
                size: 20,
              ),
            ),
            const SizedBox(width: 12),
            const Text('Context Collector'),
          ],
        ),
        actions: [
          Consumer<FileCollectorProvider>(
            builder: (context, provider, child) {
              return Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  AnimatedContainer(
                    duration: const Duration(milliseconds: 300),
                    padding: provider.hasFiles
                        ? const EdgeInsetsDirectional.symmetric(
                            horizontal: 12,
                            vertical: 6,
                          )
                        : EdgeInsetsDirectional.zero,
                    decoration: BoxDecoration(
                      color: provider.hasFiles
                          ? context.primary.addOpacity(0.1)
                          : Colors.transparent,
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: provider.hasFiles
                        ? Row(
                            children: [
                              Icon(
                                Icons.check_circle_rounded,
                                size: 16,
                                color: context.primary,
                              ),
                              const SizedBox(width: 6),
                              Text(
                                '${provider.selectedFilesCount}',
                                style: context.titleSmall?.copyWith(
                                  color: context.primary,
                                  fontWeight: FontWeight.w700,
                                ),
                              ),
                              Text(
                                ' / ${provider.totalFilesCount}',
                                style: context.titleSmall?.copyWith(
                                  color: context.onSurface.addOpacity(0.6),
                                ),
                              ),
                            ],
                          )
                        : const SizedBox.shrink(),
                  ),
                  if (provider.hasFiles) const SizedBox(width: 8),
                  AnimatedScale(
                    scale: provider.hasFiles ? 1.0 : 0.0,
                    duration: const Duration(milliseconds: 200),
                    child: IconButton(
                      onPressed: provider.hasFiles ? provider.clearFiles : null,
                      icon: const Icon(Icons.clear_all_rounded),
                      tooltip: 'Clear all files',
                      style: IconButton.styleFrom(
                        backgroundColor: context.error.addOpacity(0.1),
                        foregroundColor: context.error,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                ],
              );
            },
          ),
          IconButton(
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute<void>(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            icon: const Icon(Icons.settings_rounded),
            tooltip: 'Settings',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: DropTarget(
        onDragEntered: (details) {
          setState(() => _isDragging = true);
        },
        onDragExited: (details) {
          setState(() => _isDragging = false);
        },
        onDragDone: (details) async {
          setState(() => _isDragging = false);
          final provider = context.read<FileCollectorProvider>();

          final files = <String>[];
          final directories = <String>[];

          // Separate files and directories
          for (final file in details.files) {
            // final entity = await FileSystemEntity.type(file.path);
            final entity = FileSystemEntity.typeSync(file.path);
            if (entity == FileSystemEntityType.file) {
              files.add(file.path);
            } else if (entity == FileSystemEntityType.directory) {
              directories.add(file.path);
            }
          }

          // Add files first
          if (files.isNotEmpty) {
            provider.addFiles(files);
          }

          // Add directories
          for (final directory in directories) {
            await provider.addDirectory(directory);
          }
        },
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          decoration: BoxDecoration(
            color: _isDragging
                ? context.primary.addOpacity(0.1)
                : Colors.transparent,
            border: _isDragging
                ? Border.all(
                    color: context.primary.addOpacity(0.5),
                    width: 2,
                  )
                : null,
          ),
          child: Consumer<FileCollectorProvider>(
            builder: (context, provider, child) {
              if (provider.error != null) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(provider.error!),
                      backgroundColor: context.error,
                      action: SnackBarAction(
                        label: 'Dismiss',
                        onPressed: provider.clearError,
                        textColor: context.onError,
                      ),
                    ),
                  );
                  provider.clearError();
                });
              }

              if (!provider.hasFiles) {
                return const DropZoneWidget();
              }

              return Row(
                children: [
                  // Left panel - File list
                  Expanded(
                    flex: 2,
                    child: Column(
                      children: [
                        const ActionButtonsWidget(),
                        const Expanded(child: FileListWidget()),
                        if (provider.isProcessing)
                          const LinearProgressIndicator(),
                      ],
                    ),
                  ),

                  // Divider
                  const VerticalDivider(width: 1),

                  // Right panel - Combined content
                  const Expanded(
                    flex: 3,
                    child: CombinedContentWidget(),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }
}
```

### screens/settings_screen.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../config/file_extensions.dart';
import '../extensions/theme_extensions.dart';
import '../providers/settings_provider.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final _extensionController = TextEditingController();
  FileCategory _selectedCategory = FileCategory.other;
  final _formKey = GlobalKey<FormState>();

  @override
  void dispose() {
    _extensionController.dispose();
    super.dispose();
  }

  Future<void> _showAddExtensionDialog(
      BuildContext context, SettingsProvider provider) async {
    await showDialog<void>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Add Custom Extension'),
        content: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: _extensionController,
                decoration: const InputDecoration(
                  labelText: 'Extension',
                  hintText: '.example',
                  prefixIcon: Icon(Icons.extension_rounded),
                ),
                inputFormatters: [
                  // Ensure it starts with a dot
                  TextInputFormatter.withFunction((oldValue, newValue) {
                    final text = newValue.text;
                    if (text.isEmpty) return newValue;
                    if (!text.startsWith('.')) {
                      return TextEditingValue(
                        text: '.$text',
                        selection:
                            TextSelection.collapsed(offset: text.length + 1),
                      );
                    }
                    return newValue;
                  }),
                ],
                validator: (value) {
                  if (value == null || value.isEmpty || value == '.') {
                    return 'Please enter a valid extension';
                  }
                  if (!value.startsWith('.')) {
                    return 'Extension must start with a dot';
                  }
                  if (provider.activeExtensions
                      .containsKey(value.toLowerCase())) {
                    return 'Extension already exists';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<FileCategory>(
                value: _selectedCategory,
                decoration: const InputDecoration(
                  labelText: 'Category',
                  prefixIcon: Icon(Icons.category_rounded),
                ),
                items: FileCategory.values.map((category) {
                  return DropdownMenuItem(
                    value: category,
                    child: Row(
                      children: [
                        Icon(category.icon, size: 20),
                        const SizedBox(width: 8),
                        Text(category.displayName),
                      ],
                    ),
                  );
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    setState(() => _selectedCategory = value);
                  }
                },
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              if (_formKey.currentState!.validate()) {
                try {
                  await provider.addCustomExtension(
                    _extensionController.text.toLowerCase(),
                    _selectedCategory,
                  );
                  if (mounted) {
                    Navigator.pop(dialogContext);
                    _extensionController.clear();
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Extension added successfully'),
                      ),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('Error: $e'),
                        backgroundColor: context.error,
                      ),
                    );
                  }
                }
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Extension Settings'),
        actions: [
          Consumer<SettingsProvider>(
            builder: (context, provider, child) {
              return PopupMenuButton<String>(
                icon: const Icon(Icons.more_vert_rounded),
                onSelected: (value) async {
                  switch (value) {
                    case 'enable_all':
                      await provider.enableAll();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('All extensions enabled'),
                          ),
                        );
                      }
                    case 'disable_all':
                      await provider.disableAll();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('All default extensions disabled'),
                          ),
                        );
                      }
                    case 'reset':
                      await showDialog<void>(
                        context: context,
                        builder: (dialogContext) => AlertDialog(
                          title: const Text('Reset to Defaults'),
                          content: const Text(
                            'This will remove all custom extensions and reset all settings to default. Are you sure?',
                          ),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(dialogContext),
                              child: const Text('Cancel'),
                            ),
                            FilledButton(
                              onPressed: () async {
                                await provider.resetToDefaults();
                                if (mounted) {
                                  Navigator.pop(dialogContext);
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                      content:
                                          Text('Settings reset to defaults'),
                                    ),
                                  );
                                }
                              },
                              style: FilledButton.styleFrom(
                                backgroundColor: context.error,
                              ),
                              child: const Text('Reset'),
                            ),
                          ],
                        ),
                      );
                  }
                },
                itemBuilder: (context) => [
                  const PopupMenuItem(
                    value: 'enable_all',
                    child: Row(
                      children: [
                        Icon(Icons.check_circle_outline_rounded),
                        SizedBox(width: 12),
                        Text('Enable All'),
                      ],
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'disable_all',
                    child: Row(
                      children: [
                        Icon(Icons.remove_circle_outline_rounded),
                        SizedBox(width: 12),
                        Text('Disable All Default'),
                      ],
                    ),
                  ),
                  const PopupMenuDivider(),
                  const PopupMenuItem(
                    value: 'reset',
                    child: Row(
                      children: [
                        Icon(Icons.restore_rounded),
                        SizedBox(width: 12),
                        Text('Reset to Defaults'),
                      ],
                    ),
                  ),
                ],
              );
            },
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: Consumer<SettingsProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          final groupedExtensions = provider.groupedExtensions;

          return Column(
            children: [
              Container(
                padding: const EdgeInsetsDirectional.all(16),
                color: context.surfaceContainerHighest,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Customize Supported File Extensions',
                      style: context.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Enable or disable file extensions for context collection. You can also add custom extensions.',
                      style: context.bodyMedium?.copyWith(
                        color: context.onSurface.addOpacity(0.7),
                      ),
                    ),
                    const SizedBox(height: 16),
                    FilledButton.icon(
                      onPressed: () =>
                          _showAddExtensionDialog(context, provider),
                      icon: const Icon(Icons.add_rounded),
                      label: const Text('Add Custom Extension'),
                    ),
                  ],
                ),
              ),
              Expanded(
                child: ListView.builder(
                  padding: const EdgeInsetsDirectional.all(16),
                  itemCount: groupedExtensions.length,
                  itemBuilder: (context, index) {
                    final category = groupedExtensions.keys.elementAt(index);
                    final extensions = groupedExtensions[category]!;
                    final enabledCount =
                        extensions.where((e) => e.value).length;

                    return Card(
                      margin: const EdgeInsetsDirectional.only(bottom: 16),
                      child: ExpansionTile(
                        leading: Icon(category.icon),
                        title: Text(category.displayName),
                        subtitle: Text(
                          '$enabledCount of ${extensions.length} enabled',
                          style: context.bodySmall?.copyWith(
                            color: context.onSurface.addOpacity(0.6),
                          ),
                        ),
                        children: [
                          const Divider(height: 1),
                          Padding(
                            padding: const EdgeInsetsDirectional.all(8),
                            child: Wrap(
                              spacing: 8,
                              runSpacing: 8,
                              children: extensions.map((entry) {
                                final extension = entry.key;
                                final isEnabled = entry.value;
                                final isCustom = provider
                                    .settings.customExtensions
                                    .containsKey(extension);

                                return FilterChip(
                                  label: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text(extension),
                                      if (isCustom) ...[
                                        const SizedBox(width: 4),
                                        Icon(
                                          Icons.star_rounded,
                                          size: 14,
                                          color: context.primary,
                                        ),
                                      ],
                                    ],
                                  ),
                                  selected: isEnabled,
                                  onSelected: (_) async {
                                    await provider.toggleExtension(extension);
                                  },
                                  showCheckmark: true,
                                  deleteIcon: isCustom
                                      ? const Icon(Icons.close_rounded,
                                          size: 18)
                                      : null,
                                  onDeleted: isCustom
                                      ? () async {
                                          await provider
                                              .toggleExtension(extension);
                                        }
                                      : null,
                                );
                              }).toList(),
                            ),
                          ),
                        ],
                      ),
                    );
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

### theme/app_theme.dart
- Language: dart
```dart
// ignore_for_file: unused_field
import 'package:flutter/material.dart';

class AppTheme {
  // Modern color palette inspired by modern design systems
  static const Color _primaryColor = Color(0xFF5B47E0); // Modern purple
  static const Color _primaryVariant = Color(0xFF4936C9);
  static const Color _secondaryColor = Color(0xFF00D4AA); // Mint green
  static const Color _accentColor = Color(0xFFFF6B6B); // Coral red
  static const Color _surfaceColor = Color(0xFFF7F9FC); // Cool gray
  static const Color _backgroundColor = Color(0xFFFCFDFF); // Almost white
  static const Color _errorColor = Color(0xFFFF4757);
  static const Color _successColor = Color(0xFF00D4AA);
  static const Color _warningColor = Color(0xFFFFA502);
  static const Color _infoColor = Color(0xFF54A0FF);

  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: const ColorScheme.light(
        primary: _primaryColor,
        secondary: _secondaryColor,
        tertiary: _accentColor,
        surface: _surfaceColor,
        error: _errorColor,
        onPrimary: Colors.white,
        onSecondary: Colors.white,
        onSurface: Color(0xFF1A1C1E),
        onError: Colors.white,
        surfaceContainerHighest: Color(0xFFE8EDF5),
        outline: Color(0xFFE0E5ED),
        outlineVariant: Color(0xFFF0F3F7),
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: _backgroundColor,
        foregroundColor: Color(0xFF1A1C1E),
        titleTextStyle: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.w700,
          color: Color(0xFF1A1C1E),
          letterSpacing: -0.5,
        ),
        iconTheme: IconThemeData(
          color: Color(0xFF1A1C1E),
          size: 22,
        ),
      ),
      cardTheme: CardTheme(
        elevation: 0,
        color: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: const BorderSide(
            color: Color(0xFFE8EDF5),
            width: 1,
          ),
        ),
        margin: const EdgeInsetsDirectional.all(6),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          backgroundColor: _primaryColor,
          foregroundColor: Colors.white,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          side: const BorderSide(
            color: Color(0xFFE8EDF5),
            width: 1.5,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6),
        ),
        fillColor: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return _primaryColor;
          }
          return null;
        }),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: const Color(0xFFF7F9FC),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _primaryColor, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _errorColor, width: 1.5),
        ),
        contentPadding: const EdgeInsetsDirectional.symmetric(
          horizontal: 16,
          vertical: 14,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: Color(0xFFE8EDF5),
        thickness: 1,
        space: 0,
      ),
      iconTheme: const IconThemeData(
        size: 20,
      ),
      progressIndicatorTheme: const ProgressIndicatorThemeData(
        color: _primaryColor,
      ),
      snackBarTheme: SnackBarThemeData(
        backgroundColor: const Color(0xFF1A1C1E),
        contentTextStyle: const TextStyle(
          color: Colors.white,
          fontSize: 14,
          fontWeight: FontWeight.w500,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        behavior: SnackBarBehavior.floating,
        elevation: 4,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: const ColorScheme.dark(
        primary: _primaryColor,
        secondary: _secondaryColor,
        tertiary: _accentColor,
        surface: Color(0xFF1C1E21),
        error: _errorColor,
        onPrimary: Colors.white,
        onSecondary: Colors.white,
        onSurface: Color(0xFFE1E3E8),
        onError: Colors.white,
        surfaceContainerHighest: Color(0xFF262A2F),
        outline: Color(0xFF3A3F47),
        outlineVariant: Color(0xFF2C3036),
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: Color(0xFF16181B),
        foregroundColor: Color(0xFFE1E3E8),
        titleTextStyle: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.w700,
          color: Color(0xFFE1E3E8),
          letterSpacing: -0.5,
        ),
        iconTheme: IconThemeData(
          color: Color(0xFFE1E3E8),
          size: 22,
        ),
      ),
      cardTheme: CardTheme(
        elevation: 0,
        color: const Color(0xFF262A2F),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: const BorderSide(
            color: Color(0xFF3A3F47),
            width: 1,
          ),
        ),
        margin: const EdgeInsetsDirectional.all(6),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          backgroundColor: _primaryColor,
          foregroundColor: Colors.white,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          side: const BorderSide(
            color: Color(0xFF3A3F47),
            width: 1.5,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6),
        ),
        fillColor: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return _primaryColor;
          }
          return null;
        }),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: const Color(0xFF262A2F),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _primaryColor, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _errorColor, width: 1.5),
        ),
        contentPadding: const EdgeInsetsDirectional.symmetric(
          horizontal: 16,
          vertical: 14,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: Color(0xFF3A3F47),
        thickness: 1,
        space: 0,
      ),
      iconTheme: const IconThemeData(
        size: 20,
      ),
      progressIndicatorTheme: const ProgressIndicatorThemeData(
        color: _primaryColor,
      ),
      snackBarTheme: SnackBarThemeData(
        backgroundColor: const Color(0xFF2C3036),
        contentTextStyle: const TextStyle(
          color: Color(0xFFE1E3E8),
          fontSize: 14,
          fontWeight: FontWeight.w500,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        behavior: SnackBarBehavior.floating,
        elevation: 4,
      ),
    );
  }
}
```

### widgets/action_buttons_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../extensions/theme_extensions.dart';
import '../providers/file_collector_provider.dart';

class ActionButtonsWidget extends StatelessWidget {
  const ActionButtonsWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<FileCollectorProvider>(
      builder: (context, provider, child) {
        return Container(
          padding: const EdgeInsetsDirectional.all(20),
          decoration: BoxDecoration(
            color: context.background,
            border: BorderDirectional(
              bottom: BorderSide(
                color: context.outline.addOpacity(0.2),
                width: 1,
              ),
            ),
          ),
          child: Column(
            children: [
              // File selection controls
              Container(
                padding: const EdgeInsetsDirectional.symmetric(
                  horizontal: 16,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: context.surface,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: context.outline.addOpacity(0.2),
                  ),
                ),
                child: Row(
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.folder_copy_rounded,
                          size: 20,
                          color: context.primary,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          'Files',
                          style: context.titleMedium?.copyWith(
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsetsDirectional.symmetric(
                            horizontal: 10,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: context.primary.addOpacity(0.1),
                            borderRadius: BorderRadius.circular(20),
                          ),
                          child: Text(
                            '${provider.selectedFilesCount} / ${provider.totalFilesCount}',
                            style: context.labelSmall?.copyWith(
                              color: context.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const Spacer(),
                    Container(
                      decoration: BoxDecoration(
                        color: context.surfaceContainerHighest,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Material(
                            color: Colors.transparent,
                            borderRadius: const BorderRadiusDirectional.only(
                              topStart: Radius.circular(8),
                              bottomStart: Radius.circular(8),
                            ),
                            child: InkWell(
                              onTap: provider.totalFilesCount > 0
                                  ? provider.selectAll
                                  : null,
                              borderRadius: const BorderRadius.only(
                                topLeft: Radius.circular(8),
                                bottomLeft: Radius.circular(8),
                              ),
                              child: Container(
                                padding: const EdgeInsetsDirectional.symmetric(
                                  horizontal: 12,
                                  vertical: 6,
                                ),
                                child: Row(
                                  children: [
                                    Icon(
                                      Icons.done_all_rounded,
                                      size: 16,
                                      color: provider.totalFilesCount > 0
                                          ? context.primary
                                          : context.onSurface.addOpacity(0.3),
                                    ),
                                    const SizedBox(width: 4),
                                    Text(
                                      'All',
                                      style: context.labelMedium?.copyWith(
                                        color: provider.totalFilesCount > 0
                                            ? context.primary
                                            : context.onSurface.addOpacity(0.3),
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ),
                          Container(
                            width: 1,
                            height: 24,
                            color: context.outline.addOpacity(0.2),
                          ),
                          Material(
                            color: Colors.transparent,
                            borderRadius: const BorderRadiusDirectional.only(
                              topEnd: Radius.circular(8),
                              bottomEnd: Radius.circular(8),
                            ),
                            child: InkWell(
                              onTap: provider.selectedFilesCount > 0
                                  ? provider.deselectAll
                                  : null,
                              borderRadius: const BorderRadius.only(
                                topRight: Radius.circular(8),
                                bottomRight: Radius.circular(8),
                              ),
                              child: Container(
                                padding: const EdgeInsetsDirectional.symmetric(
                                  horizontal: 12,
                                  vertical: 6,
                                ),
                                child: Row(
                                  children: [
                                    Icon(
                                      Icons.remove_done_rounded,
                                      size: 16,
                                      color: provider.selectedFilesCount > 0
                                          ? context.onSurface.addOpacity(0.6)
                                          : context.onSurface.addOpacity(0.3),
                                    ),
                                    const SizedBox(width: 4),
                                    Text(
                                      'None',
                                      style: context.labelMedium?.copyWith(
                                        color: provider.selectedFilesCount > 0
                                            ? context.onSurface.addOpacity(0.6)
                                            : context.onSurface.addOpacity(0.3),
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 16),

              // Action buttons grid
              // All buttons removed as per user request, relying on drag-and-drop and CombinedContentWidget actions.
              // If any buttons are needed here in the future, they can be re-added.
              const SizedBox.shrink(),
              // No buttons left in this section
            ],
          ),
        );
      },
    );
  }
}
```

### widgets/combined_content_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';
import 'package:provider/provider.dart';

import '../extensions/theme_extensions.dart';
import '../providers/file_collector_provider.dart';
import 'editor_settings_dialog.dart';
import 'monaco_editor_embedded.dart';

class CombinedContentWidget extends StatefulWidget {
  const CombinedContentWidget({super.key});

  @override
  State<CombinedContentWidget> createState() => _CombinedContentWidgetState();
}

class _CombinedContentWidgetState extends State<CombinedContentWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _collapseController;
  late Animation<double> _collapseAnimation;
  bool _isCollapsed = false;
  EditorSettings _editorSettings = const EditorSettings();

  @override
  void initState() {
    super.initState();
    _collapseController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _collapseAnimation = CurvedAnimation(
      parent: _collapseController,
      curve: Curves.easeInOut,
    );
    _collapseController.value = 1.0; // Start expanded
    _loadEditorSettings();
  }

  Future<void> _loadEditorSettings() async {
    final settings = await EditorSettings.load();
    if (mounted) {
      setState(() {
        _editorSettings = settings;
      });
    }
  }

  @override
  void dispose() {
    _collapseController.dispose();
    super.dispose();
  }

  void _toggleCollapse() {
    setState(() {
      _isCollapsed = !_isCollapsed;
      if (_isCollapsed) {
        _collapseController.reverse();
      } else {
        _collapseController.forward();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<FileCollectorProvider>(
      builder: (context, provider, child) {
        return Column(
          children: [
            // Header with collapse button
            Container(
              padding: const EdgeInsetsDirectional.symmetric(
                horizontal: 16,
                vertical: 12,
              ),
              decoration: BoxDecoration(
                color: context.surface,
                border: BorderDirectional(
                  bottom: BorderSide(
                    color: context.onSurface.addOpacity(0.1),
                  ),
                ),
                boxShadow: [
                  BoxShadow(
                    color: context.onSurface.addOpacity(0.05),
                    offset: const Offset(0, 1),
                    blurRadius: 3,
                  ),
                ],
              ),
              child: Row(
                children: [
                  // Collapse/Expand button
                  _buildCollapseButton(context),
                  const SizedBox(width: 12),

                  // Title with icon
                  Icon(
                    Icons.merge_type_rounded,
                    size: 20,
                    color: context.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    'Combined Content',
                    style: context.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),

                  // File count badge
                  if (provider.selectedFilesCount > 0) ...[
                    const SizedBox(width: 12),
                    Container(
                      padding: const EdgeInsetsDirectional.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: context.primary.addOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                          color: context.primary.addOpacity(0.3),
                        ),
                      ),
                      child: Text(
                        '${provider.selectedFilesCount} files',
                        style: context.labelSmall?.copyWith(
                          color: context.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],

                  const Spacer(),

                  // Settings button (for font size, theme, etc.)
                  IconButton(
                    onPressed: () => _showEditorSettings(context),
                    icon: const Icon(Icons.settings_outlined),
                    iconSize: 20,
                    tooltip: 'Editor settings',
                    style: IconButton.styleFrom(
                      foregroundColor: context.onSurface.addOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),

            // Content area
            Expanded(
              child: AnimatedBuilder(
                animation: _collapseAnimation,
                builder: (context, child) {
                  return Row(
                    children: [
                      // Collapsed sidebar
                      AnimatedContainer(
                        duration: const Duration(milliseconds: 300),
                        width: _isCollapsed ? 48 : 0,
                        child: _isCollapsed
                            ? _buildCollapsedSidebar(context, provider)
                            : const SizedBox.shrink(),
                      ),

                      // Main content
                      Expanded(
                        child: SizeTransition(
                          sizeFactor: _collapseAnimation,
                          axis: Axis.horizontal,
                          child: Container(
                            margin: const EdgeInsetsDirectional.all(16),
                            child: _buildContent(context, provider),
                          ),
                        ),
                      ),
                    ],
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildCollapseButton(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: _toggleCollapse,
        borderRadius: BorderRadius.circular(6),
        child: Container(
          padding: const EdgeInsetsDirectional.all(6),
          decoration: BoxDecoration(
            border: Border.all(
              color: context.onSurface.addOpacity(0.2),
            ),
            borderRadius: BorderRadius.circular(6),
          ),
          child: AnimatedRotation(
            turns: _isCollapsed ? 0.5 : 0,
            duration: const Duration(milliseconds: 300),
            child: Icon(
              Icons.chevron_left,
              size: 18,
              color: context.onSurface.addOpacity(0.7),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildCollapsedSidebar(BuildContext context,
      FileCollectorProvider provider) {
    return Container(
      decoration: BoxDecoration(
        color: context.isDark
            ? Colors.black.addOpacity(0.3)
            : Colors.grey.shade100,
        border: BorderDirectional(
          end: BorderSide(
            color: context.onSurface.addOpacity(0.1),
          ),
        ),
      ),
      child: Column(
        children: [
          const SizedBox(height: 16),
          IconButton(
            onPressed: _toggleCollapse,
            icon: const Icon(Icons.chevron_right),
            tooltip: 'Expand editor',
          ),
          const SizedBox(height: 24),
          if (provider.combinedContent.isNotEmpty) ...[
            IconButton(
              onPressed: () =>
                  _copyToClipboard(context, provider.combinedContent),
              icon: const Icon(Icons.copy),
              tooltip: 'Copy content',
            ),
            const SizedBox(height: 16),
            RotatedBox(
              quarterTurns: -1,
              child: Text(
                '${provider.selectedFilesCount} files',
                style: context.labelSmall?.copyWith(
                  color: context.onSurface.addOpacity(0.6),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildContent(BuildContext context, FileCollectorProvider provider) {
    if (provider.combinedContent.isEmpty) {
      return _buildEmptyState(context);
    }

    return MonacoEditorEmbedded(
      content: provider.combinedContent,
      onCopy: () => _copyToClipboard(context, provider.combinedContent),
      showLineNumbers: _editorSettings.showLineNumbers,
      fontSize: _editorSettings.fontSize,
      wordWrap: _editorSettings.wordWrap,
      readOnly: true,
    );
  }

  Widget _buildEmptyState(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsetsDirectional.all(24),
            decoration: BoxDecoration(
              color: context.primary.addOpacity(0.05),
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.merge_type_rounded,
              size: 64,
              color: context.primary.addOpacity(0.3),
            ),
          ),
          const SizedBox(height: 24),
          Text(
            'Combined Content Preview',
            style: context.titleLarge?.copyWith(
              color: context.onSurface.addOpacity(0.8),
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Select files and load their content to see the combined result here',
            textAlign: TextAlign.center,
            style: context.bodyMedium?.copyWith(
              color: context.onSurface.addOpacity(0.6),
            ),
          ),
          const SizedBox(height: 32),

          // Quick tips
          Container(
            padding: const EdgeInsetsDirectional.all(20),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [
                  context.primary.addOpacity(0.05),
                  context.primary.addOpacity(0.02),
                ],
                begin: AlignmentDirectional.topStart,
                end: AlignmentDirectional.bottomEnd,
              ),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: context.primary.addOpacity(0.2),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(
                      Icons.lightbulb_outline,
                      size: 20,
                      color: context.primary,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      'Quick Tips',
                      style: context.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: context.primary,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                _buildTip(
                  context,
                  '• Drag and drop files or folders directly onto the app',
                ),
                _buildTip(
                  context,
                  '• Use the action buttons to load, copy, or save content',
                ),
                _buildTip(
                  context,
                  '• Toggle file selection to customize your collection',
                ),
                _buildTip(
                  context,
                  '• Line numbers help navigate large combined files',
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTip(BuildContext context, String text) {
    return Padding(
      padding: const EdgeInsetsDirectional.only(bottom: 4),
      child: Text(
        text,
        style: context.bodySmall?.copyWith(
          color: context.onSurface.addOpacity(0.7),
          height: 1.5,
        ),
      ),
    );
  }

  void _copyToClipboard(BuildContext context, String content) {
    Clipboard.setData(ClipboardData(text: content)).then((_) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              Icon(
                Icons.check_circle,
                color: context.onPrimary,
                size: 20,
              ),
              const SizedBox(width: 8),
              const Text('Content copied to clipboard!'),
            ],
          ),
          backgroundColor: context.primary,
          behavior: SnackBarBehavior.floating,
          duration: const Duration(seconds: 2),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      );
    }).catchError((dynamic error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error copying to clipboard: $error'),
          backgroundColor: context.error,
        ),
      );
    });
  }

  void _showEditorSettings(BuildContext context) async {
    final newSettings = await EditorSettingsDialog.show(
      context,
      _editorSettings,
    );

    if (newSettings != null && mounted) {
      setState(() {
        _editorSettings = newSettings;
      });
    }
  }
}
```

### widgets/drop_zone_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';

import '../config/file_extensions.dart';
import '../extensions/theme_extensions.dart';

class DropZoneWidget extends StatelessWidget {
  const DropZoneWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        margin: const EdgeInsetsDirectional.all(32),
        padding: const EdgeInsetsDirectional.all(64),
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            maxWidth: 600,
          ),
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Icon container with gradient background
                Container(
                  width: 120,
                  height: 120,
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        context.primary.addOpacity(0.1),
                        context.primary.addOpacity(0.05),
                      ],
                      begin: AlignmentDirectional.topStart,
                      end: AlignmentDirectional.bottomEnd,
                    ),
                    borderRadius: BorderRadius.circular(30),
                  ),
                  child: Icon(
                    Icons.folder_open_rounded,
                    size: 56,
                    color: context.primary,
                  ),
                ),
                const SizedBox(height: 32),
                Text(
                  'Drop Your Files or Directories Here',
                  style: context.displaySmall?.copyWith(
                    color: context.onSurface,
                    fontWeight: FontWeight.w800,
                    letterSpacing: -1,
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  'Drag and drop files or directories to combine their content\ninto a single, organized collection',
                  textAlign: TextAlign.center,
                  style: context.bodyLarge?.copyWith(
                    color: context.onSurface.addOpacity(0.6),
                    height: 1.5,
                  ),
                ),
                const SizedBox(height: 40),
                _buildSecondaryButton(context),
                const SizedBox(height: 48),
                _buildFeatureGrid(context),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSecondaryButton(BuildContext context) {
    return OutlinedButton.icon(
      onPressed: () => _showSupportedFormats(context),
      icon: const Icon(Icons.help_outline_rounded),
      label: const Text('Supported Formats'),
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsetsDirectional.symmetric(
          horizontal: 24,
          vertical: 16,
        ),
        textStyle: const TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Widget _buildFeatureGrid(BuildContext context) {
    final features = [
      (
        icon: Icons.code_rounded,
        title: 'All Text Files',
        description:
            'Support for ${FileExtensionConfig.supportedExtensions.length}+ file types',
      ),
      (
        icon: Icons.link_rounded,
        title: 'File References',
        description: 'Includes path & metadata',
      ),
      (
        icon: Icons.content_copy_rounded,
        title: 'Quick Copy',
        description: 'One-click clipboard copy',
      ),
      (
        icon: Icons.save_alt_rounded,
        title: 'Export Ready',
        description: 'Save as text file',
      ),
    ];

    return Wrap(
      spacing: 16,
      runSpacing: 16,
      children: features
          .map((feature) => SizedBox(
                width: 280,
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsetsDirectional.all(12),
                      decoration: BoxDecoration(
                        color: context.primary.addOpacity(0.08),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Icon(
                        feature.icon,
                        size: 24,
                        color: context.primary,
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            feature.title,
                            style: context.titleSmall?.copyWith(
                              fontWeight: FontWeight.w700,
                            ),
                          ),
                          const SizedBox(height: 2),
                          Text(
                            feature.description,
                            style: context.bodySmall?.copyWith(
                              color: context.onSurface.addOpacity(0.6),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ))
          .toList(),
    );
  }

  Future<void> _showSupportedFormats(BuildContext context) async {
    final groupedExtensions = FileExtensionConfig.getGroupedExtensions();
    await showDialog<void>(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        child: Container(
          constraints: const BoxConstraints(
            maxWidth: 600,
            maxHeight: 700,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                padding: const EdgeInsetsDirectional.all(24),
                decoration: BoxDecoration(
                  color: context.primary.addOpacity(0.05),
                  borderRadius: const BorderRadiusDirectional.only(
                    topStart: Radius.circular(20),
                    topEnd: Radius.circular(20),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.file_present_rounded,
                      color: context.primary,
                      size: 28,
                    ),
                    const SizedBox(width: 12),
                    Text(
                      'Supported File Formats',
                      style: context.headlineSmall?.copyWith(
                        fontWeight: FontWeight.w700,
                        color: context.onSurface,
                      ),
                    ),
                    const Spacer(),
                    IconButton(
                      onPressed: () => Navigator.of(context).pop(),
                      icon: Icon(
                        Icons.close_rounded,
                        color: context.onSurface.addOpacity(0.6),
                      ),
                      style: IconButton.styleFrom(
                        backgroundColor: context.surface,
                      ),
                    ),
                  ],
                ),
              ),
              Flexible(
                child: SingleChildScrollView(
                  padding: const EdgeInsetsDirectional.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      for (final entry in groupedExtensions.entries) ...[
                        _buildFormatCategory(
                          context,
                          entry.key,
                          entry.value,
                        ),
                        if (entry.key != groupedExtensions.keys.last)
                          const SizedBox(height: 20),
                      ],
                    ],
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsetsDirectional.all(16),
                decoration: BoxDecoration(
                  color: context.surface,
                  borderRadius: const BorderRadiusDirectional.only(
                    bottomStart: Radius.circular(20),
                    bottomEnd: Radius.circular(20),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info_outline_rounded,
                      size: 16,
                      color: context.onSurface.addOpacity(0.6),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        '${FileExtensionConfig.supportedExtensions.length} file types supported',
                        style: context.bodySmall?.copyWith(
                          color: context.onSurface.addOpacity(0.6),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildFormatCategory(
      BuildContext context, FileCategory category, List<String> extensions) {
    return Container(
      padding: const EdgeInsetsDirectional.all(16),
      decoration: BoxDecoration(
        color: context.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: context.outline.addOpacity(0.2),
          width: 1,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsetsDirectional.all(8),
                decoration: BoxDecoration(
                  color: context.primary.addOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  category.icon,
                  size: 20,
                  color: context.primary,
                ),
              ),
              const SizedBox(width: 12),
              Text(
                category.displayName,
                style: context.titleSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                  color: context.onSurface,
                ),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsetsDirectional.symmetric(
                  horizontal: 8,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: context.primary.addOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${extensions.length}',
                  style: context.labelSmall?.copyWith(
                    color: context.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 6,
            runSpacing: 6,
            children: extensions
                .map((ext) => Container(
                      padding: const EdgeInsetsDirectional.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: context.surfaceContainerHighest,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        ext,
                        style: context.labelSmall?.copyWith(
                          fontFamily: 'monospace',
                          fontSize: 12,
                        ),
                      ),
                    ))
                .toList(),
          ),
        ],
      ),
    );
  }
}
```

### widgets/editor_settings_dialog.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../extensions/theme_extensions.dart';

class EditorSettings {

  const EditorSettings({
    this.fontSize = defaultFontSize,
    this.showLineNumbers = defaultShowLineNumbers,
    this.wordWrap = defaultWordWrap,
  });
  static const String keyFontSize = 'editor_font_size';
  static const String keyShowLineNumbers = 'editor_show_line_numbers';
  static const String keyWordWrap = 'editor_word_wrap';

  static const double defaultFontSize = 13;
  static const bool defaultShowLineNumbers = true;
  static const bool defaultWordWrap = false;

  final double fontSize;
  final bool showLineNumbers;
  final bool wordWrap;

  EditorSettings copyWith({
    double? fontSize,
    bool? showLineNumbers,
    bool? wordWrap,
  }) {
    return EditorSettings(
      fontSize: fontSize ?? this.fontSize,
      showLineNumbers: showLineNumbers ?? this.showLineNumbers,
      wordWrap: wordWrap ?? this.wordWrap,
    );
  }

  Future<void> save() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(keyFontSize, fontSize);
    await prefs.setBool(keyShowLineNumbers, showLineNumbers);
    await prefs.setBool(keyWordWrap, wordWrap);
  }

  static Future<EditorSettings> load() async {
    final prefs = await SharedPreferences.getInstance();
    return EditorSettings(
      fontSize: prefs.getDouble(keyFontSize) ?? defaultFontSize,
      showLineNumbers:
          prefs.getBool(keyShowLineNumbers) ?? defaultShowLineNumbers,
      wordWrap: prefs.getBool(keyWordWrap) ?? defaultWordWrap,
    );
  }
}

class EditorSettingsDialog extends StatefulWidget {

  const EditorSettingsDialog({
    super.key,
    required this.settings,
  });
  final EditorSettings settings;

  static Future<EditorSettings?> show(
    BuildContext context,
    EditorSettings currentSettings,
  ) async {
    return showDialog<EditorSettings>(
      context: context,
      builder: (context) => EditorSettingsDialog(settings: currentSettings),
    );
  }

  @override
  State<EditorSettingsDialog> createState() => _EditorSettingsDialogState();
}

class _EditorSettingsDialogState extends State<EditorSettingsDialog> {
  late EditorSettings _settings;

  @override
  void initState() {
    super.initState();
    _settings = widget.settings;
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Container(
        width: 400,
        padding: const EdgeInsetsDirectional.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.settings_outlined,
                  color: context.primary,
                ),
                const SizedBox(width: 12),
                Text(
                  'Editor Settings',
                  style: context.titleLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),

            // Font size
            _buildSectionTitle(context, 'Font Size'),
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: Slider(
                    value: _settings.fontSize,
                    min: 10,
                    max: 20,
                    divisions: 10,
                    label: '${_settings.fontSize.round()}px',
                    onChanged: (value) {
                      setState(() {
                        _settings = _settings.copyWith(fontSize: value);
                      });
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Container(
                  width: 60,
                  padding: const EdgeInsetsDirectional.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    color: context.primary.addOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: context.primary.addOpacity(0.3),
                    ),
                  ),
                  child: Text(
                    '${_settings.fontSize.round()}px',
                    style: context.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Preview
            Container(
              padding: const EdgeInsetsDirectional.all(12),
              decoration: BoxDecoration(
                color: context.isDark
                    ? Colors.black.addOpacity(0.3)
                    : Colors.grey.shade100,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: context.onSurface.addOpacity(0.1),
                ),
              ),
              child: Row(
                children: [
                  if (_settings.showLineNumbers) ...[
                    Text(
                      '1\n2\n3',
                      style: TextStyle(
                        fontFamily: 'monospace',
                        fontSize: _settings.fontSize * 0.9,
                        height: 1.4,
                        color: context.onSurface.addOpacity(0.4),
                      ),
                    ),
                    Container(
                      width: 1,
                      height: 50,
                      margin:
                          const EdgeInsetsDirectional.symmetric(horizontal: 12),
                      color: context.onSurface.addOpacity(0.1),
                    ),
                  ],
                  Expanded(
                    child: Text(
                      'Sample text preview\nLine 2 of code\nLine 3 of code',
                      style: TextStyle(
                        fontFamily: 'monospace',
                        fontSize: _settings.fontSize,
                        height: 1.4,
                        color: context.onSurface,
                      ),
                      softWrap: _settings.wordWrap,
                      overflow: _settings.wordWrap
                          ? TextOverflow.visible
                          : TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 24),

            // Options
            _buildSectionTitle(context, 'Display Options'),
            const SizedBox(height: 12),

            // Show line numbers
            _buildOptionTile(
              context,
              title: 'Show Line Numbers',
              subtitle: 'Display line numbers on the left side',
              value: _settings.showLineNumbers,
              onChanged: (value) {
                setState(() {
                  _settings = _settings.copyWith(showLineNumbers: value);
                });
              },
            ),

            // Word wrap
            _buildOptionTile(
              context,
              title: 'Word Wrap',
              subtitle: 'Wrap long lines instead of horizontal scrolling',
              value: _settings.wordWrap,
              onChanged: (value) {
                setState(() {
                  _settings = _settings.copyWith(wordWrap: value);
                });
              },
            ),

            const SizedBox(height: 24),

            // Actions
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancel'),
                ),
                const SizedBox(width: 8),
                FilledButton(
                  onPressed: () async {
                    await _settings.save();
                    if (mounted) {
                      Navigator.of(context).pop(_settings);
                    }
                  },
                  child: const Text('Apply'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Text(
      title,
      style: context.titleSmall?.copyWith(
        fontWeight: FontWeight.w600,
        color: context.onSurface.addOpacity(0.8),
      ),
    );
  }

  Widget _buildOptionTile(
    BuildContext context, {
    required String title,
    required String subtitle,
    required bool value,
    required ValueChanged<bool> onChanged,
  }) {
    return Padding(
      padding: const EdgeInsetsDirectional.only(bottom: 8),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () => onChanged(!value),
          borderRadius: BorderRadius.circular(8),
          child: Padding(
            padding: const EdgeInsetsDirectional.symmetric(
              horizontal: 12,
              vertical: 8,
            ),
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: context.bodyMedium?.copyWith(
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      Text(
                        subtitle,
                        style: context.labelSmall?.copyWith(
                          color: context.onSurface.addOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                ),
                Switch(
                  value: value,
                  onChanged: onChanged,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

### widgets/enhanced_text_editor.dart
- Language: dart
```dart
import 'package:flutter/material.dart';

import '../extensions/theme_extensions.dart';

class EnhancedTextEditor extends StatefulWidget {
  const EnhancedTextEditor({
    super.key,
    required this.content,
    this.onCopy,
    this.onScrollToTop,
    this.showLineNumbers = true,
    this.fontSize = 13,
    this.wordWrap = false,
  });

  final String content;
  final VoidCallback? onCopy;
  final VoidCallback? onScrollToTop;
  final bool showLineNumbers;
  final double fontSize;
  final bool wordWrap;

  @override
  State<EnhancedTextEditor> createState() => _EnhancedTextEditorState();
}

class _EnhancedTextEditorState extends State<EnhancedTextEditor>
    with SingleTickerProviderStateMixin {
  final ScrollController _verticalController = ScrollController();
  final ScrollController _horizontalController = ScrollController();
  final ScrollController _lineNumberController = ScrollController();

  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;

  List<String> _lines = [];
  int _totalLines = 0;
  int _totalCharacters = 0;

  @override
  void initState() {
    super.initState();
    _updateTextMetrics();

    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _fadeController,
      curve: Curves.easeIn,
    );
    _fadeController.forward();

    // Sync line numbers scroll with content scroll
    _verticalController.addListener(() {
      if (_lineNumberController.hasClients) {
        _lineNumberController.jumpTo(_verticalController.offset);
      }
    });
  }

  @override
  void didUpdateWidget(EnhancedTextEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.content != widget.content) {
      _updateTextMetrics();
      // Trigger fade animation on content change
      _fadeController.forward(from: 0);
    }
  }

  @override
  void dispose() {
    _verticalController.dispose();
    _horizontalController.dispose();
    _lineNumberController.dispose();
    _fadeController.dispose();
    super.dispose();
  }

  void _updateTextMetrics() {
    _lines = widget.content.split('\n');
    _totalLines = _lines.length;
    _totalCharacters = widget.content.length;
  }

  @override
  Widget build(BuildContext context) {
    final lineNumberWidth = _calculateLineNumberWidth();

    return Column(
      children: [
        // Main content area
        Expanded(
          child: FadeTransition(
            opacity: _fadeAnimation,
            child: Container(
              decoration: BoxDecoration(
                color: context.isDark
                    ? Colors.black.addOpacity(0.3)
                    : Colors.grey.shade50,
                border: Border.all(
                  color: context.onSurface.addOpacity(0.1),
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Line numbers
                    if (widget.showLineNumbers) ...[
                      Container(
                        width: lineNumberWidth,
                        decoration: BoxDecoration(
                          color: context.isDark
                              ? Colors.black.addOpacity(0.5)
                              : Colors.grey.shade100,
                          border: BorderDirectional(
                            end: BorderSide(
                              color: context.onSurface.addOpacity(0.1),
                            ),
                          ),
                        ),
                        child: SingleChildScrollView(
                          controller: _lineNumberController,
                          physics: const NeverScrollableScrollPhysics(),
                          child: Padding(
                            padding: const EdgeInsetsDirectional.only(
                              top: 12,
                              bottom: 12,
                              end: 8,
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.end,
                              children: List.generate(
                                _totalLines,
                                (index) => SizedBox(
                                  height: widget.fontSize * 1.4,
                                  child: Text(
                                    '${index + 1}',
                                    style: TextStyle(
                                      fontFamily: 'monospace',
                                      fontSize: widget.fontSize * 0.9,
                                      height: 1.4,
                                      color: context.onSurface.addOpacity(0.4),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                    ],

                    // Text content
                    Expanded(
                      child: widget.wordWrap
                          ? Scrollbar(
                              controller: _verticalController,
                              thumbVisibility: true,
                              child: SingleChildScrollView(
                                controller: _verticalController,
                                padding: const EdgeInsetsDirectional.all(12),
                                child: SelectableText(
                                  widget.content,
                                  style: TextStyle(
                                    fontFamily: 'monospace',
                                    fontSize: widget.fontSize,
                                    height: 1.4,
                                    color: context.onBackground,
                                  ),
                                  textAlign: TextAlign.start,
                                ),
                              ),
                            )
                          : Scrollbar(
                              controller: _horizontalController,
                              thumbVisibility: true,
                              child: SingleChildScrollView(
                                controller: _horizontalController,
                                scrollDirection: Axis.horizontal,
                                child: SizedBox(
                                  width: _calculateTextWidth(),
                                  child: Scrollbar(
                                    controller: _verticalController,
                                    thumbVisibility: true,
                                    child: SingleChildScrollView(
                                      controller: _verticalController,
                                      padding:
                                          const EdgeInsetsDirectional.all(12),
                                      child: SelectableText(
                                        widget.content,
                                        style: TextStyle(
                                          fontFamily: 'monospace',
                                          fontSize: widget.fontSize,
                                          height: 1.4,
                                          color: context.onBackground,
                                        ),
                                        textAlign: TextAlign.start,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),

        // Info bar
        Container(
          margin: const EdgeInsetsDirectional.only(top: 8),
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          decoration: BoxDecoration(
            color: context.isDark
                ? Colors.black.addOpacity(0.3)
                : Colors.grey.shade100,
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: context.onSurface.addOpacity(0.1),
            ),
          ),
          child: Row(
            children: [
              _buildInfoItem(
                context,
                icon: Icons.format_list_numbered,
                label: 'Lines',
                value: _totalLines.toString(),
              ),
              const SizedBox(width: 24),
              _buildInfoItem(
                context,
                icon: Icons.text_fields,
                label: 'Characters',
                value: _formatNumber(_totalCharacters),
              ),
              const Spacer(),
              // Action buttons
              if (widget.content.isNotEmpty) ...[
                _buildActionButton(
                  context,
                  icon: Icons.vertical_align_top,
                  tooltip: 'Scroll to top',
                  onPressed: () {
                    _verticalController.animateTo(
                      0,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                    widget.onScrollToTop?.call();
                  },
                ),
                const SizedBox(width: 8),
                _buildActionButton(
                  context,
                  icon: Icons.copy,
                  tooltip: 'Copy to clipboard (⌘+C after selecting)',
                  onPressed: widget.onCopy,
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildInfoItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 14,
          color: context.onSurface.addOpacity(0.5),
        ),
        const SizedBox(width: 6),
        Text(
          '$label: ',
          style: context.labelSmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
          ),
        ),
        Text(
          value,
          style: context.labelSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface.addOpacity(0.8),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: context.primary.addOpacity(0.1),
        foregroundColor: context.primary,
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  double _calculateLineNumberWidth() {
    if (!widget.showLineNumbers) return 0;

    final maxDigits = _totalLines.toString().length;
    // Calculate width based on number of digits + padding
    return (maxDigits * 10.0) + 24.0;
  }

  double _calculateTextWidth() {
    // Calculate the maximum line length to determine horizontal scroll width
    double maxLineWidth = 0;
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
    );

    for (final line in _lines) {
      textPainter
        ..text = TextSpan(
          text: line,
          style: TextStyle(
            fontFamily: 'monospace',
            fontSize: widget.fontSize,
            height: 1.4,
          ),
        )
        ..layout();
      maxLineWidth =
          maxLineWidth > textPainter.width ? maxLineWidth : textPainter.width;
    }

    // Add padding and minimum width
    return (maxLineWidth + 48).clamp(500, double.infinity);
  }

  String _formatNumber(int number) {
    if (number < 1000) return number.toString();
    if (number < 1000000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    }
    return '${(number / 1000000).toStringAsFixed(1)}M';
  }
}
```

### widgets/file_list_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../config/file_extensions.dart';
import '../extensions/theme_extensions.dart';
import '../models/file_item.dart';
import '../providers/file_collector_provider.dart';
import '../providers/settings_provider.dart';

class FileListWidget extends StatelessWidget {
  const FileListWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer2<FileCollectorProvider, SettingsProvider>(
      builder: (context, fileProvider, settingsProvider, child) {
        if (fileProvider.files.isEmpty) {
          return const Center(
            child: Text('No files added yet'),
          );
        }

        return ListView.builder(
          itemCount: fileProvider.files.length,
          itemBuilder: (context, index) {
            final file = fileProvider.files[index];
            return _FileListItem(
              file: file,
              activeExtensions: settingsProvider.activeExtensions,
              onToggle: () => fileProvider.toggleFileSelection(file),
              onRemove: () => fileProvider.removeFile(file),
            );
          },
        );
      },
    );
  }
}

class _FileListItem extends StatelessWidget {
  const _FileListItem({
    required this.file,
    required this.activeExtensions,
    required this.onToggle,
    required this.onRemove,
  });

  final FileItem file;
  final Map<String, FileCategory> activeExtensions;
  final VoidCallback onToggle;
  final VoidCallback onRemove;

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      margin: const EdgeInsetsDirectional.symmetric(
        horizontal: 12,
        vertical: 6,
      ),
      decoration: BoxDecoration(
        color: file.isSelected
            ? context.primary.addOpacity(0.05)
            : context.surface,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: file.isSelected
              ? context.primary.addOpacity(0.3)
              : context.outline.addOpacity(0.2),
          width: file.isSelected ? 1.5 : 1,
        ),
      ),
      child: Material(
        color: Colors.transparent,
        borderRadius: BorderRadius.circular(16),
        child: InkWell(
          onTap: onToggle,
          borderRadius: BorderRadius.circular(16),
          child: Padding(
            padding: const EdgeInsetsDirectional.all(16),
            child: Row(
              children: [
                _buildLeading(context),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildContent(context),
                ),
                const SizedBox(width: 12),
                _buildTrailing(context),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLeading(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          width: 24,
          height: 24,
          decoration: BoxDecoration(
            color: file.isSelected ? context.primary : context.surface,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: file.isSelected
                  ? context.primary
                  : context.outline.addOpacity(0.5),
              width: 2,
            ),
          ),
          child: file.isSelected
              ? const Icon(
                  Icons.check_rounded,
                  size: 14,
                  color: Colors.white,
                )
              : null,
        ),
        const SizedBox(width: 12),
        _buildFileIcon(context),
      ],
    );
  }

  Widget _buildContent(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          file.name,
          style: context.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 4),
        Text(
          file.fullPath,
          style: context.bodySmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
            fontFamily: 'monospace',
            fontSize: 11,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 8),
        SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: Row(
            children: [
              _buildStatusChip(context),
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsetsDirectional.symmetric(
                  horizontal: 8,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: context.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Text(
                  file.sizeFormatted,
                  style: context.labelSmall?.copyWith(
                    fontSize: 11,
                    color: context.onSurface.addOpacity(0.6),
                  ),
                ),
              ),
              if (file.getCategoryWithSettings(activeExtensions) != null) ...[
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsetsDirectional.symmetric(
                    horizontal: 8,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: context.primary.addOpacity(0.1),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Text(
                    file.extension,
                    style: context.labelSmall?.copyWith(
                      fontSize: 11,
                      fontFamily: 'monospace',
                      color: context.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTrailing(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (file.isLoading)
          Container(
            width: 32,
            height: 32,
            padding: const EdgeInsetsDirectional.all(8),
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: context.primary,
            ),
          )
        else if (file.error != null)
          IconButton(
            icon: Icon(
              Icons.error_outline_rounded,
              color: context.error,
            ),
            onPressed: () => _showErrorDialog(context),
            tooltip: 'Show error',
            style: IconButton.styleFrom(
              backgroundColor: context.error.addOpacity(0.1),
            ),
          )
        else if (file.content != null)
          Container(
            padding: const EdgeInsetsDirectional.all(6),
            decoration: BoxDecoration(
              color: context.primary.addOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.check_rounded,
              color: context.primary,
              size: 20,
            ),
          ),
        const SizedBox(width: 8),
        IconButton(
          icon: const Icon(Icons.close_rounded),
          onPressed: onRemove,
          tooltip: 'Remove file',
          style: IconButton.styleFrom(
            foregroundColor: context.error,
            backgroundColor: context.error.addOpacity(0.1),
          ),
        ),
      ],
    );
  }

  Widget _buildFileIcon(BuildContext context) {
    final category = file.getCategoryWithSettings(activeExtensions);
    final isSupported = file.isTextFileWithSettings(activeExtensions);

    if (!isSupported || category == null) {
      return Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: context.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(10),
        ),
        child: Icon(
          Icons.insert_drive_file_outlined,
          color: context.onSurface.addOpacity(0.5),
          size: 20,
        ),
      );
    }

    // Get specific icon and color based on extension
    IconData iconData = category.icon;
    Color iconColor = context.primary;
    Color bgColor = context.primary.addOpacity(0.1);

    // Special cases for popular extensions
    switch (file.extension.toLowerCase()) {
      case '.dart':
        iconData = Icons.flutter_dash;
        iconColor = const Color(0xFF0175C2);
        bgColor = iconColor.addOpacity(0.1);
      case '.py':
        iconColor = const Color(0xFF3776AB);
        bgColor = iconColor.addOpacity(0.1);
      case '.js':
      case '.ts':
        iconColor = const Color(0xFFF7DF1E);
        bgColor = const Color(0xFF323330);
      case '.html':
        iconColor = const Color(0xFFE34F26);
        bgColor = iconColor.addOpacity(0.1);
      case '.css':
        iconColor = const Color(0xFF1572B6);
        bgColor = iconColor.addOpacity(0.1);
      case '.json':
        iconData = Icons.data_object_rounded;
      case '.md':
        iconData = Icons.article_rounded;
      case '.yaml':
      case '.yml':
        iconData = Icons.settings_rounded;
      case '.sql':
        iconData = Icons.storage_rounded;
      case '.dockerfile':
        iconData = Icons.directions_boat_rounded;
        iconColor = const Color(0xFF2496ED);
        bgColor = iconColor.addOpacity(0.1);
    }

    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(10),
      ),
      child: Icon(
        iconData,
        color: iconColor,
        size: 22,
      ),
    );
  }

  Widget _buildStatusChip(BuildContext context) {
    if (file.isLoading) {
      return Chip(
        label: const Text('Loading...'),
        labelStyle: context.labelSmall,
        backgroundColor: context.primary.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    if (file.error != null) {
      return Chip(
        label: const Text('Error'),
        labelStyle: context.labelSmall?.copyWith(
          color: context.error,
        ),
        backgroundColor: context.error.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    if (file.content != null) {
      return Chip(
        label: const Text('Loaded'),
        labelStyle: context.labelSmall?.copyWith(
          color: context.primary,
        ),
        backgroundColor: context.primary.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    if (!file.isTextFileWithSettings(activeExtensions)) {
      return Chip(
        label: const Text('Not Supported'),
        labelStyle: context.labelSmall?.copyWith(
          color: context.onSurface.addOpacity(0.6),
        ),
        backgroundColor: context.onSurface.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    return Chip(
      label: const Text('Ready'),
      labelStyle: context.labelSmall,
      backgroundColor: context.surface,
      side: BorderSide(
        color: context.onSurface.addOpacity(0.2),
      ),
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
      visualDensity: VisualDensity.compact,
    );
  }

  Future<void> _showErrorDialog(BuildContext context) async {
    await showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.error_outline, color: context.error),
            const SizedBox(width: 8),
            const Text('File Error'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'File: ${file.name}',
              style: context.titleSmall?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Error: ${file.error}',
              style: context.bodyMedium,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}
```

### widgets/monaco_editor_embedded.dart
- Language: dart
```dart
import 'dart:convert';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';

import '../extensions/theme_extensions.dart';

class MonacoEditorEmbedded extends StatefulWidget {
  const MonacoEditorEmbedded({
    super.key,
    required this.content,
    this.onCopy,
    this.onScrollToTop,
    this.showLineNumbers = true,
    this.fontSize = 13,
    this.wordWrap = false,
    this.readOnly = true,
  });

  final String content;
  final VoidCallback? onCopy;
  final VoidCallback? onScrollToTop;
  final bool showLineNumbers;
  final double fontSize;
  final bool wordWrap;
  final bool readOnly;

  @override
  State<MonacoEditorEmbedded> createState() => _MonacoEditorEmbeddedState();
}

class _MonacoEditorEmbeddedState extends State<MonacoEditorEmbedded> {
  late WebViewController _controller;
  bool _isReady = false;
  bool _isLoading = true;
  String? _error;

  // Metrics
  int _totalLines = 0;
  int _totalCharacters = 0;

  @override
  void initState() {
    super.initState();
    _updateMetrics();
    _initWebView();
  }

  @override
  void didUpdateWidget(MonacoEditorEmbedded oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.content != widget.content) {
      _updateContent();
      _updateMetrics();
    }

    if (oldWidget.fontSize != widget.fontSize ||
        oldWidget.showLineNumbers != widget.showLineNumbers ||
        oldWidget.wordWrap != widget.wordWrap) {
      _updateOptions();
    }
  }

  void _updateMetrics() {
    setState(() {
      _totalLines = widget.content.split('\n').length;
      _totalCharacters = widget.content.length;
    });
  }

  Future<void> _initWebView() async {
    try {
      // Create WebViewController
      _controller = WebViewController()
        ..setJavaScriptMode(JavaScriptMode.unrestricted);

      // Don't set transparent background on macOS to avoid 'opaque is not implemented' error
      if (!Platform.isMacOS) {
        _controller.setBackgroundColor(Colors.transparent);
      }

      _controller.setNavigationDelegate(
        NavigationDelegate(
          onProgress: (int progress) {
            if (progress == 100) {
              setState(() {
                _isLoading = false;
              });
            }
          },
          onPageStarted: (String url) {},
          onPageFinished: (String url) {
            // Inject JavaScript to handle communication
            _controller.runJavaScript('''
                // Create a bridge for Flutter communication
                window.flutter_ready = true;
                
                // Override console methods to send messages to Flutter
                const originalLog = console.log;
                console.log = function(...args) {
                  originalLog.apply(console, args);
                  if (args[0] && args[0].startsWith('FLUTTER:')) {
                    window.location.href = 'flutter://' + encodeURIComponent(args[0]);
                  }
                };
              ''');
          },
          onWebResourceError: (WebResourceError error) {
            setState(() {
              _error = 'Failed to load editor: ${error.description}';
              _isLoading = false;
            });
          },
          onNavigationRequest: (NavigationRequest request) {
            // Handle custom protocol for Flutter communication
            if (request.url.startsWith('flutter://')) {
              final message = Uri.decodeFull(request.url.substring(10));
              _handleFlutterMessage(message);
              return NavigationDecision.prevent;
            }
            return NavigationDecision.navigate;
          },
        ),
      );

      // Load the HTML content
      await _loadHtmlContent();
    } catch (e) {
      setState(() {
        _error = 'Failed to initialize editor: $e';
        _isLoading = false;
      });
    }
  }

  void _handleFlutterMessage(String message) {
    if (message.startsWith('FLUTTER:')) {
      final command = message.substring(8);
      if (command == 'EDITOR_READY') {
        _onEditorReady();
      }
    }
  }

  Future<void> _loadHtmlContent() async {
    try {
      // Try to load the HTML from assets
      await _controller.loadFile('assets/editor/editor.html');
    } catch (e) {
      // Fall back to inline HTML if asset loading fails
      final htmlContent = _getInlineHtmlContent();
      await _controller.loadHtmlString(htmlContent);
    }
  }

  String _getInlineHtmlContent() {
    // This is a fallback HTML content in case the asset file can't be loaded
    return '''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com data:;">
    <title>Monaco Editor</title>
    <style>
        html, body, #container {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <script>
        // Check if online to use CDN
        const isOnline = navigator.onLine;
        var require = { paths: { 'vs': isOnline ? 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' : 'monaco/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.js"></script>
    
    <script>
        // Wait for Monaco to load
        require(['vs/editor/editor.main'], function() {
            // Create the editor
            window.editor = monaco.editor.create(document.getElementById('container'), {
                value: '// Loading content...',
                language: 'plaintext',
                theme: '${context.isDark ? 'vs-dark' : 'vs'}',
                fontSize: ${widget.fontSize},
                wordWrap: '${widget.wordWrap ? 'on' : 'off'}',
                minimap: { enabled: false },
                automaticLayout: true,
                fontFamily: 'JetBrains Mono, SF Mono, Monaco, Inconsolata, Fira Code, monospace',
                lineNumbers: '${widget.showLineNumbers ? 'on' : 'off'}',
                renderWhitespace: 'selection',
                scrollBeyondLastLine: false,
                smoothScrolling: true,
                cursorBlinking: 'smooth',
                cursorSmoothCaretAnimation: true,
                padding: { top: 10, bottom: 10 },
                readOnly: ${widget.readOnly}
            });

            // Universal notification function for cross-platform compatibility
            function notifyFlutter(handler, ...args) {
                if (window.chrome && window.chrome.webview) {
                    // For Windows WebView2
                    window.chrome.webview.postMessage({handler: handler, args: args});
                } else if (window.flutter_inappwebview) {
                    // For Flutter inappwebview on macOS/Linux
                    window.flutter_inappwebview.callHandler(handler, ...args);
                } else {
                    // Fallback using URL scheme
                    window.location.href = 'flutter://' + encodeURIComponent('FLUTTER:' + handler);
                }
            }

            // Expose methods for Flutter to call
            window.setEditorContent = function(content) {
                window.editor.setValue(content);
            };

            window.setEditorOptions = function(options) {
                window.editor.updateOptions(options);
            };

            window.setEditorLanguage = function(language) {
                monaco.editor.setModelLanguage(window.editor.getModel(), language);
            };

            window.getEditorContent = function() {
                return window.editor.getValue();
            };

            // Detect language from content
            window.detectAndSetLanguage = function() {
                const content = window.editor.getValue();
                let language = 'plaintext';
                
                // Simple language detection based on content patterns
                if (content.includes('import 'package:flutter') || content.includes('class ') && content.includes(' extends ')) {
                    language = 'dart';
                } else if (content.includes('import React') || content.includes('const ') || content.includes('function ')) {
                    language = 'javascript';
                } else if (content.includes('<!DOCTYPE html>') || content.includes('<html')) {
                    language = 'html';
                } else if (content.includes('def ') || content.includes('import ') && content.includes('from ')) {
                    language = 'python';
                } else if (content.includes('{') && content.includes('}') && content.includes(':')) {
                    language = 'json';
                }
                
                monaco.editor.setModelLanguage(window.editor.getModel(), language);
            };

            // Signal that editor is ready
            notifyFlutter('onEditorReady');
        });
    </script>
</body>
</html>
    ''';
  }

  void _onEditorReady() {
    setState(() {
      _isReady = true;
    });

    // Set initial content
    _updateContent();
  }

  void _updateContent() {
    if (!_isReady) return;

    final escapedContent = jsonEncode(widget.content);
    _controller.runJavaScript('''
      window.setEditorContent($escapedContent);
      window.detectAndSetLanguage();
    ''');
  }

  void _updateOptions() {
    if (!_isReady) return;

    final options = {
      'fontSize': widget.fontSize,
      'lineNumbers': widget.showLineNumbers ? 'on' : 'off',
      'wordWrap': widget.wordWrap ? 'on' : 'off',
      'readOnly': widget.readOnly,
      'theme': context.isDark ? 'vs-dark' : 'vs',
    };

    final optionsJson = jsonEncode(options);
    _controller.runJavaScript('window.setEditorOptions($optionsJson);');
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return _buildErrorView(context);
    }

    return Column(
      children: [
        // Main content area
        Expanded(
          child: Container(
            decoration: BoxDecoration(
              color: context.isDark
                  ? Colors.black.addOpacity(0.3)
                  : Colors.grey.shade50,
              border: Border.all(
                color: context.onSurface.addOpacity(0.1),
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: Stack(
                children: [
                  WebViewWidget(controller: _controller),
                  if (_isLoading)
                    ColoredBox(
                      color: context.surface,
                      child: const Center(
                        child: CircularProgressIndicator(),
                      ),
                    ),
                ],
              ),
            ),
          ),
        ),

        // Info bar
        _buildInfoBar(context),
      ],
    );
  }

  Widget _buildErrorView(BuildContext context) {
    return Center(
      child: Container(
        padding: const EdgeInsetsDirectional.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: context.error,
            ),
            const SizedBox(height: 16),
            Text(
              'Failed to load editor',
              style: context.titleLarge?.copyWith(
                color: context.error,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _error!,
              textAlign: TextAlign.center,
              style: context.bodyMedium?.copyWith(
                color: context.onSurface.addOpacity(0.6),
              ),
            ),
            const SizedBox(height: 24),
            OutlinedButton.icon(
              onPressed: () {
                setState(() {
                  _error = null;
                  _isLoading = true;
                });
                _initWebView();
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoBar(BuildContext context) {
    return Container(
      margin: const EdgeInsetsDirectional.only(top: 8),
      padding: const EdgeInsetsDirectional.symmetric(
        horizontal: 16,
        vertical: 8,
      ),
      decoration: BoxDecoration(
        color: context.isDark
            ? Colors.black.addOpacity(0.3)
            : Colors.grey.shade100,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: context.onSurface.addOpacity(0.1),
        ),
      ),
      child: Row(
        children: [
          _buildInfoItem(
            context,
            icon: Icons.format_list_numbered,
            label: 'Lines',
            value: _totalLines.toString(),
          ),
          const SizedBox(width: 24),
          _buildInfoItem(
            context,
            icon: Icons.text_fields,
            label: 'Characters',
            value: _formatNumber(_totalCharacters),
          ),
          const Spacer(),
          // Monaco indicator
          Container(
            padding: const EdgeInsetsDirectional.symmetric(
              horizontal: 12,
              vertical: 4,
            ),
            decoration: BoxDecoration(
              color: context.primary.addOpacity(0.1),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: context.primary.addOpacity(0.3),
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.code,
                  size: 14,
                  color: context.primary,
                ),
                const SizedBox(width: 6),
                Text(
                  'Monaco Editor',
                  style: context.labelSmall?.copyWith(
                    color: context.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 16),
          // Action buttons
          if (widget.content.isNotEmpty) ...[
            _buildActionButton(
              context,
              icon: Icons.vertical_align_top,
              tooltip: 'Scroll to top',
              onPressed: () {
                _controller.runJavaScript(
                    'window.editor.setScrollPosition({scrollTop: 0, scrollLeft: 0});');
                widget.onScrollToTop?.call();
              },
            ),
            const SizedBox(width: 8),
            _buildActionButton(
              context,
              icon: Icons.copy,
              tooltip: 'Copy to clipboard',
              onPressed: widget.onCopy,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 14,
          color: context.onSurface.addOpacity(0.5),
        ),
        const SizedBox(width: 6),
        Text(
          '$label: ',
          style: context.labelSmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
          ),
        ),
        Text(
          value,
          style: context.labelSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface.addOpacity(0.8),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: context.primary.addOpacity(0.1),
        foregroundColor: context.primary,
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  String _formatNumber(int number) {
    if (number < 1000) return number.toString();
    if (number < 1000000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    }
    return '${(number / 1000000).toStringAsFixed(1)}M';
  }
}
```

### widgets/monaco_editor_widget.dart
- Language: dart
```dart
import 'dart:convert';
import 'dart:io';

import 'package:desktop_webview_window/desktop_webview_window.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;

import '../extensions/theme_extensions.dart';

class MonacoEditorWidget extends StatefulWidget {
  const MonacoEditorWidget({
    super.key,
    required this.content,
    this.onCopy,
    this.onScrollToTop,
    this.showLineNumbers = true,
    this.fontSize = 13,
    this.wordWrap = false,
    this.readOnly = true,
  });

  final String content;
  final VoidCallback? onCopy;
  final VoidCallback? onScrollToTop;
  final bool showLineNumbers;
  final double fontSize;
  final bool wordWrap;
  final bool readOnly;

  @override
  State<MonacoEditorWidget> createState() => _MonacoEditorWidgetState();
}

class _MonacoEditorWidgetState extends State<MonacoEditorWidget> {
  Webview? _webview;
  bool _isReady = false;
  bool _isLoading = true;
  String? _error;

  // Metrics
  int _totalLines = 0;
  int _totalCharacters = 0;

  @override
  void initState() {
    super.initState();
    _initWebview();
    _updateMetrics();
  }

  @override
  void didUpdateWidget(MonacoEditorWidget oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.content != widget.content) {
      _updateContent();
      _updateMetrics();
    }

    if (oldWidget.fontSize != widget.fontSize ||
        oldWidget.showLineNumbers != widget.showLineNumbers ||
        oldWidget.wordWrap != widget.wordWrap) {
      _updateOptions();
    }
  }

  void _updateMetrics() {
    setState(() {
      _totalLines = widget.content.split('\n').length;
      _totalCharacters = widget.content.length;
    });
  }

  Future<void> _initWebview() async {
    try {
      // Check if WebView is available
      if (!await WebviewWindow.isWebviewAvailable()) {
        setState(() {
          _error =
              'WebView is not available. Please install Edge WebView2 Runtime.';
          _isLoading = false;
        });
        return;
      }

      // Create WebView window
      _webview = await WebviewWindow.create(
        configuration: CreateConfiguration(
          userDataFolderWindows: await _getWebViewDataPath(),
        ),
      );

      // Set up JavaScript handlers
      _webview!.addScriptToExecuteOnDocumentCreated('''
        window.flutter_inappwebview = {
          callHandler: function(handlerName, ...args) {
            window.chrome.webview.postMessage({
              handler: handlerName,
              args: args
            });
          }
        };
      ''');

      // Listen for messages from JavaScript
      _webview!.addOnWebMessageReceivedCallback((message) {
        try {
          final data = (jsonDecode(message) as Map<String, dynamic>?) ?? {};
          final handler = data['handler']?.toString() ?? '';
          final args = data['args'] as List<dynamic>?;

          switch (handler) {
            case 'onEditorReady':
              _onEditorReady();
            case 'onContentChanged':
              // Since we're in read-only mode, this shouldn't happen
              break;
          }
        } catch (e) {
          print('Error processing WebView message: $e');
        }
      });

      // Load the editor HTML
      final htmlPath = await _getEditorHtmlPath();
      _webview!.launch(htmlPath);
    } catch (e) {
      setState(() {
        _error = 'Failed to initialize editor: $e';
        _isLoading = false;
      });
    }
  }

  Future<String> _getWebViewDataPath() async {
    final appDir = Directory.current.path;
    final dataPath = path.join(appDir, 'webview_data');
    await Directory(dataPath).create(recursive: true);
    return dataPath;
  }

  Future<String> _getEditorHtmlPath() async {
    // In production, this would load from assets
    // For now, we'll create a temporary HTML file
    final tempDir = await Directory.systemTemp.createTemp('monaco_editor');
    final htmlFile = File(path.join(tempDir.path, 'editor.html'));

    // Copy the HTML content from assets
    final htmlContent =
        await rootBundle.loadString('assets/editor/editor.html');
    await htmlFile.writeAsString(htmlContent);

    return 'file://${htmlFile.path}';
  }

  void _onEditorReady() {
    setState(() {
      _isReady = true;
      _isLoading = false;
    });

    // Set initial content and options
    _updateContent();
    _updateOptions();
  }

  void _updateContent() {
    if (!_isReady || _webview == null) return;

    final escapedContent = jsonEncode(widget.content);
    _webview!.evaluateJavaScript('window.setEditorContent($escapedContent);');
  }

  void _updateOptions() {
    if (!_isReady || _webview == null) return;

    final options = {
      'fontSize': widget.fontSize,
      'lineNumbers': widget.showLineNumbers ? 'on' : 'off',
      'wordWrap': widget.wordWrap ? 'on' : 'off',
      'readOnly': widget.readOnly,
    };

    final optionsJson = jsonEncode(options);
    _webview!.evaluateJavaScript('window.setEditorOptions($optionsJson);');
  }

  @override
  void dispose() {
    _webview?.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return _buildErrorView(context);
    }

    if (_isLoading) {
      return _buildLoadingView(context);
    }

    return Column(
      children: [
        // Main content area
        Expanded(
          child: Container(
            decoration: BoxDecoration(
              color: context.isDark
                  ? Colors.black.addOpacity(0.3)
                  : Colors.grey.shade50,
              border: Border.all(
                color: context.onSurface.addOpacity(0.1),
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: const Center(
                child: Text(
                  'Monaco Editor is running in a separate window',
                  style: TextStyle(color: Colors.grey),
                ),
              ),
            ),
          ),
        ),

        // Info bar
        _buildInfoBar(context),
      ],
    );
  }

  Widget _buildLoadingView(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            'Loading Monaco Editor...',
            style: context.bodyLarge?.copyWith(
              color: context.onSurface.addOpacity(0.6),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorView(BuildContext context) {
    return Center(
      child: Container(
        padding: const EdgeInsetsDirectional.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: context.error,
            ),
            const SizedBox(height: 16),
            Text(
              'Failed to load editor',
              style: context.titleLarge?.copyWith(
                color: context.error,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _error!,
              textAlign: TextAlign.center,
              style: context.bodyMedium?.copyWith(
                color: context.onSurface.addOpacity(0.6),
              ),
            ),
            const SizedBox(height: 24),
            OutlinedButton.icon(
              onPressed: () {
                setState(() {
                  _error = null;
                  _isLoading = true;
                });
                _initWebview();
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoBar(BuildContext context) {
    return Container(
      margin: const EdgeInsetsDirectional.only(top: 8),
      padding: const EdgeInsetsDirectional.symmetric(
        horizontal: 16,
        vertical: 8,
      ),
      decoration: BoxDecoration(
        color: context.isDark
            ? Colors.black.addOpacity(0.3)
            : Colors.grey.shade100,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: context.onSurface.addOpacity(0.1),
        ),
      ),
      child: Row(
        children: [
          _buildInfoItem(
            context,
            icon: Icons.format_list_numbered,
            label: 'Lines',
            value: _totalLines.toString(),
          ),
          const SizedBox(width: 24),
          _buildInfoItem(
            context,
            icon: Icons.text_fields,
            label: 'Characters',
            value: _formatNumber(_totalCharacters),
          ),
          const Spacer(),
          // Action buttons
          if (widget.content.isNotEmpty) ...[
            _buildActionButton(
              context,
              icon: Icons.vertical_align_top,
              tooltip: 'Scroll to top',
              onPressed: () {
                _webview?.evaluateJavaScript(
                    'window.editor.setScrollPosition({scrollTop: 0, scrollLeft: 0});');
                widget.onScrollToTop?.call();
              },
            ),
            const SizedBox(width: 8),
            _buildActionButton(
              context,
              icon: Icons.copy,
              tooltip: 'Copy to clipboard',
              onPressed: widget.onCopy,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 14,
          color: context.onSurface.addOpacity(0.5),
        ),
        const SizedBox(width: 6),
        Text(
          '$label: ',
          style: context.labelSmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
          ),
        ),
        Text(
          value,
          style: context.labelSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface.addOpacity(0.8),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: context.primary.addOpacity(0.1),
        foregroundColor: context.primary,
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  String _formatNumber(int number) {
    if (number < 1000) return number.toString();
    if (number < 1000000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    }
    return '${(number / 1000000).toStringAsFixed(1)}M';
  }
}
```

