# Directory Analysis Report

Generated: 2025-05-24 12:40:49
Source: /Users/omarhanafy/scripts/context_collector/lib
Processing time: 0.01 seconds

## Directory Structure

```
└── lib
    ├── config
    │   └── file_extensions.dart
    ├── controllers
    │   └── monaco_controller.dart
    ├── extensions
    │   └── theme_extensions.dart
    ├── models
    │   ├── extension_settings.dart
    │   └── file_item.dart
    ├── providers
    │   ├── file_collector_provider.dart
    │   └── settings_provider.dart
    ├── screens
    │   ├── home_screen.dart
    │   └── settings_screen.dart
    ├── theme
    │   └── app_theme.dart
    ├── widgets
    │   ├── action_buttons_widget.dart
    │   ├── combined_content_widget.dart
    │   ├── drop_zone_widget.dart
    │   ├── editor_settings_dialog.dart
    │   ├── enhanced_text_editor.dart
    │   ├── file_list_widget.dart
    │   ├── monaco_editor_embedded.dart
    │   ├── monaco_editor_info_bar.dart
    │   ├── monaco_editor_widget.dart
    │   └── resizable_splitter.dart
    └── main.dart
```

## File Contents

### config/file_extensions.dart
- Language: dart
```dart
import 'package:flutter/material.dart';

class FileExtensionConfig {
  static const Map<String, FileCategory> extensionCategories = {
    // Programming Languages
    '.dart': FileCategory.programming,
    '.py': FileCategory.programming,
    '.js': FileCategory.programming,
    '.ts': FileCategory.programming,
    '.jsx': FileCategory.programming,
    '.tsx': FileCategory.programming,
    '.java': FileCategory.programming,
    '.kt': FileCategory.programming,
    '.swift': FileCategory.programming,
    '.cpp': FileCategory.programming,
    '.c': FileCategory.programming,
    '.h': FileCategory.programming,
    '.hpp': FileCategory.programming,
    '.cs': FileCategory.programming,
    '.php': FileCategory.programming,
    '.rb': FileCategory.programming,
    '.go': FileCategory.programming,
    '.rs': FileCategory.programming,
    '.scala': FileCategory.programming,
    '.r': FileCategory.programming,
    '.m': FileCategory.programming,
    '.mm': FileCategory.programming,
    '.lua': FileCategory.programming,
    '.pl': FileCategory.programming,
    '.ex': FileCategory.programming,
    '.exs': FileCategory.programming,
    '.elm': FileCategory.programming,
    '.clj': FileCategory.programming,
    '.coffee': FileCategory.programming,
    '.vb': FileCategory.programming,
    '.fs': FileCategory.programming,
    '.hs': FileCategory.programming,
    '.nim': FileCategory.programming,
    '.cr': FileCategory.programming,
    '.jl': FileCategory.programming,
    '.pas': FileCategory.programming,
    '.d': FileCategory.programming,
    '.zig': FileCategory.programming,
    '.v': FileCategory.programming,
    '.sol': FileCategory.programming,

    // Web Technologies
    '.html': FileCategory.web,
    '.htm': FileCategory.web,
    '.css': FileCategory.web,
    '.scss': FileCategory.web,
    '.sass': FileCategory.web,
    '.less': FileCategory.web,
    '.vue': FileCategory.web,
    '.svelte': FileCategory.web,
    '.astro': FileCategory.web,

    // Data & Config
    '.json': FileCategory.data,
    '.xml': FileCategory.data,
    '.yaml': FileCategory.data,
    '.yml': FileCategory.data,
    '.toml': FileCategory.data,
    '.ini': FileCategory.data,
    '.conf': FileCategory.data,
    '.cfg': FileCategory.data,
    '.properties': FileCategory.data,
    '.env': FileCategory.data,
    '.csv': FileCategory.data,
    '.tsv': FileCategory.data,
    '.plist': FileCategory.data,

    // Scripts
    '.sh': FileCategory.script,
    '.bash': FileCategory.script,
    '.zsh': FileCategory.script,
    '.fish': FileCategory.script,
    '.ps1': FileCategory.script,
    '.psm1': FileCategory.script,
    '.psd1': FileCategory.script,
    '.bat': FileCategory.script,
    '.cmd': FileCategory.script,
    '.vbs': FileCategory.script,
    '.ahk': FileCategory.script,

    // Documentation
    '.md': FileCategory.documentation,
    '.markdown': FileCategory.documentation,
    '.rst': FileCategory.documentation,
    '.adoc': FileCategory.documentation,
    '.asciidoc': FileCategory.documentation,
    '.tex': FileCategory.documentation,
    '.latex': FileCategory.documentation,
    '.txt': FileCategory.documentation,
    '.rtf': FileCategory.documentation,
    '.org': FileCategory.documentation,

    // Database
    '.sql': FileCategory.database,
    '.psql': FileCategory.database,
    '.mysql': FileCategory.database,
    '.sqlite': FileCategory.database,
    '.mongodb': FileCategory.database,
    '.cql': FileCategory.database,

    // DevOps & Build
    '.dockerfile': FileCategory.devops,
    '.containerfile': FileCategory.devops,
    '.makefile': FileCategory.devops,
    '.mk': FileCategory.devops,
    '.gradle': FileCategory.devops,
    '.groovy': FileCategory.devops,
    '.jenkinsfile': FileCategory.devops,
    '.travis.yml': FileCategory.devops,
    '.gitlab-ci.yml': FileCategory.devops,
    '.github': FileCategory.devops,
    '.circleci': FileCategory.devops,
    '.drone.yml': FileCategory.devops,

    // Other
    '.gitignore': FileCategory.other,
    '.gitattributes': FileCategory.other,
    '.editorconfig': FileCategory.other,
    '.prettierrc': FileCategory.other,
    '.eslintrc': FileCategory.other,
    '.stylelintrc': FileCategory.other,
    '.npmrc': FileCategory.other,
    '.nvmrc': FileCategory.other,
    '.rvmrc': FileCategory.other,
    '.ruby-version': FileCategory.other,
    '.python-version': FileCategory.other,
    '.node-version': FileCategory.other,
    '.tool-versions': FileCategory.other,
    '.babelrc': FileCategory.other,
    '.browserslistrc': FileCategory.other,
    '.huskyrc': FileCategory.other,
    '.lintstagedrc': FileCategory.other,
    '.commitlintrc': FileCategory.other,
    '.renovaterc': FileCategory.other,
    '.dependabot': FileCategory.other,
    '.log': FileCategory.other,
    '.lock': FileCategory.other,
    '.pid': FileCategory.other,
    '.cache': FileCategory.other,
    '.tmp': FileCategory.other,
    '.temp': FileCategory.other,
    '.bak': FileCategory.other,
    '.backup': FileCategory.other,
    '.old': FileCategory.other,
    '.orig': FileCategory.other,
    '.rej': FileCategory.other,
    '.diff': FileCategory.other,
    '.patch': FileCategory.other,
    '.pub': FileCategory.other,
    '.pem': FileCategory.other,
    '.key': FileCategory.other,
    '.crt': FileCategory.other,
    '.cer': FileCategory.other,
    '.p12': FileCategory.other,
    '.pfx': FileCategory.other,
    '.jks': FileCategory.other,
  };

  static Set<String> get supportedExtensions =>
      extensionCategories.keys.toSet();

  static bool isTextFile(String extension) {
    return extensionCategories.containsKey(extension.toLowerCase());
  }

  static FileCategory? getCategory(String extension) {
    return extensionCategories[extension.toLowerCase()];
  }
  
  // These will be used as fallbacks when settings provider is not available
  static bool isTextFileWithSettings(String extension, Map<String, FileCategory>? activeExtensions) {
    final ext = extension.toLowerCase();
    if (activeExtensions != null) {
      return activeExtensions.containsKey(ext);
    }
    return isTextFile(ext);
  }
  
  static FileCategory? getCategoryWithSettings(String extension, Map<String, FileCategory>? activeExtensions) {
    final ext = extension.toLowerCase();
    if (activeExtensions != null) {
      return activeExtensions[ext];
    }
    return getCategory(ext);
  }

  static List<String> getExtensionsByCategory(FileCategory category) {
    return extensionCategories.entries
        .where((entry) => entry.value == category)
        .map((entry) => entry.key)
        .toList()
      ..sort();
  }

  static Map<FileCategory, List<String>> getGroupedExtensions() {
    final Map<FileCategory, List<String>> grouped = {};

    for (final category in FileCategory.values) {
      final extensions = getExtensionsByCategory(category);
      if (extensions.isNotEmpty) {
        grouped[category] = extensions;
      }
    }

    return grouped;
  }
}

enum FileCategory {
  programming('Programming Languages', Icons.code),
  web('Web Technologies', Icons.web),
  data('Data & Config', Icons.data_object),
  script('Scripts', Icons.terminal),
  documentation('Documentation', Icons.description),
  database('Database', Icons.storage),
  devops('DevOps & Build', Icons.build_circle),
  other('Other', Icons.insert_drive_file);

  const FileCategory(this.displayName, this.icon);

  final String displayName;
  final IconData icon;
}
```

### controllers/monaco_controller.dart
- Language: dart
```dart
import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:webview_flutter/webview_flutter.dart';

/// Controller for managing Monaco Editor state and operations
class MonacoController extends ChangeNotifier {
  WebViewController? _webViewController;

  String _content = '';
  String _language = 'plaintext';
  String _theme = 'vs-dark';
  double _fontSize = 13;
  bool _wordWrap = false;
  bool _showLineNumbers = true;
  bool _readOnly = true;
  bool _isReady = false;

  // State tracking
  Map<String, dynamic>? _lastState;

  // Getters
  String get content => _content;
  String get language => _language;
  String get theme => _theme;
  double get fontSize => _fontSize;
  bool get wordWrap => _wordWrap;
  bool get showLineNumbers => _showLineNumbers;
  bool get readOnly => _readOnly;
  bool get isReady => _isReady;

  void attachWebView(WebViewController controller) {
    _webViewController = controller;
  }

  void detachWebView() {
    _webViewController = null;
    _isReady = false;
  }

  void markReady() {
    _isReady = true;
    if (_webViewController != null) {
      _pushContentToEditor();
      _pushOptionsToEditor();
    }
    notifyListeners();
  }

  /// Updates the editor content
  Future<void> setContent(String content, {bool preserveState = false}) async {
    if (_content == content) return;

    if (preserveState && _webViewController != null && _isReady) {
      await _saveEditorState();
    }

    _content = content;

    if (_webViewController != null && _isReady) {
      await _pushContentToEditor();

      if (preserveState && _lastState != null) {
        await _restoreEditorState();
      }
    }

    notifyListeners();
  }

  /// Gets the current editor content
  Future<String> getContent() async {
    if (_webViewController != null && _isReady) {
      try {
        final result = await _webViewController!.runJavaScriptReturningResult(
          'window.getEditorContent() || ""',
        );
        final content = result is String ? result : result.toString();
        // Remove quotes if present
        _content = content.replaceAll(RegExp(r'^"|"$'), '');
      } catch (e) {
        debugPrint('Error getting content: $e');
      }
    }
    return _content;
  }

  /// Sets the editor language
  Future<void> setLanguage(String language) async {
    if (_language == language) return;

    _language = language;

    if (_webViewController != null && _isReady) {
      await _webViewController!.runJavaScript(
        'window.setEditorLanguage("$language")',
      );
    }

    notifyListeners();
  }

  /// Sets the editor theme
  Future<void> setTheme(String theme) async {
    if (_theme == theme) return;

    _theme = theme;

    if (_webViewController != null && _isReady) {
      await _webViewController!.runJavaScript(
        'window.setEditorTheme("$theme")',
      );
    }

    notifyListeners();
  }

  /// Updates editor options
  Future<void> updateOptions({
    double? fontSize,
    bool? wordWrap,
    bool? showLineNumbers,
    bool? readOnly,
  }) async {
    var changed = false;

    if (fontSize != null && fontSize != _fontSize) {
      _fontSize = fontSize;
      changed = true;
    }

    if (wordWrap != null && wordWrap != _wordWrap) {
      _wordWrap = wordWrap;
      changed = true;
    }

    if (showLineNumbers != null && showLineNumbers != _showLineNumbers) {
      _showLineNumbers = showLineNumbers;
      changed = true;
    }

    if (readOnly != null && readOnly != _readOnly) {
      _readOnly = readOnly;
      changed = true;
    }

    if (changed) {
      await _pushOptionsToEditor();
      notifyListeners();
    }
  }

  /// Formats the document
  Future<void> format() async {
    if (_webViewController != null && _isReady) {
      await _webViewController!.runJavaScript(
        'window.editor?.getAction("editor.action.formatDocument")?.run()',
      );
    }
  }

  /// Finds text in the editor
  Future<void> find() async {
    if (_webViewController != null && _isReady) {
      await _webViewController!.runJavaScript(
        'window.editor?.getAction("actions.find")?.run()',
      );
    }
  }

  /// Goes to a specific line
  Future<void> goToLine(int line) async {
    if (_webViewController != null && _isReady) {
      await _webViewController!.runJavaScript(
        'if (window.editor) { window.editor.revealLineInCenter($line); window.editor.setPosition({ lineNumber: $line, column: 1 }); }',
      );
    }
  }

  /// Scrolls to top
  Future<void> scrollToTop() async {
    if (_webViewController != null && _isReady) {
      await _webViewController!.runJavaScript(
        'window.editor?.setScrollPosition({ scrollTop: 0, scrollLeft: 0 })',
      );
    }
  }

  // Private methods
  Future<void> _pushContentToEditor() async {
    if (_webViewController == null || !_isReady) return;

    final String escapedContent = json.encode(_content);
    await _webViewController!.runJavaScript(
      'window.setEditorContent($escapedContent)',
    );
  }

  Future<void> _pushOptionsToEditor() async {
    if (_webViewController == null || !_isReady) return;

    final options = {
      'fontSize': _fontSize,
      'wordWrap': _wordWrap ? 'on' : 'off',
      'lineNumbers': _showLineNumbers ? 'on' : 'off',
      'readOnly': _readOnly,
    };

    final String optionsJson = json.encode(options);
    await _webViewController!.runJavaScript(
      'window.setEditorOptions($optionsJson)',
    );
  }

  Future<void> _saveEditorState() async {
    try {
      // Save current state manually since original HTML doesn't have saveState method
      final stateJson = await _webViewController!.runJavaScriptReturningResult(
        '''
JSON.stringify({
          position: window.editor?.getPosition(),
          selection: window.editor?.getSelection(),
          scrollTop: window.editor?.getScrollTop(),
          scrollLeft: window.editor?.getScrollLeft()
        })''',
      ) as String;
      _lastState = json.decode(stateJson) as Map<String, dynamic>?;
    } catch (e) {
      debugPrint('Error saving editor state: $e');
      _lastState = null;
    }
  }

  Future<void> _restoreEditorState() async {
    if (_lastState == null || _webViewController == null || !_isReady) return;

    try {
      // Restore state manually
      await _webViewController!.runJavaScript('''
        if (window.editor) {
          const state = ${json.encode(_lastState)};
          if (state.position) {
            window.editor.setPosition(state.position);
          }
          if (state.selection) {
            window.editor.setSelection(state.selection);
          }
          if (state.scrollTop !== undefined) {
            window.editor.setScrollPosition({
              scrollTop: state.scrollTop,
              scrollLeft: state.scrollLeft || 0
            });
          }
        }
      ''');
    } catch (e) {
      debugPrint('Error restoring editor state: $e');
    }
  }

  @override
  void dispose() {
    _webViewController = null;
    super.dispose();
  }
}
```

### extensions/theme_extensions.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';

export 'package:flutter_helper_utils/flutter_helper_utils.dart';

/// Extension on BuildContext to provide convenient theme color access
extension ThemeColorsExtension on BuildContext {
  // ColorScheme colors
  Color get primary => themeData.primary;

  Color get onPrimary => themeData.onPrimary;

  Color get primaryContainer => themeData.primaryContainer;

  Color get onPrimaryContainer => themeData.onPrimaryContainer;

  Color get secondary => themeData.secondary;

  Color get onSecondary => themeData.onSecondary;

  Color get secondaryContainer => themeData.secondaryContainer;

  Color get onSecondaryContainer => themeData.onSecondaryContainer;

  Color get tertiary => themeData.tertiary;

  Color get onTertiary => themeData.onTertiary;

  Color get tertiaryContainer => themeData.tertiaryContainer;

  Color get onTertiaryContainer => themeData.onTertiaryContainer;

  Color get error => themeData.error;

  Color get onError => themeData.onError;

  Color get errorContainer => themeData.errorContainer;

  Color get onErrorContainer => themeData.onErrorContainer;

  Color get background => themeData.surface;

  Color get onBackground => themeData.onSurface;

  Color get surface => themeData.surface;

  Color get surfaceContainerHighest => themeData.surfaceContainerHighest;

  Color get onSurface => themeData.onSurface;

  Color get onSurfaceVariant => themeData.onSurfaceVariant;

  Color get outline => themeData.outline;

  Color get outlineVariant => themeData.outlineVariant;

  Color get shadow => themeData.shadow;

  Color get scrim => themeData.scrim;

  Color get inverseSurface => themeData.inverseSurface;

  Color get onInverseSurface => themeData.onInverseSurface;

  Color get inversePrimary => themeData.inversePrimary;

  Color get surfaceTint => themeData.surfaceTint;

  TextTheme get textTheme => themeData.textTheme;
}

/// Extension on BuildContext to provide convenient text style access
extension TextStylesExtension on BuildContext {
  // Display styles
  TextStyle? get displayLarge => textTheme.displayLarge;

  TextStyle? get displayMedium => textTheme.displayMedium;

  TextStyle? get displaySmall => textTheme.displaySmall;

  // Headline styles
  TextStyle? get headlineLarge => textTheme.headlineLarge;

  TextStyle? get headlineMedium => textTheme.headlineMedium;

  TextStyle? get headlineSmall => textTheme.headlineSmall;

  // Title styles
  TextStyle? get titleLarge => textTheme.titleLarge;

  TextStyle? get titleMedium => textTheme.titleMedium;

  TextStyle? get titleSmall => textTheme.titleSmall;

  // Label styles
  TextStyle? get labelLarge => textTheme.labelLarge;

  TextStyle? get labelMedium => textTheme.labelMedium;

  TextStyle? get labelSmall => textTheme.labelSmall;

  // Body styles
  TextStyle? get bodyLarge => textTheme.bodyLarge;

  TextStyle? get bodyMedium => textTheme.bodyMedium;

  TextStyle? get bodySmall => textTheme.bodySmall;

  // Copy methods for convenience (mirrors the fhu pattern)
  TextStyle? displayLargeCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      displayLarge?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );

  TextStyle? titleMediumCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      titleMedium?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );

  TextStyle? bodyMediumCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      bodyMedium?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );

  TextStyle? labelSmallCopy({
    Color? color,
    double? fontSize,
    FontWeight? fontWeight,
    double? height,
    double? letterSpacing,
  }) =>
      labelSmall?.copyWith(
        color: color,
        fontSize: fontSize,
        fontWeight: fontWeight,
        height: height,
        letterSpacing: letterSpacing,
      );
}
```

### main.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:window_manager/window_manager.dart';

import 'providers/file_collector_provider.dart';
import 'providers/settings_provider.dart';
import 'screens/home_screen.dart';
import 'theme/app_theme.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Configure window for desktop
  await windowManager.ensureInitialized();

  const WindowOptions windowOptions = WindowOptions(
    size: Size(1000, 700),
    minimumSize: Size(600, 400),
    center: true,
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.normal,
    title: 'Context Collector',
  );

  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    await windowManager.show();
    await windowManager.focus();
  });

  runApp(const ContextCollectorApp());
}

class ContextCollectorApp extends StatelessWidget {
  const ContextCollectorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => SettingsProvider()),
        ChangeNotifierProvider(create: (context) => FileCollectorProvider()),
      ],
      child: MaterialApp(
        title: 'Context Collector',
        theme: AppTheme.lightTheme,
        darkTheme: AppTheme.darkTheme,
        themeMode: ThemeMode.system,
        home: const HomeScreen(),
        debugShowCheckedModeBanner: false,
      ),
    );
  }
}
```

### models/extension_settings.dart
- Language: dart
```dart
import 'package:dart_helper_utils/dart_helper_utils.dart';
import 'package:flutter/cupertino.dart';

import '../config/file_extensions.dart';

@immutable
class ExtensionSettings {
  const ExtensionSettings({
    this.customExtensions = const {},
    this.disabledExtensions = const {},
  });

  factory ExtensionSettings.fromJson(Map<String, dynamic> json) {
    return ExtensionSettings(
      customExtensions: _parseCustomExtensions(json),
      disabledExtensions: _parseDisabledExtensions(json),
    );
  }

  factory ExtensionSettings.fromJsonString(String jsonString) {
    try {
      final decoded = jsonString.tryDecode();
      if (decoded == null) return const ExtensionSettings();

      return ExtensionSettings.fromJson(toMap<String, dynamic>(decoded));
    } catch (e) {
      return const ExtensionSettings();
    }
  }

  final Map<String, FileCategory> customExtensions;
  final Set<String> disabledExtensions;

  // Helper method to parse custom extensions using dart_helper_utils
  static Map<String, FileCategory> _parseCustomExtensions(
    Map<String, dynamic> json,
  ) {
    final customMap = json.tryGetMap<String, dynamic>('customExtensions');
    if (customMap == null) return const {};

    final result = <String, FileCategory>{};

    for (final entry in customMap.entries) {
      final categoryName = entry.value.toString();
      final category =
          FileCategory.values.firstWhereOrNull((c) => c.name == categoryName) ??
              FileCategory.other;

      result[entry.key] = category;
    }

    return result;
  }

  // Helper method to parse disabled extensions using dart_helper_utils
  static Set<String> _parseDisabledExtensions(Map<String, dynamic> json) {
    final disabledList = json.tryGetList<String>('disabledExtensions');
    return disabledList?.toSet() ?? const <String>{};
  }

  Map<String, dynamic> toJson() {
    return {
      'customExtensions': customExtensions.map(
        (key, value) => MapEntry(key, value.name),
      ),
      'disabledExtensions': disabledExtensions.toList(),
    };
  }

  ExtensionSettings copyWith({
    Map<String, FileCategory>? customExtensions,
    Set<String>? disabledExtensions,
  }) {
    return ExtensionSettings(
      customExtensions: customExtensions ?? this.customExtensions,
      disabledExtensions: disabledExtensions ?? this.disabledExtensions,
    );
  }

  // Get all active extensions (default + custom - disabled)
  Map<String, FileCategory> get activeExtensions {
    final result = Map<String, FileCategory>.from(
      FileExtensionConfig.extensionCategories,
    );

    // Remove disabled extensions
    for (final ext in disabledExtensions) {
      result.remove(ext);
    }

    // Add custom extensions (these override defaults)
    result.addAll(customExtensions);

    return result;
  }

  // Check if an extension is supported
  bool isSupported(String extension) {
    final ext = extension.toLowerCase();
    return activeExtensions.containsKey(ext);
  }

  // Get category for an extension
  FileCategory? getCategory(String extension) {
    final ext = extension.toLowerCase();
    return activeExtensions[ext];
  }

  // Additional utility methods

  /// Add a custom extension mapping
  ExtensionSettings addCustomExtension(
      String extension, FileCategory category) {
    final newCustom = Map<String, FileCategory>.from(customExtensions);
    newCustom[extension.toLowerCase()] = category;
    return copyWith(customExtensions: newCustom);
  }

  /// Remove a custom extension mapping
  ExtensionSettings removeCustomExtension(String extension) {
    final newCustom = Map<String, FileCategory>.from(customExtensions)
      ..remove(extension.toLowerCase());
    return copyWith(customExtensions: newCustom);
  }

  /// Disable an extension
  ExtensionSettings disableExtension(String extension) {
    final newDisabled = Set<String>.from(disabledExtensions)
      ..add(extension.toLowerCase());
    return copyWith(disabledExtensions: newDisabled);
  }

  /// Enable a previously disabled extension
  ExtensionSettings enableExtension(String extension) {
    final newDisabled = Set<String>.from(disabledExtensions)
      ..remove(extension.toLowerCase());
    return copyWith(disabledExtensions: newDisabled);
  }

  /// Get all extensions for a specific category
  Set<String> getExtensionsForCategory(FileCategory category) {
    return activeExtensions.entries
        .where((entry) => entry.value == category)
        .map((entry) => entry.key)
        .toSet();
  }

  /// Check if any extensions are configured for a category
  bool hasCategorySupport(FileCategory category) {
    return activeExtensions.values.contains(category);
  }

  /// Get statistics about the configuration
  Map<String, int> get statistics {
    final stats = <String, int>{};

    // Count by category
    for (final category in FileCategory.values) {
      final count =
          activeExtensions.values.where((cat) => cat == category).length;
      if (count > 0) {
        stats[category.name] = count;
      }
    }

    stats['total'] = activeExtensions.length;
    stats['custom'] = customExtensions.length;
    stats['disabled'] = disabledExtensions.length;

    return stats;
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is ExtensionSettings &&
        other.customExtensions.length == customExtensions.length &&
        other.disabledExtensions.length == disabledExtensions.length &&
        other.customExtensions.entries.every(
          (entry) => customExtensions[entry.key] == entry.value,
        ) &&
        other.disabledExtensions.every(disabledExtensions.contains);
  }

  @override
  int get hashCode {
    return Object.hash(
      customExtensions.entries
          .map((e) => Object.hash(e.key, e.value))
          .fold(0, (a, b) => a is num ? a.toInt() ^ b : 0),
      disabledExtensions.fold(
          0, (a, b) => a is num ? a.toInt() ^ b.hashCode : 0),
    );
  }

  @override
  String toString() {
    return 'ExtensionSettings('
        'customExtensions: ${customExtensions.length}, '
        'disabledExtensions: ${disabledExtensions.length}, '
        'totalActive: ${activeExtensions.length}'
        ')';
  }
}
```

### models/file_item.dart
- Language: dart
```dart
import 'dart:io';

import 'package:flutter/cupertino.dart';
import 'package:path/path.dart' as path;

import '../config/file_extensions.dart';

@immutable
class FileItem {
  const FileItem({
    required this.name,
    required this.fullPath,
    required this.extension,
    required this.size,
    required this.lastModified,
    this.content,
    this.isSelected = true,
    this.isLoading = false,
    this.error,
  });

  factory FileItem.fromFile(File file) {
    final stat = file.statSync();
    return FileItem(
      name: path.basename(file.path),
      fullPath: file.path,
      extension: path.extension(file.path).toLowerCase(),
      size: stat.size,
      lastModified: stat.modified,
    );
  }

  final String name;
  final String fullPath;
  final String extension;
  final int size;
  final DateTime lastModified;
  final String? content;
  final bool isSelected;
  final bool isLoading;
  final String? error;

  String get sizeFormatted {
    if (size < 1024) return '${size}B';
    if (size < 1024 * 1024) return '${(size / 1024).toStringAsFixed(1)}KB';
    if (size < 1024 * 1024 * 1024) {
      return '${(size / (1024 * 1024)).toStringAsFixed(1)}MB';
    }
    return '${(size / (1024 * 1024 * 1024)).toStringAsFixed(1)}GB';
  }

  bool get isTextFile => FileExtensionConfig.isTextFile(extension);

  FileCategory? get category => FileExtensionConfig.getCategory(extension);
  
  bool isTextFileWithSettings(Map<String, FileCategory>? activeExtensions) {
    return FileExtensionConfig.isTextFileWithSettings(extension, activeExtensions);
  }
  
  FileCategory? getCategoryWithSettings(Map<String, FileCategory>? activeExtensions) {
    return FileExtensionConfig.getCategoryWithSettings(extension, activeExtensions);
  }

  Future<FileItem> loadContent({Map<String, FileCategory>? activeExtensions}) async {
    final isSupported = activeExtensions != null 
        ? isTextFileWithSettings(activeExtensions)
        : isTextFile;
        
    if (!isSupported) {
      return copyWith(
        error: 'File type not supported for text extraction',
        isLoading: false,
      );
    }

    try {
      final file = File(fullPath);
      if (!file.existsSync()) {
        return copyWith(
          error: 'File not found',
          isLoading: false,
        );
      }

      final fileContent = await file.readAsString();
      return copyWith(
        content: fileContent,
        isLoading: false,
        error: null,
      );
    } catch (e) {
      return copyWith(
        error: 'Error reading file: $e',
        content: null,
        isLoading: false,
      );
    }
  }

  String generateReference() {
    return '// File: $fullPath\n// Size: $sizeFormatted\n// Modified: ${lastModified.toIso8601String()}\n';
  }

  FileItem copyWith({
    String? name,
    String? fullPath,
    String? extension,
    int? size,
    DateTime? lastModified,
    String? content,
    bool? isSelected,
    bool? isLoading,
    String? error,
  }) {
    return FileItem(
      name: name ?? this.name,
      fullPath: fullPath ?? this.fullPath,
      extension: extension ?? this.extension,
      size: size ?? this.size,
      lastModified: lastModified ?? this.lastModified,
      content: content ?? this.content,
      isSelected: isSelected ?? this.isSelected,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is FileItem && other.fullPath == fullPath;
  }

  @override
  int get hashCode => fullPath.hashCode;
}
```

### providers/file_collector_provider.dart
- Language: dart
```dart
import 'dart:io';

import 'package:file_selector/file_selector.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;

import '../config/file_extensions.dart';
import '../models/file_item.dart';
import 'settings_provider.dart';

class FileCollectorProvider with ChangeNotifier {
  final List<FileItem> _files = [];
  bool _isProcessing = false;
  String? _error;
  String _combinedContent = '';
  SettingsProvider? _settingsProvider;

  List<FileItem> get files => List.unmodifiable(_files);
  bool get isProcessing => _isProcessing;
  String? get error => _error;
  String get combinedContent => _combinedContent;

  List<FileItem> get selectedFiles =>
      _files.where((f) => f.isSelected).toList();

  int get selectedFilesCount => selectedFiles.length;
  int get totalFilesCount => _files.length;

  bool get hasFiles => _files.isNotEmpty;
  bool get hasSelectedFiles => selectedFiles.isNotEmpty;

  set settingsProvider(SettingsProvider settingsProvider) {
    _settingsProvider = settingsProvider;
  }

  Map<String, FileCategory>? get _activeExtensions =>
      _settingsProvider?.activeExtensions;

  void addFiles(List<String> filePaths) {
    _error = null;
    bool newFilesAdded = false;

    for (final filePath in filePaths) {
      final file = File(filePath);
      if (file.existsSync()) {
        final fileItem = FileItem.fromFile(file);
        if (!_files.contains(fileItem)) {
          _files.add(fileItem); // By default, isSelected is true in FileItem
          newFilesAdded = true;
        }
      }
    }

    if (newFilesAdded) {
      notifyListeners();
      _updateCombinedContent(); // Update content for newly added files (references)
      loadFileContents(); // Automatically load content for new files
    } else {
      notifyListeners(); // Still notify if no new files but paths were processed
    }
  }

  Future<void> addDirectory(String directoryPath) async {
    _error = null;
    bool newFilesAdded = false;
    try {
      final directory = Directory(directoryPath);
      if (!directory.existsSync()) {
        _error = 'Directory not found: $directoryPath';
        notifyListeners();
        return;
      }

      final activeExtensions =
          _activeExtensions ?? FileExtensionConfig.extensionCategories;
      final foundFilePaths = <String>[];

      await for (final entity
          in directory.list(recursive: true, followLinks: false)) {
        if (entity is File) {
          final extension = path.extension(entity.path).toLowerCase();
          if (activeExtensions.containsKey(extension)) {
            foundFilePaths.add(entity.path);
          }
        }
      }

      if (foundFilePaths.isNotEmpty) {
        // Temporarily collect files to check which are truly new
        final tempNewFiles = <FileItem>[];
        for (final filePath in foundFilePaths) {
          final file = File(filePath);
          if (file.existsSync()) {
            final fileItem = FileItem.fromFile(file);
            if (!_files.contains(fileItem)) {
              tempNewFiles.add(fileItem);
            }
          }
        }

        if (tempNewFiles.isNotEmpty) {
          _files.addAll(tempNewFiles);
          newFilesAdded = true;
        }
      }
    } catch (e) {
      _error = 'Error scanning directory: $e';
    }

    if (newFilesAdded) {
      notifyListeners();
      _updateCombinedContent();
      await loadFileContents(); // Automatically load content
    } else {
      notifyListeners(); // Notify for errors or if no new files were found
    }
  }

  void removeFile(FileItem fileItem) {
    _files.remove(fileItem);
    notifyListeners();
    _updateCombinedContent();
  }

  void clearFiles() {
    _files.clear();
    _combinedContent = '';
    _error = null;
    notifyListeners();
  }

  void toggleFileSelection(FileItem fileItem) {
    final index = _files.indexOf(fileItem);
    if (index != -1) {
      _files[index] = fileItem.copyWith(isSelected: !fileItem.isSelected);
      notifyListeners();
      _updateCombinedContent();
    }
  }

  void selectAll() {
    for (int i = 0; i < _files.length; i++) {
      _files[i] = _files[i].copyWith(isSelected: true);
    }
    notifyListeners();
    _updateCombinedContent();
  }

  void deselectAll() {
    for (int i = 0; i < _files.length; i++) {
      _files[i] = _files[i].copyWith(isSelected: false);
    }
    notifyListeners();
    _updateCombinedContent();
  }

  Future<void> loadFileContents() async {
    // Only process files that are selected, have no content, and are not already loading
    final filesToLoad = _files
        .where((f) => f.isSelected && f.content == null && !f.isLoading)
        .toList();

    if (filesToLoad.isEmpty) return;

    _isProcessing = true;
    _error = null;
    notifyListeners();

    try {
      bool contentChanged = false;
      for (final fileToLoad in filesToLoad) {
        final index = _files.indexOf(fileToLoad);
        if (index != -1) {
          // Should always be true here
          _files[index] = _files[index].copyWith(isLoading: true);
          // No need to notify here, will notify after each load or batch at end

          final updatedFile = await _files[index].loadContent(
            activeExtensions: _activeExtensions,
          );
          _files[index] = updatedFile;
          if (updatedFile.content != null || updatedFile.error != null) {
            contentChanged = true;
          }
          notifyListeners(); // Notify after each file is processed to update UI progressively
        }
      }

      if (contentChanged) {
        _updateCombinedContent(); // This will re-generate the combined text
      }
    } catch (e) {
      _error = 'Error loading files: $e';
    } finally {
      _isProcessing = false;
      notifyListeners(); // Final notification for isProcessing and any errors
    }
  }

  void _updateCombinedContent() {
    final buffer = StringBuffer()
      ..writeln('# Context Collection')
      ..writeln('Generated on: ${DateTime.now().toIso8601String()}')
      ..writeln('Total selected files: ${selectedFiles.length}')
      ..writeln();

    for (final file in selectedFiles) {
      buffer
        ..writeln('=' * 80)
        ..writeln(file.generateReference())
        ..writeln('=' * 80);

      if (file.isLoading) {
        buffer.writeln('LOADING CONTENT...');
      } else if (file.content != null) {
        buffer.writeln(file.content);
      } else if (file.error != null) {
        buffer.writeln('ERROR: ${file.error}');
      } else if (!file.isTextFileWithSettings(_activeExtensions)) {
        buffer.writeln('SKIPPED: Binary file');
      } else {
        buffer.writeln('PENDING: Content not loaded (or file is empty)');
      }

      buffer
        ..writeln()
        ..writeln();
    }

    _combinedContent = buffer.toString();
  }

  Future<void> copyToClipboard() async {
    if (_combinedContent.isEmpty) {
      await loadFileContents();
    }

    try {
      await Clipboard.setData(ClipboardData(text: _combinedContent));
    } catch (e) {
      _error = 'Error copying to clipboard: $e';
      notifyListeners();
    }
  }

  Future<void> saveToFile() async {
    if (_combinedContent.isEmpty) {
      await loadFileContents();
    }

    try {
      final fileName =
          'context_collection_${DateTime.now().millisecondsSinceEpoch}.txt';

      final filePath = await getSaveLocation(
        suggestedName: fileName,
        acceptedTypeGroups: [
          const XTypeGroup(
            label: 'Text files',
            extensions: ['txt'],
          ),
        ],
      );

      if (filePath != null) {
        final file = File(filePath.path);
        await file.writeAsString(_combinedContent);
      }
    } catch (e) {
      _error = 'Error saving file: $e';
      notifyListeners();
    }
  }

  Future<void> pickFiles() async {
    try {
      final List<XFile> files = await openFiles(
        acceptedTypeGroups: [
          const XTypeGroup(
            label: 'Text files',
            extensions: <String>[
              'txt',
              'dart',
              'py',
              'js',
              'ts',
              'jsx',
              'tsx',
              'java',
              'kt',
              'swift',
              'cpp',
              'c',
              'h',
              'hpp',
              'cs',
              'php',
              'rb',
              'go',
              'rs',
              'html',
              'css',
              'scss',
              'json',
              'xml',
              'yaml',
              'yml',
              'md',
              'sql'
            ],
          ),
          const XTypeGroup(
            label: 'All files',
          ),
        ],
      );

      if (files.isNotEmpty) {
        final filePaths = files.map((file) => file.path).toList();
        addFiles(filePaths);
      }
    } catch (e) {
      _error = 'Error picking files: $e';
      notifyListeners();
    }
  }

  Future<void> pickDirectory() async {
    try {
      final String? directoryPath = await getDirectoryPath();

      if (directoryPath != null) {
        await addDirectory(directoryPath);
      }
    } catch (e) {
      _error = 'Error picking directory: $e';
      notifyListeners();
    }
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }
}
```

### providers/settings_provider.dart
- Language: dart
```dart
import 'package:context_collector/extensions/theme_extensions.dart';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../config/file_extensions.dart';
import '../models/extension_settings.dart';

class SettingsProvider with ChangeNotifier {
  SettingsProvider() {
    _loadSettings();
  }

  static const String _prefsKey = 'extension_settings';

  ExtensionSettings _settings = const ExtensionSettings();
  bool _isLoading = true;

  ExtensionSettings get settings => _settings;

  bool get isLoading => _isLoading;

  // Get all active extensions
  Map<String, FileCategory> get activeExtensions => _settings.activeExtensions;

  // Get all available extensions grouped by category
  Map<FileCategory, List<MapEntry<String, bool>>> get groupedExtensions {
    final result = <FileCategory, List<MapEntry<String, bool>>>{};

    // Add default extensions
    for (final entry in FileExtensionConfig.extensionCategories.entries) {
      final category = entry.value;
      final isEnabled = !_settings.disabledExtensions.contains(entry.key);

      result.putIfAbsent(category, () => []);
      result[category]!.add(MapEntry(entry.key, isEnabled));
    }

    // Add custom extensions
    for (final entry in _settings.customExtensions.entries) {
      final category = entry.value;

      result.putIfAbsent(category, () => []);
      result[category]!.add(MapEntry(entry.key, true));
    }

    // Sort extensions within each category
    for (final list in result.values) {
      list.sort((a, b) => a.key.compareTo(b.key));
    }

    return result;
  }

  Future<void> _loadSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final settingsJson = prefs.getString(_prefsKey);

      if (settingsJson != null) {
        _settings = ExtensionSettings.fromJsonString(settingsJson);
      }
    } catch (e) {
      debugPrint('Error loading settings: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _saveSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_prefsKey, _settings.encode());
    } catch (e) {
      debugPrint('Error saving settings: $e');
    }
  }

  // Toggle extension enabled/disabled state
  Future<void> toggleExtension(String extension) async {
    final isDefault =
        FileExtensionConfig.extensionCategories.containsKey(extension);

    if (isDefault) {
      // For default extensions, add/remove from disabled list
      final newDisabled = Set<String>.from(_settings.disabledExtensions);

      if (newDisabled.contains(extension)) {
        newDisabled.remove(extension);
      } else {
        newDisabled.add(extension);
      }

      _settings = _settings.copyWith(disabledExtensions: newDisabled);
    } else {
      // For custom extensions, remove from custom list
      final newCustom =
          Map<String, FileCategory>.from(_settings.customExtensions)
            ..remove(extension);

      _settings = _settings.copyWith(customExtensions: newCustom);
    }

    await _saveSettings();
    notifyListeners();
  }

  // Add a custom extension
  Future<void> addCustomExtension(
      String extension, FileCategory category) async {
    if (extension.isEmpty || !extension.startsWith('.')) {
      throw ArgumentError('Invalid extension format');
    }

    final ext = extension.toLowerCase();

    // Check if it already exists
    if (FileExtensionConfig.extensionCategories.containsKey(ext) ||
        _settings.customExtensions.containsKey(ext)) {
      throw ArgumentError('Extension already exists');
    }

    final newCustom =
        Map<String, FileCategory>.from(_settings.customExtensions);
    newCustom[ext] = category;

    // Remove from disabled if it was there
    final newDisabled = Set<String>.from(_settings.disabledExtensions)
      ..remove(ext);

    _settings = _settings.copyWith(
      customExtensions: newCustom,
      disabledExtensions: newDisabled,
    );

    await _saveSettings();
    notifyListeners();
  }

  // Reset to default settings
  Future<void> resetToDefaults() async {
    _settings = const ExtensionSettings();
    await _saveSettings();
    notifyListeners();
  }

  // Enable all extensions
  Future<void> enableAll() async {
    _settings = _settings.copyWith(disabledExtensions: {});
    await _saveSettings();
    notifyListeners();
  }

  // Disable all extensions (except custom ones)
  Future<void> disableAll() async {
    _settings = _settings.copyWith(
      disabledExtensions: FileExtensionConfig.extensionCategories.keys.toSet(),
    );
    await _saveSettings();
    notifyListeners();
  }
}
```

### screens/home_screen.dart
- Language: dart
```dart
import 'dart:io';

import 'package:desktop_drop/desktop_drop.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../extensions/theme_extensions.dart';
import '../providers/file_collector_provider.dart';
import '../providers/settings_provider.dart';
import '../widgets/action_buttons_widget.dart';
import '../widgets/combined_content_widget.dart';
import '../widgets/drop_zone_widget.dart';
import '../widgets/file_list_widget.dart';
import '../widgets/resizable_splitter.dart';
import 'settings_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool _isDragging = false;

  @override
  void initState() {
    super.initState();
    // Connect the settings provider to file collector provider
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final fileProvider = context.read<FileCollectorProvider>();
      final settingsProvider = context.read<SettingsProvider>();
      fileProvider.settingsProvider = settingsProvider;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: context.surface,
      appBar: AppBar(
        title: Row(
          children: [
            Container(
              padding: const EdgeInsetsDirectional.all(8),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [
                    context.primary,
                    context.primary.addOpacity(0.8),
                  ],
                ),
                borderRadius: BorderRadius.circular(10),
              ),
              child: const Icon(
                Icons.collections_bookmark_rounded,
                color: Colors.white,
                size: 20,
              ),
            ),
            const SizedBox(width: 12),
            const Text('Context Collector'),
          ],
        ),
        actions: [
          Consumer<FileCollectorProvider>(
            builder: (context, provider, child) {
              return Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  AnimatedContainer(
                    duration: const Duration(milliseconds: 300),
                    padding: provider.hasFiles
                        ? const EdgeInsetsDirectional.symmetric(
                            horizontal: 12,
                            vertical: 6,
                          )
                        : EdgeInsetsDirectional.zero,
                    decoration: BoxDecoration(
                      color: provider.hasFiles
                          ? context.primary.addOpacity(0.1)
                          : Colors.transparent,
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: provider.hasFiles
                        ? Row(
                            children: [
                              Icon(
                                Icons.check_circle_rounded,
                                size: 16,
                                color: context.primary,
                              ),
                              const SizedBox(width: 6),
                              Text(
                                '${provider.selectedFilesCount}',
                                style: context.titleSmall?.copyWith(
                                  color: context.primary,
                                  fontWeight: FontWeight.w700,
                                ),
                              ),
                              Text(
                                ' / ${provider.totalFilesCount}',
                                style: context.titleSmall?.copyWith(
                                  color: context.onSurface.addOpacity(0.6),
                                ),
                              ),
                            ],
                          )
                        : const SizedBox.shrink(),
                  ),
                  if (provider.hasFiles) const SizedBox(width: 8),
                  AnimatedScale(
                    scale: provider.hasFiles ? 1.0 : 0.0,
                    duration: const Duration(milliseconds: 200),
                    child: IconButton(
                      onPressed: provider.hasFiles ? provider.clearFiles : null,
                      icon: const Icon(Icons.clear_all_rounded),
                      tooltip: 'Clear all files',
                      style: IconButton.styleFrom(
                        backgroundColor: context.error.addOpacity(0.1),
                        foregroundColor: context.error,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                ],
              );
            },
          ),
          IconButton(
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute<void>(
                  builder: (context) => const SettingsScreen(),
                ),
              );
            },
            icon: const Icon(Icons.settings_rounded),
            tooltip: 'Settings',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: DropTarget(
        onDragEntered: (details) {
          setState(() => _isDragging = true);
        },
        onDragExited: (details) {
          setState(() => _isDragging = false);
        },
        onDragDone: (details) async {
          setState(() => _isDragging = false);
          final provider = context.read<FileCollectorProvider>();

          final files = <String>[];
          final directories = <String>[];

          // Separate files and directories
          for (final file in details.files) {
            // final entity = await FileSystemEntity.type(file.path);
            final entity = FileSystemEntity.typeSync(file.path);
            if (entity == FileSystemEntityType.file) {
              files.add(file.path);
            } else if (entity == FileSystemEntityType.directory) {
              directories.add(file.path);
            }
          }

          // Add files first
          if (files.isNotEmpty) {
            provider.addFiles(files);
          }

          // Add directories
          for (final directory in directories) {
            await provider.addDirectory(directory);
          }
        },
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          decoration: BoxDecoration(
            color: _isDragging
                ? context.primary.addOpacity(0.1)
                : Colors.transparent,
            border: _isDragging
                ? Border.all(
                    color: context.primary.addOpacity(0.5),
                    width: 2,
                  )
                : null,
          ),
          child: Consumer<FileCollectorProvider>(
            builder: (context, provider, child) {
              if (provider.error != null) {
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(provider.error!),
                      backgroundColor: context.error,
                      action: SnackBarAction(
                        label: 'Dismiss',
                        onPressed: provider.clearError,
                        textColor: context.onError,
                      ),
                    ),
                  );
                  provider.clearError();
                });
              }

              if (!provider.hasFiles) {
                return const DropZoneWidget();
              }

              return ResizableSplitter(
                initialRatio: 0.35,
                minRatio: 0.2,
                maxRatio: 0.6,
                startPanel: Column(
                  children: [
                    const ActionButtonsWidget(),
                    const Expanded(child: FileListWidget()),
                    if (provider.isProcessing)
                      const LinearProgressIndicator(),
                  ],
                ),
                endPanel: const CombinedContentWidget(),
              );
            },
          ),
        ),
      ),
    );
  }
}
```

### screens/settings_screen.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../config/file_extensions.dart';
import '../extensions/theme_extensions.dart';
import '../providers/settings_provider.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final _extensionController = TextEditingController();
  FileCategory _selectedCategory = FileCategory.other;
  final _formKey = GlobalKey<FormState>();

  @override
  void dispose() {
    _extensionController.dispose();
    super.dispose();
  }

  Future<void> _showAddExtensionDialog(
      BuildContext context, SettingsProvider provider) async {
    await showDialog<void>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Add Custom Extension'),
        content: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: _extensionController,
                decoration: const InputDecoration(
                  labelText: 'Extension',
                  hintText: '.example',
                  prefixIcon: Icon(Icons.extension_rounded),
                ),
                inputFormatters: [
                  // Ensure it starts with a dot
                  TextInputFormatter.withFunction((oldValue, newValue) {
                    final text = newValue.text;
                    if (text.isEmpty) return newValue;
                    if (!text.startsWith('.')) {
                      return TextEditingValue(
                        text: '.$text',
                        selection:
                            TextSelection.collapsed(offset: text.length + 1),
                      );
                    }
                    return newValue;
                  }),
                ],
                validator: (value) {
                  if (value == null || value.isEmpty || value == '.') {
                    return 'Please enter a valid extension';
                  }
                  if (!value.startsWith('.')) {
                    return 'Extension must start with a dot';
                  }
                  if (provider.activeExtensions
                      .containsKey(value.toLowerCase())) {
                    return 'Extension already exists';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<FileCategory>(
                value: _selectedCategory,
                decoration: const InputDecoration(
                  labelText: 'Category',
                  prefixIcon: Icon(Icons.category_rounded),
                ),
                items: FileCategory.values.map((category) {
                  return DropdownMenuItem(
                    value: category,
                    child: Row(
                      children: [
                        Icon(category.icon, size: 20),
                        const SizedBox(width: 8),
                        Text(category.displayName),
                      ],
                    ),
                  );
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    setState(() => _selectedCategory = value);
                  }
                },
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              if (_formKey.currentState!.validate()) {
                try {
                  await provider.addCustomExtension(
                    _extensionController.text.toLowerCase(),
                    _selectedCategory,
                  );
                  if (mounted) {
                    Navigator.pop(dialogContext);
                    _extensionController.clear();
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Extension added successfully'),
                      ),
                    );
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('Error: $e'),
                        backgroundColor: context.error,
                      ),
                    );
                  }
                }
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Extension Settings'),
        actions: [
          Consumer<SettingsProvider>(
            builder: (context, provider, child) {
              return PopupMenuButton<String>(
                icon: const Icon(Icons.more_vert_rounded),
                onSelected: (value) async {
                  switch (value) {
                    case 'enable_all':
                      await provider.enableAll();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('All extensions enabled'),
                          ),
                        );
                      }
                    case 'disable_all':
                      await provider.disableAll();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('All default extensions disabled'),
                          ),
                        );
                      }
                    case 'reset':
                      await showDialog<void>(
                        context: context,
                        builder: (dialogContext) => AlertDialog(
                          title: const Text('Reset to Defaults'),
                          content: const Text(
                            'This will remove all custom extensions and reset all settings to default. Are you sure?',
                          ),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(dialogContext),
                              child: const Text('Cancel'),
                            ),
                            FilledButton(
                              onPressed: () async {
                                await provider.resetToDefaults();
                                if (mounted) {
                                  Navigator.pop(dialogContext);
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                      content:
                                          Text('Settings reset to defaults'),
                                    ),
                                  );
                                }
                              },
                              style: FilledButton.styleFrom(
                                backgroundColor: context.error,
                              ),
                              child: const Text('Reset'),
                            ),
                          ],
                        ),
                      );
                  }
                },
                itemBuilder: (context) => [
                  const PopupMenuItem(
                    value: 'enable_all',
                    child: Row(
                      children: [
                        Icon(Icons.check_circle_outline_rounded),
                        SizedBox(width: 12),
                        Text('Enable All'),
                      ],
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'disable_all',
                    child: Row(
                      children: [
                        Icon(Icons.remove_circle_outline_rounded),
                        SizedBox(width: 12),
                        Text('Disable All Default'),
                      ],
                    ),
                  ),
                  const PopupMenuDivider(),
                  const PopupMenuItem(
                    value: 'reset',
                    child: Row(
                      children: [
                        Icon(Icons.restore_rounded),
                        SizedBox(width: 12),
                        Text('Reset to Defaults'),
                      ],
                    ),
                  ),
                ],
              );
            },
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: Consumer<SettingsProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          final groupedExtensions = provider.groupedExtensions;

          return Column(
            children: [
              Container(
                padding: const EdgeInsetsDirectional.all(16),
                color: context.surfaceContainerHighest,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Customize Supported File Extensions',
                      style: context.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Enable or disable file extensions for context collection. You can also add custom extensions.',
                      style: context.bodyMedium?.copyWith(
                        color: context.onSurface.addOpacity(0.7),
                      ),
                    ),
                    const SizedBox(height: 16),
                    FilledButton.icon(
                      onPressed: () =>
                          _showAddExtensionDialog(context, provider),
                      icon: const Icon(Icons.add_rounded),
                      label: const Text('Add Custom Extension'),
                    ),
                  ],
                ),
              ),
              Expanded(
                child: ListView.builder(
                  padding: const EdgeInsetsDirectional.all(16),
                  itemCount: groupedExtensions.length,
                  itemBuilder: (context, index) {
                    final category = groupedExtensions.keys.elementAt(index);
                    final extensions = groupedExtensions[category]!;
                    final enabledCount =
                        extensions.where((e) => e.value).length;

                    return Card(
                      margin: const EdgeInsetsDirectional.only(bottom: 16),
                      child: ExpansionTile(
                        leading: Icon(category.icon),
                        title: Text(category.displayName),
                        subtitle: Text(
                          '$enabledCount of ${extensions.length} enabled',
                          style: context.bodySmall?.copyWith(
                            color: context.onSurface.addOpacity(0.6),
                          ),
                        ),
                        children: [
                          const Divider(height: 1),
                          Padding(
                            padding: const EdgeInsetsDirectional.all(8),
                            child: Wrap(
                              spacing: 8,
                              runSpacing: 8,
                              children: extensions.map((entry) {
                                final extension = entry.key;
                                final isEnabled = entry.value;
                                final isCustom = provider
                                    .settings.customExtensions
                                    .containsKey(extension);

                                return FilterChip(
                                  label: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text(extension),
                                      if (isCustom) ...[
                                        const SizedBox(width: 4),
                                        Icon(
                                          Icons.star_rounded,
                                          size: 14,
                                          color: context.primary,
                                        ),
                                      ],
                                    ],
                                  ),
                                  selected: isEnabled,
                                  onSelected: (_) async {
                                    await provider.toggleExtension(extension);
                                  },
                                  showCheckmark: true,
                                  deleteIcon: isCustom
                                      ? const Icon(Icons.close_rounded,
                                          size: 18)
                                      : null,
                                  onDeleted: isCustom
                                      ? () async {
                                          await provider
                                              .toggleExtension(extension);
                                        }
                                      : null,
                                );
                              }).toList(),
                            ),
                          ),
                        ],
                      ),
                    );
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}
```

### theme/app_theme.dart
- Language: dart
```dart
// ignore_for_file: unused_field
import 'package:flutter/material.dart';

class AppTheme {
  // Modern color palette inspired by modern design systems
  static const Color _primaryColor = Color(0xFF5B47E0); // Modern purple
  static const Color _primaryVariant = Color(0xFF4936C9);
  static const Color _secondaryColor = Color(0xFF00D4AA); // Mint green
  static const Color _accentColor = Color(0xFFFF6B6B); // Coral red
  static const Color _surfaceColor = Color(0xFFF7F9FC); // Cool gray
  static const Color _backgroundColor = Color(0xFFFCFDFF); // Almost white
  static const Color _errorColor = Color(0xFFFF4757);
  static const Color _successColor = Color(0xFF00D4AA);
  static const Color _warningColor = Color(0xFFFFA502);
  static const Color _infoColor = Color(0xFF54A0FF);

  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: const ColorScheme.light(
        primary: _primaryColor,
        secondary: _secondaryColor,
        tertiary: _accentColor,
        surface: _surfaceColor,
        error: _errorColor,
        onPrimary: Colors.white,
        onSecondary: Colors.white,
        onSurface: Color(0xFF1A1C1E),
        onError: Colors.white,
        surfaceContainerHighest: Color(0xFFE8EDF5),
        outline: Color(0xFFE0E5ED),
        outlineVariant: Color(0xFFF0F3F7),
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: _backgroundColor,
        foregroundColor: Color(0xFF1A1C1E),
        titleTextStyle: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.w700,
          color: Color(0xFF1A1C1E),
          letterSpacing: -0.5,
        ),
        iconTheme: IconThemeData(
          color: Color(0xFF1A1C1E),
          size: 22,
        ),
      ),
      cardTheme: CardTheme(
        elevation: 0,
        color: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: const BorderSide(
            color: Color(0xFFE8EDF5),
            width: 1,
          ),
        ),
        margin: const EdgeInsetsDirectional.all(6),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          backgroundColor: _primaryColor,
          foregroundColor: Colors.white,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          side: const BorderSide(
            color: Color(0xFFE8EDF5),
            width: 1.5,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6),
        ),
        fillColor: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return _primaryColor;
          }
          return null;
        }),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: const Color(0xFFF7F9FC),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _primaryColor, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _errorColor, width: 1.5),
        ),
        contentPadding: const EdgeInsetsDirectional.symmetric(
          horizontal: 16,
          vertical: 14,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: Color(0xFFE8EDF5),
        thickness: 1,
        space: 0,
      ),
      iconTheme: const IconThemeData(
        size: 20,
      ),
      progressIndicatorTheme: const ProgressIndicatorThemeData(
        color: _primaryColor,
      ),
      snackBarTheme: SnackBarThemeData(
        backgroundColor: const Color(0xFF1A1C1E),
        contentTextStyle: const TextStyle(
          color: Colors.white,
          fontSize: 14,
          fontWeight: FontWeight.w500,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        behavior: SnackBarBehavior.floating,
        elevation: 4,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: const ColorScheme.dark(
        primary: _primaryColor,
        secondary: _secondaryColor,
        tertiary: _accentColor,
        surface: Color(0xFF1C1E21),
        error: _errorColor,
        onPrimary: Colors.white,
        onSecondary: Colors.white,
        onSurface: Color(0xFFE1E3E8),
        onError: Colors.white,
        surfaceContainerHighest: Color(0xFF262A2F),
        outline: Color(0xFF3A3F47),
        outlineVariant: Color(0xFF2C3036),
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        backgroundColor: Color(0xFF16181B),
        foregroundColor: Color(0xFFE1E3E8),
        titleTextStyle: TextStyle(
          fontSize: 22,
          fontWeight: FontWeight.w700,
          color: Color(0xFFE1E3E8),
          letterSpacing: -0.5,
        ),
        iconTheme: IconThemeData(
          color: Color(0xFFE1E3E8),
          size: 22,
        ),
      ),
      cardTheme: CardTheme(
        elevation: 0,
        color: const Color(0xFF262A2F),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: const BorderSide(
            color: Color(0xFF3A3F47),
            width: 1,
          ),
        ),
        margin: const EdgeInsetsDirectional.all(6),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          elevation: 0,
          backgroundColor: _primaryColor,
          foregroundColor: Colors.white,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 20,
            vertical: 12,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          side: const BorderSide(
            color: Color(0xFF3A3F47),
            width: 1.5,
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: _primaryColor,
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          textStyle: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
      ),
      checkboxTheme: CheckboxThemeData(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6),
        ),
        fillColor: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return _primaryColor;
          }
          return null;
        }),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: const Color(0xFF262A2F),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _primaryColor, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: _errorColor, width: 1.5),
        ),
        contentPadding: const EdgeInsetsDirectional.symmetric(
          horizontal: 16,
          vertical: 14,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: Color(0xFF3A3F47),
        thickness: 1,
        space: 0,
      ),
      iconTheme: const IconThemeData(
        size: 20,
      ),
      progressIndicatorTheme: const ProgressIndicatorThemeData(
        color: _primaryColor,
      ),
      snackBarTheme: SnackBarThemeData(
        backgroundColor: const Color(0xFF2C3036),
        contentTextStyle: const TextStyle(
          color: Color(0xFFE1E3E8),
          fontSize: 14,
          fontWeight: FontWeight.w500,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        behavior: SnackBarBehavior.floating,
        elevation: 4,
      ),
    );
  }
}
```

### widgets/action_buttons_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../extensions/theme_extensions.dart';
import '../providers/file_collector_provider.dart';

class ActionButtonsWidget extends StatelessWidget {
  const ActionButtonsWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<FileCollectorProvider>(
      builder: (context, provider, child) {
        return Container(
          padding: const EdgeInsetsDirectional.all(20),
          decoration: BoxDecoration(
            color: context.background,
            border: BorderDirectional(
              bottom: BorderSide(
                color: context.outline.addOpacity(0.2),
                width: 1,
              ),
            ),
          ),
          child: Column(
            children: [
              // File selection controls
              Container(
                padding: const EdgeInsetsDirectional.symmetric(
                  horizontal: 16,
                  vertical: 12,
                ),
                decoration: BoxDecoration(
                  color: context.surface,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: context.outline.addOpacity(0.2),
                  ),
                ),
                child: Row(
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.folder_copy_rounded,
                          size: 20,
                          color: context.primary,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          'Files',
                          style: context.titleMedium?.copyWith(
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsetsDirectional.symmetric(
                            horizontal: 10,
                            vertical: 4,
                          ),
                          decoration: BoxDecoration(
                            color: context.primary.addOpacity(0.1),
                            borderRadius: BorderRadius.circular(20),
                          ),
                          child: Text(
                            '${provider.selectedFilesCount} / ${provider.totalFilesCount}',
                            style: context.labelSmall?.copyWith(
                              color: context.primary,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const Spacer(),
                    Container(
                      decoration: BoxDecoration(
                        color: context.surfaceContainerHighest,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Material(
                            color: Colors.transparent,
                            borderRadius: const BorderRadiusDirectional.only(
                              topStart: Radius.circular(8),
                              bottomStart: Radius.circular(8),
                            ),
                            child: InkWell(
                              onTap: provider.totalFilesCount > 0
                                  ? provider.selectAll
                                  : null,
                              borderRadius: const BorderRadius.only(
                                topLeft: Radius.circular(8),
                                bottomLeft: Radius.circular(8),
                              ),
                              child: Container(
                                padding: const EdgeInsetsDirectional.symmetric(
                                  horizontal: 12,
                                  vertical: 6,
                                ),
                                child: Row(
                                  children: [
                                    Icon(
                                      Icons.done_all_rounded,
                                      size: 16,
                                      color: provider.totalFilesCount > 0
                                          ? context.primary
                                          : context.onSurface.addOpacity(0.3),
                                    ),
                                    const SizedBox(width: 4),
                                    Text(
                                      'All',
                                      style: context.labelMedium?.copyWith(
                                        color: provider.totalFilesCount > 0
                                            ? context.primary
                                            : context.onSurface.addOpacity(0.3),
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ),
                          Container(
                            width: 1,
                            height: 24,
                            color: context.outline.addOpacity(0.2),
                          ),
                          Material(
                            color: Colors.transparent,
                            borderRadius: const BorderRadiusDirectional.only(
                              topEnd: Radius.circular(8),
                              bottomEnd: Radius.circular(8),
                            ),
                            child: InkWell(
                              onTap: provider.selectedFilesCount > 0
                                  ? provider.deselectAll
                                  : null,
                              borderRadius: const BorderRadius.only(
                                topRight: Radius.circular(8),
                                bottomRight: Radius.circular(8),
                              ),
                              child: Container(
                                padding: const EdgeInsetsDirectional.symmetric(
                                  horizontal: 12,
                                  vertical: 6,
                                ),
                                child: Row(
                                  children: [
                                    Icon(
                                      Icons.remove_done_rounded,
                                      size: 16,
                                      color: provider.selectedFilesCount > 0
                                          ? context.onSurface.addOpacity(0.6)
                                          : context.onSurface.addOpacity(0.3),
                                    ),
                                    const SizedBox(width: 4),
                                    Text(
                                      'None',
                                      style: context.labelMedium?.copyWith(
                                        color: provider.selectedFilesCount > 0
                                            ? context.onSurface.addOpacity(0.6)
                                            : context.onSurface.addOpacity(0.3),
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 16),

              // Action buttons grid
              // All buttons removed as per user request, relying on drag-and-drop and CombinedContentWidget actions.
              // If any buttons are needed here in the future, they can be re-added.
              const SizedBox.shrink(),
              // No buttons left in this section
            ],
          ),
        );
      },
    );
  }
}
```

### widgets/combined_content_widget.dart
- Language: dart
```dart
import 'package:context_collector/widgets/monaco_editor_embedded.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../controllers/monaco_controller.dart';
import '../extensions/theme_extensions.dart';
import '../providers/file_collector_provider.dart';
import 'editor_settings_dialog.dart';
import 'monaco_editor_info_bar.dart';

class CombinedContentWidget extends StatefulWidget {
  const CombinedContentWidget({super.key});

  @override
  State<CombinedContentWidget> createState() => _CombinedContentWidgetState();
}

class _CombinedContentWidgetState extends State<CombinedContentWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _collapseController;
  late Animation<double> _collapseAnimation;
  late MonacoController _monacoController;
  bool _isCollapsed = false;
  EditorSettings _editorSettings = const EditorSettings();

  @override
  void initState() {
    super.initState();
    _collapseController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _collapseAnimation = CurvedAnimation(
      parent: _collapseController,
      curve: Curves.easeInOut,
    );
    _collapseController.value = 1.0; // Start expanded

    // Initialize Monaco controller
    _monacoController = MonacoController();

    _loadEditorSettings();
  }

  Future<void> _loadEditorSettings() async {
    final settings = await EditorSettings.load();
    if (mounted) {
      setState(() {
        _editorSettings = settings;
      });

      // Apply settings to Monaco controller
      await _monacoController.updateOptions(
        fontSize: settings.fontSize,
        wordWrap: settings.wordWrap,
        showLineNumbers: settings.showLineNumbers,
      );
    }
  }

  @override
  void dispose() {
    _collapseController.dispose();
    _monacoController.dispose();
    super.dispose();
  }

  void _toggleCollapse() {
    setState(() {
      _isCollapsed = !_isCollapsed;
      if (_isCollapsed) {
        _collapseController.reverse();
      } else {
        _collapseController.forward();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<FileCollectorProvider>(
      builder: (context, provider, child) {
        return Column(
          children: [
            // Header with collapse button
            Container(
              padding: const EdgeInsetsDirectional.symmetric(
                horizontal: 16,
                vertical: 12,
              ),
              decoration: BoxDecoration(
                color: context.surface,
                border: BorderDirectional(
                  bottom: BorderSide(
                    color: context.onSurface.addOpacity(0.1),
                  ),
                ),
                boxShadow: [
                  BoxShadow(
                    color: context.onSurface.addOpacity(0.05),
                    offset: const Offset(0, 1),
                    blurRadius: 3,
                  ),
                ],
              ),
              child: Row(
                children: [
                  // Collapse/Expand button
                  _buildCollapseButton(context),
                  const SizedBox(width: 12),

                  // Title with icon
                  Icon(
                    Icons.merge_type_rounded,
                    size: 20,
                    color: context.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    'Combined Content',
                    style: context.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),

                  // File count badge
                  if (provider.selectedFilesCount > 0) ...[
                    const SizedBox(width: 12),
                    Container(
                      padding: const EdgeInsetsDirectional.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: context.primary.addOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                          color: context.primary.addOpacity(0.3),
                        ),
                      ),
                      child: Text(
                        '${provider.selectedFilesCount} files',
                        style: context.labelSmall?.copyWith(
                          color: context.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],

                  const Spacer(),

                  // Settings button (for font size, theme, etc.)
                  IconButton(
                    onPressed: () => _showEditorSettings(context),
                    icon: const Icon(Icons.settings_outlined),
                    iconSize: 20,
                    tooltip: 'Editor settings',
                    style: IconButton.styleFrom(
                      foregroundColor: context.onSurface.addOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),

            // Content area
            Expanded(
              child: AnimatedBuilder(
                animation: _collapseAnimation,
                builder: (context, child) {
                  return Row(
                    children: [
                      // Collapsed sidebar
                      AnimatedContainer(
                        duration: const Duration(milliseconds: 300),
                        width: _isCollapsed ? 48 : 0,
                        child: _isCollapsed
                            ? _buildCollapsedSidebar(context, provider)
                            : const SizedBox.shrink(),
                      ),

                      // Main content
                      Expanded(
                        child: SizeTransition(
                          sizeFactor: _collapseAnimation,
                          axis: Axis.horizontal,
                          child: Container(
                            margin: const EdgeInsetsDirectional.all(16),
                            child: _buildContent(context, provider),
                          ),
                        ),
                      ),
                    ],
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildCollapseButton(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: _toggleCollapse,
        borderRadius: BorderRadius.circular(6),
        child: Container(
          padding: const EdgeInsetsDirectional.all(6),
          decoration: BoxDecoration(
            border: Border.all(
              color: context.onSurface.addOpacity(0.2),
            ),
            borderRadius: BorderRadius.circular(6),
          ),
          child: AnimatedRotation(
            turns: _isCollapsed ? 0.5 : 0,
            duration: const Duration(milliseconds: 300),
            child: Icon(
              Icons.chevron_left,
              size: 18,
              color: context.onSurface.addOpacity(0.7),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildCollapsedSidebar(
      BuildContext context, FileCollectorProvider provider) {
    return Container(
      decoration: BoxDecoration(
        color: context.isDark
            ? Colors.black.addOpacity(0.3)
            : Colors.grey.shade100,
        border: BorderDirectional(
          end: BorderSide(
            color: context.onSurface.addOpacity(0.1),
          ),
        ),
      ),
      child: Column(
        children: [
          const SizedBox(height: 16),
          IconButton(
            onPressed: _toggleCollapse,
            icon: const Icon(Icons.chevron_right),
            tooltip: 'Expand editor',
          ),
          const SizedBox(height: 24),
          if (provider.combinedContent.isNotEmpty) ...[
            IconButton(
              onPressed: () =>
                  _copyToClipboard(context, provider.combinedContent),
              icon: const Icon(Icons.copy),
              tooltip: 'Copy content',
            ),
            const SizedBox(height: 16),
            RotatedBox(
              quarterTurns: -1,
              child: Text(
                '${provider.selectedFilesCount} files',
                style: context.labelSmall?.copyWith(
                  color: context.onSurface.addOpacity(0.6),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildContent(BuildContext context, FileCollectorProvider provider) {
    if (provider.combinedContent.isEmpty) {
      return _buildEmptyState(context);
    }

    // Update controller content when provider changes
    if (_monacoController.content != provider.combinedContent) {
      _monacoController.setContent(provider.combinedContent);
    }

    return Column(
      children: [
        // Editor
        Expanded(
          child: MonacoEditorEmbedded(
            controller: _monacoController,
            onReady: () async {
              // Editor is ready, ensure content is set after a small delay
              await 100.millisecondsDelay();
              await _monacoController.setContent(provider.combinedContent);
            },
          ),
        ),

        // Info bar with controls
        MonacoEditorInfoBar(
          controller: _monacoController,
          onCopy: () => _copyToClipboard(context, provider.combinedContent),
          onSettings: () => _showEditorSettings(context),
        ),
      ],
    );
  }

  Widget _buildEmptyState(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsetsDirectional.all(24),
            decoration: BoxDecoration(
              color: context.primary.addOpacity(0.05),
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.merge_type_rounded,
              size: 64,
              color: context.primary.addOpacity(0.3),
            ),
          ),
          const SizedBox(height: 24),
          Text(
            'Combined Content Preview',
            style: context.titleLarge?.copyWith(
              color: context.onSurface.addOpacity(0.8),
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Select files and load their content to see the combined result here',
            textAlign: TextAlign.center,
            style: context.bodyMedium?.copyWith(
              color: context.onSurface.addOpacity(0.6),
            ),
          ),
          const SizedBox(height: 32),

          // Quick tips
          Container(
            padding: const EdgeInsetsDirectional.all(20),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [
                  context.primary.addOpacity(0.05),
                  context.primary.addOpacity(0.02),
                ],
                begin: AlignmentDirectional.topStart,
                end: AlignmentDirectional.bottomEnd,
              ),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: context.primary.addOpacity(0.2),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(
                      Icons.lightbulb_outline,
                      size: 20,
                      color: context.primary,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      'Quick Tips',
                      style: context.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: context.primary,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                _buildTip(
                  context,
                  '• Drag and drop files or folders directly onto the app',
                ),
                _buildTip(
                  context,
                  '• Use the action buttons to load, copy, or save content',
                ),
                _buildTip(
                  context,
                  '• Toggle file selection to customize your collection',
                ),
                _buildTip(
                  context,
                  '• Line numbers help navigate large combined files',
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTip(BuildContext context, String text) {
    return Padding(
      padding: const EdgeInsetsDirectional.only(bottom: 4),
      child: Text(
        text,
        style: context.bodySmall?.copyWith(
          color: context.onSurface.addOpacity(0.7),
          height: 1.5,
        ),
      ),
    );
  }

  void _copyToClipboard(BuildContext context, String content) {
    Clipboard.setData(ClipboardData(text: content)).then((_) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              Icon(
                Icons.check_circle,
                color: context.onPrimary,
                size: 20,
              ),
              const SizedBox(width: 8),
              const Text('Content copied to clipboard!'),
            ],
          ),
          backgroundColor: context.primary,
          behavior: SnackBarBehavior.floating,
          duration: const Duration(seconds: 2),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      );
    }).catchError((dynamic error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error copying to clipboard: $error'),
          backgroundColor: context.error,
        ),
      );
    });
  }

  Future<void> _showEditorSettings(BuildContext context) async {
    final newSettings = await EditorSettingsDialog.show(
      context,
      _editorSettings,
    );

    if (newSettings != null && mounted) {
      setState(() {
        _editorSettings = newSettings;
      });

      // Apply new settings to Monaco controller
      await _monacoController.updateOptions(
        fontSize: newSettings.fontSize,
        wordWrap: newSettings.wordWrap,
        showLineNumbers: newSettings.showLineNumbers,
      );
    }
  }
}
```

### widgets/drop_zone_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';

import '../config/file_extensions.dart';
import '../extensions/theme_extensions.dart';

class DropZoneWidget extends StatelessWidget {
  const DropZoneWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        margin: const EdgeInsetsDirectional.all(32),
        padding: const EdgeInsetsDirectional.all(64),
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            maxWidth: 600,
          ),
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Icon container with gradient background
                Container(
                  width: 120,
                  height: 120,
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        context.primary.addOpacity(0.1),
                        context.primary.addOpacity(0.05),
                      ],
                      begin: AlignmentDirectional.topStart,
                      end: AlignmentDirectional.bottomEnd,
                    ),
                    borderRadius: BorderRadius.circular(30),
                  ),
                  child: Icon(
                    Icons.folder_open_rounded,
                    size: 56,
                    color: context.primary,
                  ),
                ),
                const SizedBox(height: 32),
                Text(
                  'Drop Your Files or Directories Here',
                  style: context.displaySmall?.copyWith(
                    color: context.onSurface,
                    fontWeight: FontWeight.w800,
                    letterSpacing: -1,
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  'Drag and drop files or directories to combine their content\ninto a single, organized collection',
                  textAlign: TextAlign.center,
                  style: context.bodyLarge?.copyWith(
                    color: context.onSurface.addOpacity(0.6),
                    height: 1.5,
                  ),
                ),
                const SizedBox(height: 40),
                _buildSecondaryButton(context),
                const SizedBox(height: 48),
                _buildFeatureGrid(context),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSecondaryButton(BuildContext context) {
    return OutlinedButton.icon(
      onPressed: () => _showSupportedFormats(context),
      icon: const Icon(Icons.help_outline_rounded),
      label: const Text('Supported Formats'),
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsetsDirectional.symmetric(
          horizontal: 24,
          vertical: 16,
        ),
        textStyle: const TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Widget _buildFeatureGrid(BuildContext context) {
    final features = [
      (
        icon: Icons.code_rounded,
        title: 'All Text Files',
        description:
            'Support for ${FileExtensionConfig.supportedExtensions.length}+ file types',
      ),
      (
        icon: Icons.link_rounded,
        title: 'File References',
        description: 'Includes path & metadata',
      ),
      (
        icon: Icons.content_copy_rounded,
        title: 'Quick Copy',
        description: 'One-click clipboard copy',
      ),
      (
        icon: Icons.save_alt_rounded,
        title: 'Export Ready',
        description: 'Save as text file',
      ),
    ];

    return Wrap(
      spacing: 16,
      runSpacing: 16,
      children: features
          .map((feature) => SizedBox(
                width: 280,
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsetsDirectional.all(12),
                      decoration: BoxDecoration(
                        color: context.primary.addOpacity(0.08),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Icon(
                        feature.icon,
                        size: 24,
                        color: context.primary,
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            feature.title,
                            style: context.titleSmall?.copyWith(
                              fontWeight: FontWeight.w700,
                            ),
                          ),
                          const SizedBox(height: 2),
                          Text(
                            feature.description,
                            style: context.bodySmall?.copyWith(
                              color: context.onSurface.addOpacity(0.6),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ))
          .toList(),
    );
  }

  Future<void> _showSupportedFormats(BuildContext context) async {
    final groupedExtensions = FileExtensionConfig.getGroupedExtensions();
    await showDialog<void>(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        child: Container(
          constraints: const BoxConstraints(
            maxWidth: 600,
            maxHeight: 700,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                padding: const EdgeInsetsDirectional.all(24),
                decoration: BoxDecoration(
                  color: context.primary.addOpacity(0.05),
                  borderRadius: const BorderRadiusDirectional.only(
                    topStart: Radius.circular(20),
                    topEnd: Radius.circular(20),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.file_present_rounded,
                      color: context.primary,
                      size: 28,
                    ),
                    const SizedBox(width: 12),
                    Text(
                      'Supported File Formats',
                      style: context.headlineSmall?.copyWith(
                        fontWeight: FontWeight.w700,
                        color: context.onSurface,
                      ),
                    ),
                    const Spacer(),
                    IconButton(
                      onPressed: () => Navigator.of(context).pop(),
                      icon: Icon(
                        Icons.close_rounded,
                        color: context.onSurface.addOpacity(0.6),
                      ),
                      style: IconButton.styleFrom(
                        backgroundColor: context.surface,
                      ),
                    ),
                  ],
                ),
              ),
              Flexible(
                child: SingleChildScrollView(
                  padding: const EdgeInsetsDirectional.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      for (final entry in groupedExtensions.entries) ...[
                        _buildFormatCategory(
                          context,
                          entry.key,
                          entry.value,
                        ),
                        if (entry.key != groupedExtensions.keys.last)
                          const SizedBox(height: 20),
                      ],
                    ],
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsetsDirectional.all(16),
                decoration: BoxDecoration(
                  color: context.surface,
                  borderRadius: const BorderRadiusDirectional.only(
                    bottomStart: Radius.circular(20),
                    bottomEnd: Radius.circular(20),
                  ),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info_outline_rounded,
                      size: 16,
                      color: context.onSurface.addOpacity(0.6),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        '${FileExtensionConfig.supportedExtensions.length} file types supported',
                        style: context.bodySmall?.copyWith(
                          color: context.onSurface.addOpacity(0.6),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildFormatCategory(
      BuildContext context, FileCategory category, List<String> extensions) {
    return Container(
      padding: const EdgeInsetsDirectional.all(16),
      decoration: BoxDecoration(
        color: context.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: context.outline.addOpacity(0.2),
          width: 1,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsetsDirectional.all(8),
                decoration: BoxDecoration(
                  color: context.primary.addOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  category.icon,
                  size: 20,
                  color: context.primary,
                ),
              ),
              const SizedBox(width: 12),
              Text(
                category.displayName,
                style: context.titleSmall?.copyWith(
                  fontWeight: FontWeight.w700,
                  color: context.onSurface,
                ),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsetsDirectional.symmetric(
                  horizontal: 8,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: context.primary.addOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${extensions.length}',
                  style: context.labelSmall?.copyWith(
                    color: context.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 6,
            runSpacing: 6,
            children: extensions
                .map((ext) => Container(
                      padding: const EdgeInsetsDirectional.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: context.surfaceContainerHighest,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        ext,
                        style: context.labelSmall?.copyWith(
                          fontFamily: 'monospace',
                          fontSize: 12,
                        ),
                      ),
                    ))
                .toList(),
          ),
        ],
      ),
    );
  }
}
```

### widgets/editor_settings_dialog.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../extensions/theme_extensions.dart';

class EditorSettings {

  const EditorSettings({
    this.fontSize = defaultFontSize,
    this.showLineNumbers = defaultShowLineNumbers,
    this.wordWrap = defaultWordWrap,
  });
  static const String keyFontSize = 'editor_font_size';
  static const String keyShowLineNumbers = 'editor_show_line_numbers';
  static const String keyWordWrap = 'editor_word_wrap';

  static const double defaultFontSize = 13;
  static const bool defaultShowLineNumbers = true;
  static const bool defaultWordWrap = false;

  final double fontSize;
  final bool showLineNumbers;
  final bool wordWrap;

  EditorSettings copyWith({
    double? fontSize,
    bool? showLineNumbers,
    bool? wordWrap,
  }) {
    return EditorSettings(
      fontSize: fontSize ?? this.fontSize,
      showLineNumbers: showLineNumbers ?? this.showLineNumbers,
      wordWrap: wordWrap ?? this.wordWrap,
    );
  }

  Future<void> save() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(keyFontSize, fontSize);
    await prefs.setBool(keyShowLineNumbers, showLineNumbers);
    await prefs.setBool(keyWordWrap, wordWrap);
  }

  static Future<EditorSettings> load() async {
    final prefs = await SharedPreferences.getInstance();
    return EditorSettings(
      fontSize: prefs.getDouble(keyFontSize) ?? defaultFontSize,
      showLineNumbers:
          prefs.getBool(keyShowLineNumbers) ?? defaultShowLineNumbers,
      wordWrap: prefs.getBool(keyWordWrap) ?? defaultWordWrap,
    );
  }
}

class EditorSettingsDialog extends StatefulWidget {

  const EditorSettingsDialog({
    super.key,
    required this.settings,
  });
  final EditorSettings settings;

  static Future<EditorSettings?> show(
    BuildContext context,
    EditorSettings currentSettings,
  ) async {
    return showDialog<EditorSettings>(
      context: context,
      builder: (context) => EditorSettingsDialog(settings: currentSettings),
    );
  }

  @override
  State<EditorSettingsDialog> createState() => _EditorSettingsDialogState();
}

class _EditorSettingsDialogState extends State<EditorSettingsDialog> {
  late EditorSettings _settings;

  @override
  void initState() {
    super.initState();
    _settings = widget.settings;
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Container(
        width: 400,
        padding: const EdgeInsetsDirectional.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.settings_outlined,
                  color: context.primary,
                ),
                const SizedBox(width: 12),
                Text(
                  'Editor Settings',
                  style: context.titleLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),

            // Font size
            _buildSectionTitle(context, 'Font Size'),
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: Slider(
                    value: _settings.fontSize,
                    min: 10,
                    max: 20,
                    divisions: 10,
                    label: '${_settings.fontSize.round()}px',
                    onChanged: (value) {
                      setState(() {
                        _settings = _settings.copyWith(fontSize: value);
                      });
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Container(
                  width: 60,
                  padding: const EdgeInsetsDirectional.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    color: context.primary.addOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: context.primary.addOpacity(0.3),
                    ),
                  ),
                  child: Text(
                    '${_settings.fontSize.round()}px',
                    style: context.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Preview
            Container(
              padding: const EdgeInsetsDirectional.all(12),
              decoration: BoxDecoration(
                color: context.isDark
                    ? Colors.black.addOpacity(0.3)
                    : Colors.grey.shade100,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: context.onSurface.addOpacity(0.1),
                ),
              ),
              child: Row(
                children: [
                  if (_settings.showLineNumbers) ...[
                    Text(
                      '1\n2\n3',
                      style: TextStyle(
                        fontFamily: 'monospace',
                        fontSize: _settings.fontSize * 0.9,
                        height: 1.4,
                        color: context.onSurface.addOpacity(0.4),
                      ),
                    ),
                    Container(
                      width: 1,
                      height: 50,
                      margin:
                          const EdgeInsetsDirectional.symmetric(horizontal: 12),
                      color: context.onSurface.addOpacity(0.1),
                    ),
                  ],
                  Expanded(
                    child: Text(
                      'Sample text preview\nLine 2 of code\nLine 3 of code',
                      style: TextStyle(
                        fontFamily: 'monospace',
                        fontSize: _settings.fontSize,
                        height: 1.4,
                        color: context.onSurface,
                      ),
                      softWrap: _settings.wordWrap,
                      overflow: _settings.wordWrap
                          ? TextOverflow.visible
                          : TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 24),

            // Options
            _buildSectionTitle(context, 'Display Options'),
            const SizedBox(height: 12),

            // Show line numbers
            _buildOptionTile(
              context,
              title: 'Show Line Numbers',
              subtitle: 'Display line numbers on the left side',
              value: _settings.showLineNumbers,
              onChanged: (value) {
                setState(() {
                  _settings = _settings.copyWith(showLineNumbers: value);
                });
              },
            ),

            // Word wrap
            _buildOptionTile(
              context,
              title: 'Word Wrap',
              subtitle: 'Wrap long lines instead of horizontal scrolling',
              value: _settings.wordWrap,
              onChanged: (value) {
                setState(() {
                  _settings = _settings.copyWith(wordWrap: value);
                });
              },
            ),

            const SizedBox(height: 24),

            // Actions
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancel'),
                ),
                const SizedBox(width: 8),
                FilledButton(
                  onPressed: () async {
                    await _settings.save();
                    if (mounted) {
                      Navigator.of(context).pop(_settings);
                    }
                  },
                  child: const Text('Apply'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    return Text(
      title,
      style: context.titleSmall?.copyWith(
        fontWeight: FontWeight.w600,
        color: context.onSurface.addOpacity(0.8),
      ),
    );
  }

  Widget _buildOptionTile(
    BuildContext context, {
    required String title,
    required String subtitle,
    required bool value,
    required ValueChanged<bool> onChanged,
  }) {
    return Padding(
      padding: const EdgeInsetsDirectional.only(bottom: 8),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () => onChanged(!value),
          borderRadius: BorderRadius.circular(8),
          child: Padding(
            padding: const EdgeInsetsDirectional.symmetric(
              horizontal: 12,
              vertical: 8,
            ),
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: context.bodyMedium?.copyWith(
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      Text(
                        subtitle,
                        style: context.labelSmall?.copyWith(
                          color: context.onSurface.addOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                ),
                Switch(
                  value: value,
                  onChanged: onChanged,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

### widgets/enhanced_text_editor.dart
- Language: dart
```dart
import 'package:flutter/material.dart';

import '../extensions/theme_extensions.dart';

class EnhancedTextEditor extends StatefulWidget {
  const EnhancedTextEditor({
    super.key,
    required this.content,
    this.onCopy,
    this.onScrollToTop,
    this.showLineNumbers = true,
    this.fontSize = 13,
    this.wordWrap = false,
  });

  final String content;
  final VoidCallback? onCopy;
  final VoidCallback? onScrollToTop;
  final bool showLineNumbers;
  final double fontSize;
  final bool wordWrap;

  @override
  State<EnhancedTextEditor> createState() => _EnhancedTextEditorState();
}

class _EnhancedTextEditorState extends State<EnhancedTextEditor>
    with SingleTickerProviderStateMixin {
  final ScrollController _verticalController = ScrollController();
  final ScrollController _horizontalController = ScrollController();
  final ScrollController _lineNumberController = ScrollController();

  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;

  List<String> _lines = [];
  int _totalLines = 0;
  int _totalCharacters = 0;

  @override
  void initState() {
    super.initState();
    _updateTextMetrics();

    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _fadeController,
      curve: Curves.easeIn,
    );
    _fadeController.forward();

    // Sync line numbers scroll with content scroll
    _verticalController.addListener(() {
      if (_lineNumberController.hasClients) {
        _lineNumberController.jumpTo(_verticalController.offset);
      }
    });
  }

  @override
  void didUpdateWidget(EnhancedTextEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.content != widget.content) {
      _updateTextMetrics();
      // Trigger fade animation on content change
      _fadeController.forward(from: 0);
    }
  }

  @override
  void dispose() {
    _verticalController.dispose();
    _horizontalController.dispose();
    _lineNumberController.dispose();
    _fadeController.dispose();
    super.dispose();
  }

  void _updateTextMetrics() {
    _lines = widget.content.split('\n');
    _totalLines = _lines.length;
    _totalCharacters = widget.content.length;
  }

  @override
  Widget build(BuildContext context) {
    final lineNumberWidth = _calculateLineNumberWidth();

    return Column(
      children: [
        // Main content area
        Expanded(
          child: FadeTransition(
            opacity: _fadeAnimation,
            child: Container(
              decoration: BoxDecoration(
                color: context.isDark
                    ? Colors.black.addOpacity(0.3)
                    : Colors.grey.shade50,
                border: Border.all(
                  color: context.onSurface.addOpacity(0.1),
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Line numbers
                    if (widget.showLineNumbers) ...[
                      Container(
                        width: lineNumberWidth,
                        decoration: BoxDecoration(
                          color: context.isDark
                              ? Colors.black.addOpacity(0.5)
                              : Colors.grey.shade100,
                          border: BorderDirectional(
                            end: BorderSide(
                              color: context.onSurface.addOpacity(0.1),
                            ),
                          ),
                        ),
                        child: SingleChildScrollView(
                          controller: _lineNumberController,
                          physics: const NeverScrollableScrollPhysics(),
                          child: Padding(
                            padding: const EdgeInsetsDirectional.only(
                              top: 12,
                              bottom: 12,
                              end: 8,
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.end,
                              children: List.generate(
                                _totalLines,
                                (index) => SizedBox(
                                  height: widget.fontSize * 1.4,
                                  child: Text(
                                    '${index + 1}',
                                    style: TextStyle(
                                      fontFamily: 'monospace',
                                      fontSize: widget.fontSize * 0.9,
                                      height: 1.4,
                                      color: context.onSurface.addOpacity(0.4),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                    ],

                    // Text content
                    Expanded(
                      child: widget.wordWrap
                          ? Scrollbar(
                              controller: _verticalController,
                              thumbVisibility: true,
                              child: SingleChildScrollView(
                                controller: _verticalController,
                                padding: const EdgeInsetsDirectional.all(12),
                                child: SelectableText(
                                  widget.content,
                                  style: TextStyle(
                                    fontFamily: 'monospace',
                                    fontSize: widget.fontSize,
                                    height: 1.4,
                                    color: context.onBackground,
                                  ),
                                  textAlign: TextAlign.start,
                                ),
                              ),
                            )
                          : Scrollbar(
                              controller: _horizontalController,
                              thumbVisibility: true,
                              child: SingleChildScrollView(
                                controller: _horizontalController,
                                scrollDirection: Axis.horizontal,
                                child: SizedBox(
                                  width: _calculateTextWidth(),
                                  child: Scrollbar(
                                    controller: _verticalController,
                                    thumbVisibility: true,
                                    child: SingleChildScrollView(
                                      controller: _verticalController,
                                      padding:
                                          const EdgeInsetsDirectional.all(12),
                                      child: SelectableText(
                                        widget.content,
                                        style: TextStyle(
                                          fontFamily: 'monospace',
                                          fontSize: widget.fontSize,
                                          height: 1.4,
                                          color: context.onBackground,
                                        ),
                                        textAlign: TextAlign.start,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),

        // Info bar
        Container(
          margin: const EdgeInsetsDirectional.only(top: 8),
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          decoration: BoxDecoration(
            color: context.isDark
                ? Colors.black.addOpacity(0.3)
                : Colors.grey.shade100,
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: context.onSurface.addOpacity(0.1),
            ),
          ),
          child: Row(
            children: [
              _buildInfoItem(
                context,
                icon: Icons.format_list_numbered,
                label: 'Lines',
                value: _totalLines.toString(),
              ),
              const SizedBox(width: 24),
              _buildInfoItem(
                context,
                icon: Icons.text_fields,
                label: 'Characters',
                value: _formatNumber(_totalCharacters),
              ),
              const Spacer(),
              // Action buttons
              if (widget.content.isNotEmpty) ...[
                _buildActionButton(
                  context,
                  icon: Icons.vertical_align_top,
                  tooltip: 'Scroll to top',
                  onPressed: () {
                    _verticalController.animateTo(
                      0,
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                    widget.onScrollToTop?.call();
                  },
                ),
                const SizedBox(width: 8),
                _buildActionButton(
                  context,
                  icon: Icons.copy,
                  tooltip: 'Copy to clipboard (⌘+C after selecting)',
                  onPressed: widget.onCopy,
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildInfoItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 14,
          color: context.onSurface.addOpacity(0.5),
        ),
        const SizedBox(width: 6),
        Text(
          '$label: ',
          style: context.labelSmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
          ),
        ),
        Text(
          value,
          style: context.labelSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface.addOpacity(0.8),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: context.primary.addOpacity(0.1),
        foregroundColor: context.primary,
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  double _calculateLineNumberWidth() {
    if (!widget.showLineNumbers) return 0;

    final maxDigits = _totalLines.toString().length;
    // Calculate width based on number of digits + padding
    return (maxDigits * 10.0) + 24.0;
  }

  double _calculateTextWidth() {
    // Calculate the maximum line length to determine horizontal scroll width
    double maxLineWidth = 0;
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
    );

    for (final line in _lines) {
      textPainter
        ..text = TextSpan(
          text: line,
          style: TextStyle(
            fontFamily: 'monospace',
            fontSize: widget.fontSize,
            height: 1.4,
          ),
        )
        ..layout();
      maxLineWidth =
          maxLineWidth > textPainter.width ? maxLineWidth : textPainter.width;
    }

    // Add padding and minimum width
    return (maxLineWidth + 48).clamp(500, double.infinity);
  }

  String _formatNumber(int number) {
    if (number < 1000) return number.toString();
    if (number < 1000000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    }
    return '${(number / 1000000).toStringAsFixed(1)}M';
  }
}
```

### widgets/file_list_widget.dart
- Language: dart
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../config/file_extensions.dart';
import '../extensions/theme_extensions.dart';
import '../models/file_item.dart';
import '../providers/file_collector_provider.dart';
import '../providers/settings_provider.dart';

class FileListWidget extends StatelessWidget {
  const FileListWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer2<FileCollectorProvider, SettingsProvider>(
      builder: (context, fileProvider, settingsProvider, child) {
        if (fileProvider.files.isEmpty) {
          return const Center(
            child: Text('No files added yet'),
          );
        }

        return ListView.builder(
          itemCount: fileProvider.files.length,
          itemBuilder: (context, index) {
            final file = fileProvider.files[index];
            return _FileListItem(
              file: file,
              activeExtensions: settingsProvider.activeExtensions,
              onToggle: () => fileProvider.toggleFileSelection(file),
              onRemove: () => fileProvider.removeFile(file),
            );
          },
        );
      },
    );
  }
}

class _FileListItem extends StatelessWidget {
  const _FileListItem({
    required this.file,
    required this.activeExtensions,
    required this.onToggle,
    required this.onRemove,
  });

  final FileItem file;
  final Map<String, FileCategory> activeExtensions;
  final VoidCallback onToggle;
  final VoidCallback onRemove;

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      margin: const EdgeInsetsDirectional.symmetric(
        horizontal: 12,
        vertical: 6,
      ),
      decoration: BoxDecoration(
        color: file.isSelected
            ? context.primary.addOpacity(0.05)
            : context.surface,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: file.isSelected
              ? context.primary.addOpacity(0.3)
              : context.outline.addOpacity(0.2),
          width: file.isSelected ? 1.5 : 1,
        ),
      ),
      child: Material(
        color: Colors.transparent,
        borderRadius: BorderRadius.circular(16),
        child: InkWell(
          onTap: onToggle,
          borderRadius: BorderRadius.circular(16),
          child: Padding(
            padding: const EdgeInsetsDirectional.all(16),
            child: Row(
              children: [
                _buildLeading(context),
                const SizedBox(width: 16),
                Expanded(
                  child: _buildContent(context),
                ),
                const SizedBox(width: 12),
                _buildTrailing(context),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLeading(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          width: 24,
          height: 24,
          decoration: BoxDecoration(
            color: file.isSelected ? context.primary : context.surface,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: file.isSelected
                  ? context.primary
                  : context.outline.addOpacity(0.5),
              width: 2,
            ),
          ),
          child: file.isSelected
              ? const Icon(
                  Icons.check_rounded,
                  size: 14,
                  color: Colors.white,
                )
              : null,
        ),
        const SizedBox(width: 12),
        _buildFileIcon(context),
      ],
    );
  }

  Widget _buildContent(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          file.name,
          style: context.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 4),
        Text(
          file.fullPath,
          style: context.bodySmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
            fontFamily: 'monospace',
            fontSize: 11,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 8),
        SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: Row(
            children: [
              _buildStatusChip(context),
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsetsDirectional.symmetric(
                  horizontal: 8,
                  vertical: 2,
                ),
                decoration: BoxDecoration(
                  color: context.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Text(
                  file.sizeFormatted,
                  style: context.labelSmall?.copyWith(
                    fontSize: 11,
                    color: context.onSurface.addOpacity(0.6),
                  ),
                ),
              ),
              if (file.getCategoryWithSettings(activeExtensions) != null) ...[
                const SizedBox(width: 8),
                Container(
                  padding: const EdgeInsetsDirectional.symmetric(
                    horizontal: 8,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: context.primary.addOpacity(0.1),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Text(
                    file.extension,
                    style: context.labelSmall?.copyWith(
                      fontSize: 11,
                      fontFamily: 'monospace',
                      color: context.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTrailing(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (file.isLoading)
          Container(
            width: 32,
            height: 32,
            padding: const EdgeInsetsDirectional.all(8),
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: context.primary,
            ),
          )
        else if (file.error != null)
          IconButton(
            icon: Icon(
              Icons.error_outline_rounded,
              color: context.error,
            ),
            onPressed: () => _showErrorDialog(context),
            tooltip: 'Show error',
            style: IconButton.styleFrom(
              backgroundColor: context.error.addOpacity(0.1),
            ),
          )
        else if (file.content != null)
          Container(
            padding: const EdgeInsetsDirectional.all(6),
            decoration: BoxDecoration(
              color: context.primary.addOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.check_rounded,
              color: context.primary,
              size: 20,
            ),
          ),
        const SizedBox(width: 8),
        IconButton(
          icon: const Icon(Icons.close_rounded),
          onPressed: onRemove,
          tooltip: 'Remove file',
          style: IconButton.styleFrom(
            foregroundColor: context.error,
            backgroundColor: context.error.addOpacity(0.1),
          ),
        ),
      ],
    );
  }

  Widget _buildFileIcon(BuildContext context) {
    final category = file.getCategoryWithSettings(activeExtensions);
    final isSupported = file.isTextFileWithSettings(activeExtensions);

    if (!isSupported || category == null) {
      return Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: context.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(10),
        ),
        child: Icon(
          Icons.insert_drive_file_outlined,
          color: context.onSurface.addOpacity(0.5),
          size: 20,
        ),
      );
    }

    // Get specific icon and color based on extension
    IconData iconData = category.icon;
    Color iconColor = context.primary;
    Color bgColor = context.primary.addOpacity(0.1);

    // Special cases for popular extensions
    switch (file.extension.toLowerCase()) {
      case '.dart':
        iconData = Icons.flutter_dash;
        iconColor = const Color(0xFF0175C2);
        bgColor = iconColor.addOpacity(0.1);
      case '.py':
        iconColor = const Color(0xFF3776AB);
        bgColor = iconColor.addOpacity(0.1);
      case '.js':
      case '.ts':
        iconColor = const Color(0xFFF7DF1E);
        bgColor = const Color(0xFF323330);
      case '.html':
        iconColor = const Color(0xFFE34F26);
        bgColor = iconColor.addOpacity(0.1);
      case '.css':
        iconColor = const Color(0xFF1572B6);
        bgColor = iconColor.addOpacity(0.1);
      case '.json':
        iconData = Icons.data_object_rounded;
      case '.md':
        iconData = Icons.article_rounded;
      case '.yaml':
      case '.yml':
        iconData = Icons.settings_rounded;
      case '.sql':
        iconData = Icons.storage_rounded;
      case '.dockerfile':
        iconData = Icons.directions_boat_rounded;
        iconColor = const Color(0xFF2496ED);
        bgColor = iconColor.addOpacity(0.1);
    }

    return Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(10),
      ),
      child: Icon(
        iconData,
        color: iconColor,
        size: 22,
      ),
    );
  }

  Widget _buildStatusChip(BuildContext context) {
    if (file.isLoading) {
      return Chip(
        label: const Text('Loading...'),
        labelStyle: context.labelSmall,
        backgroundColor: context.primary.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    if (file.error != null) {
      return Chip(
        label: const Text('Error'),
        labelStyle: context.labelSmall?.copyWith(
          color: context.error,
        ),
        backgroundColor: context.error.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    if (file.content != null) {
      return Chip(
        label: const Text('Loaded'),
        labelStyle: context.labelSmall?.copyWith(
          color: context.primary,
        ),
        backgroundColor: context.primary.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    if (!file.isTextFileWithSettings(activeExtensions)) {
      return Chip(
        label: const Text('Not Supported'),
        labelStyle: context.labelSmall?.copyWith(
          color: context.onSurface.addOpacity(0.6),
        ),
        backgroundColor: context.onSurface.addOpacity(0.1),
        side: BorderSide.none,
        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        visualDensity: VisualDensity.compact,
      );
    }

    return Chip(
      label: const Text('Ready'),
      labelStyle: context.labelSmall,
      backgroundColor: context.surface,
      side: BorderSide(
        color: context.onSurface.addOpacity(0.2),
      ),
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
      visualDensity: VisualDensity.compact,
    );
  }

  Future<void> _showErrorDialog(BuildContext context) async {
    await showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.error_outline, color: context.error),
            const SizedBox(width: 8),
            const Text('File Error'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'File: ${file.name}',
              style: context.titleSmall?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Error: ${file.error}',
              style: context.bodyMedium,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}
```

### widgets/monaco_editor_embedded.dart
- Language: dart
```dart
import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:webview_flutter/webview_flutter.dart';

import '../controllers/monaco_controller.dart';
import '../extensions/theme_extensions.dart';

/// Optimized Monaco Editor widget using single WebView implementation
class MonacoEditorEmbedded extends StatefulWidget {
  const MonacoEditorEmbedded({
    super.key,
    required this.controller,
    this.onReady,
    this.height,
  });

  final MonacoController controller;
  final VoidCallback? onReady;
  final double? height;

  @override
  State<MonacoEditorEmbedded> createState() => _MonacoEditorEmbeddedState();
}

class _MonacoEditorEmbeddedState extends State<MonacoEditorEmbedded> {
  late WebViewController _webViewController;
  bool _isLoading = true;
  String? _error;
  Timer? _initTimer;

  @override
  void initState() {
    super.initState();
    _initWebView();
  }

  @override
  void dispose() {
    _initTimer?.cancel();
    widget.controller.detachWebView();
    super.dispose();
  }

  Future<void> _initWebView() async {
    try {
      // Setup timeout
      _initTimer = Timer(const Duration(seconds: 10), () {
        if (!widget.controller.isReady && mounted) {
          setState(() {
            _error = 'Monaco Editor initialization timed out';
            _isLoading = false;
          });
        }
      });

      // Initialize WebViewController
      _webViewController = WebViewController();
      await _webViewController.setJavaScriptMode(JavaScriptMode.unrestricted);

      // Platform-specific setup
      if (!Platform.isMacOS) {
        await _webViewController.setBackgroundColor(Colors.transparent);
      }

      // Add communication channel
      await _webViewController.addJavaScriptChannel(
        'flutterChannel',
        onMessageReceived: _handleMessage,
      );

      // Set navigation delegate
      await _webViewController.setNavigationDelegate(
        NavigationDelegate(
          onProgress: (int progress) {
            if (progress == 100) {
              // Inject JS bridge code
              _webViewController.runJavaScript('''
                console.originalLog = console.log;
                console.log = function(...args) {
                  console.originalLog.apply(console, args);
                  if (window.flutterChannel) {
                    try {
                      window.flutterChannel.postMessage('log:' + args.join(' '));
                    } catch(e) {
                      console.originalLog('Error sending log to Flutter:', e);
                    }
                  }
                  if (args[0] === "Monaco editor instance created successfully") {
                    if (window.flutterChannel) {
                      window.flutterChannel.postMessage(JSON.stringify({event: 'onEditorReady'}));
                    }
                  }
                };
                
                // Force immediate execution to check for editor
                setTimeout(function() {
                  if (window.editor) {
                    if (window.flutterChannel) {
                      window.flutterChannel.postMessage(JSON.stringify({event: 'onEditorReady'}));
                    }
                  }
                }, 1000);
              ''');
            }
          },
          onPageFinished: (_) => _onPageLoaded(),
          onWebResourceError: _onLoadError,
          onNavigationRequest: (NavigationRequest request) {
            if (request.url.startsWith('flutter://')) {
              final payload = Uri.decodeFull(request.url.substring(10));
              _handleUrlMessage(payload);
              return NavigationDecision.prevent;
            }
            return NavigationDecision.navigate;
          },
        ),
      );

      // Load HTML
      await _loadMonacoHtml();

      // Attach to controller
      widget.controller.attachWebView(_webViewController);
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Failed to initialize Monaco: $e';
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _loadMonacoHtml() async {
    const asset = 'assets/monaco/index.html';

    try {
      if (Platform.isAndroid || Platform.isIOS) {
        // Mobile: Use loadFlutterAsset directly
        await _webViewController.loadFlutterAsset(asset);
        return;
      }

      // Desktop: We need to copy assets and inject the VS path
      final tempDir = await Directory.systemTemp.createTemp('monaco_editor');

      // Copy only essential Monaco files
      final vsPath = await _copyMonacoAssets(tempDir.path);

      // Load and modify the HTML content
      final htmlContent = await rootBundle.loadString(asset);
      final modifiedHtml = htmlContent.replaceAll('__VS_PATH__', vsPath);

      // Write the modified HTML to a temp file
      final htmlFile = File('${tempDir.path}/index.html');
      await htmlFile.writeAsString(modifiedHtml);

      // Load the temp HTML file
      await _webViewController.loadFile(htmlFile.path);

      // Schedule cleanup
      Future.delayed(const Duration(minutes: 5), () {
        try {
          tempDir.deleteSync(recursive: true);
        } catch (_) {
          // Ignore cleanup errors
        }
      });
    } catch (e) {
      throw Exception('Failed to load editor HTML: $e');
    }
  }

  Future<String> _copyMonacoAssets(String targetDir) async {
    final vsDir = Directory('$targetDir/vs');
    await vsDir.create(recursive: true);

    // Essential files only
    const essentialFiles = [
      'loader.js',
      'editor/editor.main.js',
      'editor/editor.main.css',
      'base/worker/workerMain.js',
    ];

    // Essential language files
    const languages = [
      'basic-languages/dart/dart.js',
      'basic-languages/javascript/javascript.js',
      'basic-languages/typescript/typescript.js',
      'basic-languages/python/python.js',
      'basic-languages/json/json.js',
      'basic-languages/html/html.js',
      'basic-languages/css/css.js',
      'basic-languages/yaml/yaml.js',
      'basic-languages/markdown/markdown.js',
      'basic-languages/xml/xml.js',
      'basic-languages/sql/sql.js',
      'basic-languages/shell/shell.js',
      // Advanced language support
      'language/typescript/tsMode.js',
      'language/typescript/tsWorker.js',
      'language/css/cssMode.js',
      'language/css/cssWorker.js',
      'language/json/jsonMode.js',
      'language/json/jsonWorker.js',
      'language/html/htmlMode.js',
      'language/html/htmlWorker.js',
    ];

    // Copy core files
    for (final file in essentialFiles) {
      await _copyAssetFile(
        'assets/monaco/monaco-editor/min/vs/$file',
        '$targetDir/vs/$file',
      );
    }

    // Copy language files
    for (final langFile in languages) {
      try {
        await _copyAssetFile(
          'assets/monaco/monaco-editor/min/vs/$langFile',
          '$targetDir/vs/$langFile',
        );
      } catch (_) {
        // Some language files might not exist, ignore
      }
    }

    // Copy required font file
    await _copyAssetFile(
      'assets/monaco/monaco-editor/min/vs/base/browser/ui/codicons/codicon/codicon.ttf',
      '$targetDir/vs/base/browser/ui/codicons/codicon/codicon.ttf',
    );

    return Uri.file(vsDir.path).toString();
  }

  Future<void> _copyAssetFile(String assetPath, String targetPath) async {
    final targetFile = File(targetPath);
    await targetFile.parent.create(recursive: true);

    final bytes = await rootBundle.load(assetPath);
    await targetFile.writeAsBytes(bytes.buffer.asUint8List());
  }

  void _handleUrlMessage(String payload) {
    if (payload.startsWith('onEditorReady')) {
      _onEditorReady();
    }
  }

  void _handleMessage(JavaScriptMessage message) {
    try {
      // Handle both direct messages and log messages
      if (message.message.startsWith('log:')) {
        // Console log message, ignore
        return;
      }

      final data = ConvertObject.tryToMap(message.message);
      final event = data.tryGetString('event');

      if (event == 'onEditorReady') {
        _onEditorReady();
      } else if (event == 'contentChanged') {
        // Handle content changes if needed
      }
    } catch (e) {
      // Try to handle as a simple string message
      if (message.message == 'EDITOR_READY_EVENT_FIRED') {
        _onEditorReady();
      } else {
        debugPrint('Error handling Monaco message: $e');
      }
    }
  }

  void _onPageLoaded() {
    // Page loaded, waiting for editor ready
    if (mounted) {
      setState(() {
        _isLoading = true;
      });
    }
  }

  void _onLoadError(WebResourceError error) {
    if (mounted) {
      setState(() {
        _error = 'Failed to load Monaco: ${error.description}';
        _isLoading = false;
      });
    }
  }

  Future<void> _onEditorReady() async {
    _initTimer?.cancel();

    widget.controller.markReady();

    // Apply initial content if any
    if (widget.controller.content.isNotEmpty) {
      await widget.controller.setContent(widget.controller.content);
    }

    // Apply initial options
    await widget.controller.updateOptions();

    if (mounted) {
      setState(() {
        _isLoading = false;
      });
    }

    widget.onReady?.call();
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return _buildErrorView();
    }

    return SizedBox(
      height: widget.height ?? double.infinity,
      child: Stack(
        children: [
          WebViewWidget(controller: _webViewController),
          if (_isLoading)
            ColoredBox(
              color: context.isDark ? const Color(0xFF1E1E1E) : Colors.white,
              child: Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const CircularProgressIndicator(),
                    const SizedBox(height: 16),
                    Text(
                      'Loading Monaco Editor...',
                      style: context.bodyMedium?.copyWith(
                        color: context.onSurface.addOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildErrorView() {
    return Container(
      padding: const EdgeInsets.all(32),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: context.error,
            ),
            const SizedBox(height: 16),
            Text(
              'Failed to load Monaco Editor',
              style: context.titleLarge?.copyWith(
                color: context.error,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _error ?? 'Unknown error',
              textAlign: TextAlign.center,
              style: context.bodyMedium?.copyWith(
                color: context.onSurface.addOpacity(0.6),
              ),
            ),
            const SizedBox(height: 24),
            OutlinedButton.icon(
              onPressed: () {
                setState(() {
                  _error = null;
                  _isLoading = true;
                });
                _initWebView();
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }
}
```

### widgets/monaco_editor_info_bar.dart
- Language: dart
```dart
import 'package:context_collector/extensions/theme_extensions.dart';
import 'package:flutter/material.dart';

import '../controllers/monaco_controller.dart';

/// Enhanced info bar for Monaco editor with better controls
class MonacoEditorInfoBar extends StatefulWidget {
  const MonacoEditorInfoBar({
    super.key,
    required this.controller,
    required this.onCopy,
    required this.onSettings,
  });

  final MonacoController controller;
  final VoidCallback onCopy;
  final VoidCallback onSettings;

  @override
  State<MonacoEditorInfoBar> createState() => _MonacoEditorInfoBarState();
}

class _MonacoEditorInfoBarState extends State<MonacoEditorInfoBar> {
  final List<String> _supportedLanguages = [
    'plaintext',
    'dart',
    'html',
    'css',
    'javascript',
    'typescript',
    'json',
    'yaml',
    'markdown',
    'python',
    'shell',
    'xml',
    'sql',
  ];

  final List<({String value, String label})> _themes = [
    (value: 'vs', label: 'Light'),
    (value: 'vs-dark', label: 'Dark'),
    (value: 'hc-black', label: 'High Contrast'),
  ];

  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: widget.controller,
      builder: (context, _) {
        if (!widget.controller.isReady) {
          return const SizedBox.shrink();
        }

        return Container(
          margin: const EdgeInsetsDirectional.only(top: 8),
          padding: const EdgeInsetsDirectional.symmetric(
            horizontal: 16,
            vertical: 8,
          ),
          decoration: BoxDecoration(
            color: context.isDark
                ? Colors.black.addOpacity(0.3)
                : Colors.grey.shade100,
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: context.onSurface.addOpacity(0.1),
            ),
          ),
          child: Row(
            children: [
              // Language selector
              _buildDropdownSelector(
                context,
                icon: Icons.code,
                label: 'Language',
                value: widget.controller.language,
                items: _supportedLanguages
                    .map((lang) => DropdownMenuItem(
                          value: lang,
                          child: Text(
                            lang == 'plaintext'
                                ? 'Plain Text'
                                : _capitalize(lang),
                          ),
                        ))
                    .toList(),
                onChanged: (value) {
                  if (value != null) {
                    widget.controller.setLanguage(value);
                  }
                },
              ),
              const SizedBox(width: 16),

              // Theme selector
              _buildDropdownSelector(
                context,
                icon: Icons.palette,
                label: 'Theme',
                value: widget.controller.theme,
                items: _themes
                    .map((theme) => DropdownMenuItem(
                          value: theme.value,
                          child: Text(theme.label),
                        ))
                    .toList(),
                onChanged: (value) {
                  if (value != null) {
                    widget.controller.setTheme(value);
                  }
                },
              ),

              const Spacer(),

              // Quick toggles
              _buildToggleButton(
                context,
                icon: Icons.wrap_text,
                tooltip: widget.controller.wordWrap
                    ? 'Disable word wrap'
                    : 'Enable word wrap',
                isActive: widget.controller.wordWrap,
                onPressed: () {
                  widget.controller.updateOptions(
                    wordWrap: !widget.controller.wordWrap,
                  );
                },
              ),
              const SizedBox(width: 8),

              _buildToggleButton(
                context,
                icon: Icons.format_list_numbered,
                tooltip: widget.controller.showLineNumbers
                    ? 'Hide line numbers'
                    : 'Show line numbers',
                isActive: widget.controller.showLineNumbers,
                onPressed: () {
                  widget.controller.updateOptions(
                    showLineNumbers: !widget.controller.showLineNumbers,
                  );
                },
              ),
              const SizedBox(width: 8),

              _buildToggleButton(
                context,
                icon: widget.controller.readOnly ? Icons.edit_off : Icons.edit,
                tooltip: widget.controller.readOnly
                    ? 'Enable editing'
                    : 'Disable editing (Read-only)',
                isActive: !widget.controller.readOnly,
                onPressed: () {
                  widget.controller.updateOptions(
                    readOnly: !widget.controller.readOnly,
                  );
                },
              ),
              const SizedBox(width: 8),

              // Divider
              Container(
                height: 24,
                width: 1,
                color: context.onSurface.addOpacity(0.2),
              ),
              const SizedBox(width: 8),

              // Action buttons
              _buildActionButton(
                context,
                icon: Icons.search,
                tooltip: 'Find (Ctrl/Cmd+F)',
                onPressed: () => widget.controller.find(),
              ),
              const SizedBox(width: 8),

              _buildActionButton(
                context,
                icon: Icons.format_align_left,
                tooltip: 'Format document',
                onPressed: () => widget.controller.format(),
              ),
              const SizedBox(width: 8),

              _buildActionButton(
                context,
                icon: Icons.vertical_align_top,
                tooltip: 'Scroll to top',
                onPressed: () => widget.controller.scrollToTop(),
              ),
              const SizedBox(width: 8),

              _buildActionButton(
                context,
                icon: Icons.copy,
                tooltip: 'Copy to clipboard',
                onPressed: widget.onCopy,
              ),
              const SizedBox(width: 8),

              _buildActionButton(
                context,
                icon: Icons.settings,
                tooltip: 'Editor settings',
                onPressed: widget.onSettings,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildDropdownSelector<T>(
    BuildContext context, {
    required IconData icon,
    required String label,
    required T value,
    required List<DropdownMenuItem<T>> items,
    required ValueChanged<T?> onChanged,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: context.isDark
            ? Colors.black.addOpacity(0.2)
            : Colors.white.addOpacity(0.9),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: context.onSurface.addOpacity(0.1),
        ),
      ),
      padding: const EdgeInsetsDirectional.symmetric(
        horizontal: 12,
        vertical: 4,
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 16,
            color: context.onSurface.addOpacity(0.7),
          ),
          const SizedBox(width: 8),
          Text(
            '$label:',
            style: context.labelSmall?.copyWith(
              color: context.onSurface.addOpacity(0.7),
            ),
          ),
          const SizedBox(width: 8),
          DropdownButton<T>(
            value: value,
            items: items,
            onChanged: onChanged,
            underline: const SizedBox(),
            borderRadius: BorderRadius.circular(8),
            isDense: true,
            style: context.bodySmall?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: context.primary.addOpacity(0.1),
        foregroundColor: context.primary,
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  Widget _buildToggleButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    required bool isActive,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: isActive
            ? context.primary.addOpacity(0.2)
            : context.onSurface.addOpacity(0.05),
        foregroundColor:
            isActive ? context.primary : context.onSurface.addOpacity(0.6),
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  String _capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }
}
```

### widgets/monaco_editor_widget.dart
- Language: dart
```dart
import 'dart:developer';
import 'dart:io';

import 'package:desktop_webview_window/desktop_webview_window.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path/path.dart' as p;

import '../extensions/theme_extensions.dart';

class MonacoEditorWidget extends StatefulWidget {
  const MonacoEditorWidget({
    super.key,
    required this.content,
    this.onCopy,
    this.onScrollToTop,
    this.showLineNumbers = true,
    this.fontSize = 13,
    this.wordWrap = false,
    this.readOnly = true,
  });

  final String content;
  final VoidCallback? onCopy;
  final VoidCallback? onScrollToTop;
  final bool showLineNumbers;
  final double fontSize;
  final bool wordWrap;
  final bool readOnly;

  @override
  State<MonacoEditorWidget> createState() => _MonacoEditorWidgetState();
}

class _MonacoEditorWidgetState extends State<MonacoEditorWidget> {
  Webview? _webview;
  bool _isReady = false;
  bool _isLoading = true;
  String? _error;

  // Metrics
  int _totalLines = 0;
  int _totalCharacters = 0;

  // Store temp directory for cleanup
  Directory? _tempDir;

  @override
  void initState() {
    super.initState();
    _initWebview();
    _updateMetrics();
  }

  @override
  void didUpdateWidget(MonacoEditorWidget oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.content != widget.content) {
      _updateContent();
      _updateMetrics();
    }

    if (oldWidget.fontSize != widget.fontSize ||
        oldWidget.showLineNumbers != widget.showLineNumbers ||
        oldWidget.wordWrap != widget.wordWrap) {
      _updateOptions();
    }
  }

  void _updateMetrics() {
    setState(() {
      _totalLines = widget.content.split('\n').length;
      _totalCharacters = widget.content.length;
    });
  }

  Future<void> _initWebview() async {
    try {
      // Check if WebView is available
      if (!await WebviewWindow.isWebviewAvailable()) {
        setState(() {
          _error =
              'WebView is not available. Please install Edge WebView2 Runtime.';
          _isLoading = false;
        });
        return;
      }

      // Create WebView window
      _webview = await WebviewWindow.create(
        configuration: CreateConfiguration(
          userDataFolderWindows: await _getWebViewDataPath(),
          windowHeight: 800,
          windowWidth: 1000,
          title: 'Monaco Editor',
        ),
      );

      // Set up JavaScript handlers
      _webview!.addScriptToExecuteOnDocumentCreated('''
        window.flutter_inappwebview = {
          callHandler: function(handlerName, ...args) {
            window.chrome.webview.postMessage({
              event: handlerName,
              payload: args.length > 0 ? args[0] : undefined
            });
          }
        };
      ''');

      // Listen for messages from JavaScript
      _webview!.addOnWebMessageReceivedCallback((message) {
        try {
          final data = ConvertObject.toMap(message, defaultValue: {});
          final event = data['event']?.toString() ?? '';

          switch (event) {
            case 'onEditorReady':
              _onEditorReady();
            case 'onContentChanged':
              // Since we're in read-only mode, this shouldn't happen
              break;
          }
        } catch (e, s) {
          log('Error processing message from WebView: $e',
              error: e, stackTrace: s);
        }
      });

      // Load the editor HTML
      final htmlPath = await _prepareEditorHtml();
      _webview!.launch(htmlPath);
    } catch (e) {
      setState(() {
        _error = 'Failed to initialize editor: $e';
        _isLoading = false;
      });
    }
  }

  Future<String> _getWebViewDataPath() async {
    final appDir = Directory.current.path;
    final dataPath = p.join(appDir, 'webview_data');
    await Directory(dataPath).create(recursive: true);
    return dataPath;
  }

  Future<String> _prepareEditorHtml() async {
    // Create a temporary directory to hold Monaco files
    _tempDir = await Directory.systemTemp.createTemp('monaco_editor_window');

    // Get VS path which will be an absolute file:// URL
    final vsPath = Uri.file(p.join(_tempDir!.path, 'vs')).toString();

    // Copy required Monaco files to temp directory
    await _copyAssetDirectory(
        'assets/monaco/monaco-editor/min/vs', p.join(_tempDir!.path, 'vs'));

    // Load and modify the HTML content
    final htmlContent = await rootBundle.loadString('assets/monaco/index.html');
    final modifiedHtml = htmlContent.replaceAll('__VS_PATH__', vsPath);

    // Write the modified HTML to temp file
    final htmlFile = File(p.join(_tempDir!.path, 'index.html'));
    await htmlFile.writeAsString(modifiedHtml);

    // Return the full file URL
    return 'file://${htmlFile.path}';
  }

  Future<void> _copyAssetDirectory(String assetDir, String targetDir) async {
    try {
      // Create the target directory if it doesn't exist
      final targetDirFile = Directory(targetDir);
      if (!targetDirFile.existsSync()) {
        await targetDirFile.create(recursive: true);
      }

      // Create editor directory
      final editorDir = Directory(p.join(targetDir, 'editor'));
      if (!editorDir.existsSync()) {
        await editorDir.create(recursive: true);
      }

      // Use the monaco-editor/min/vs path
      const corePath = 'assets/monaco/monaco-editor/min/vs';

      try {
        // Copy core files
        final loaderBytes = await rootBundle.load('$corePath/loader.js');
        await File(p.join(targetDir, 'loader.js'))
            .writeAsBytes(loaderBytes.buffer.asUint8List());

        final editorJsBytes =
            await rootBundle.load('$corePath/editor/editor.main.js');
        await File(p.join(targetDir, 'editor', 'editor.main.js'))
            .writeAsBytes(editorJsBytes.buffer.asUint8List());

        final editorCssBytes =
            await rootBundle.load('$corePath/editor/editor.main.css');
        await File(p.join(targetDir, 'editor', 'editor.main.css'))
            .writeAsBytes(editorCssBytes.buffer.asUint8List());
      } catch (e, s) {
        log('Error copying core Monaco files: $e', error: e, stackTrace: s);
      }
    } catch (e, s) {
      log('Error copying Monaco asset directory: $e', error: e, stackTrace: s);
    }
  }

  void _onEditorReady() {
    if (mounted) {
      setState(() {
        _isReady = true;
        _isLoading = false;
      });

      // Initialize the editor content and options
      _updateContent();
      _updateOptions();
    }
  }

  void _updateContent() {
    if (!_isReady || _webview == null) return;

    final escapedContent = widget.encode();
    _webview!.evaluateJavaScript('window.setEditorContent($escapedContent);');
  }

  void _updateOptions() {
    if (!_isReady || _webview == null) return;

    final options = {
      'fontSize': widget.fontSize,
      'lineNumbers': widget.showLineNumbers ? 'on' : 'off',
      'wordWrap': widget.wordWrap ? 'on' : 'off',
      'readOnly': widget.readOnly,
      'theme': context.isDark ? 'vs-dark' : 'vs',
      // Disable linter
      'diagnostics': false,
      'formatOnType': false,
      'formatOnPaste': false,
      'lightbulb': {'enabled': false},
    };

    final optionsJson = options.encode();
    _webview!.evaluateJavaScript('window.setEditorOptions($optionsJson);');
  }

  @override
  void dispose() {
    // Close the WebView window
    _webview?.close();

    _tempDir?.delete(recursive: true).catchError((dynamic e) {
      log('Error deleting temp directory: $e');
      return _tempDir ?? Directory.systemTemp;
    });

    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return _buildErrorView(context);
    }

    if (_isLoading) {
      return _buildLoadingView(context);
    }

    return Column(
      children: [
        // Main content area
        Expanded(
          child: Container(
            decoration: BoxDecoration(
              color: context.isDark
                  ? Colors.black.addOpacity(0.3)
                  : Colors.grey.shade50,
              border: Border.all(
                color: context.onSurface.addOpacity(0.1),
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: const Center(
                child: Text(
                  'Monaco Editor is running in a separate window',
                  style: TextStyle(color: Colors.grey),
                ),
              ),
            ),
          ),
        ),

        // Info bar
        _buildInfoBar(context),
      ],
    );
  }

  Widget _buildLoadingView(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            'Loading Monaco Editor...',
            style: context.bodyLarge?.copyWith(
              color: context.onSurface.addOpacity(0.6),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorView(BuildContext context) {
    return Center(
      child: Container(
        padding: const EdgeInsetsDirectional.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: context.error,
            ),
            const SizedBox(height: 16),
            Text(
              'Failed to load editor',
              style: context.titleLarge?.copyWith(
                color: context.error,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _error!,
              textAlign: TextAlign.center,
              style: context.bodyMedium?.copyWith(
                color: context.onSurface.addOpacity(0.6),
              ),
            ),
            const SizedBox(height: 24),
            OutlinedButton.icon(
              onPressed: () {
                setState(() {
                  _error = null;
                  _isLoading = true;
                });
                _initWebview();
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoBar(BuildContext context) {
    return Container(
      margin: const EdgeInsetsDirectional.only(top: 8),
      padding: const EdgeInsetsDirectional.symmetric(
        horizontal: 16,
        vertical: 8,
      ),
      decoration: BoxDecoration(
        color: context.isDark
            ? Colors.black.addOpacity(0.3)
            : Colors.grey.shade100,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: context.onSurface.addOpacity(0.1),
        ),
      ),
      child: Row(
        children: [
          _buildInfoItem(
            context,
            icon: Icons.format_list_numbered,
            label: 'Lines',
            value: _totalLines.toString(),
          ),
          const SizedBox(width: 24),
          _buildInfoItem(
            context,
            icon: Icons.text_fields,
            label: 'Characters',
            value: _formatNumber(_totalCharacters),
          ),
          const Spacer(),
          // Action buttons
          if (widget.content.isNotEmpty) ...[
            _buildActionButton(
              context,
              icon: Icons.vertical_align_top,
              tooltip: 'Scroll to top',
              onPressed: () {
                _webview?.evaluateJavaScript(
                    'window.editor.setScrollPosition({scrollTop: 0, scrollLeft: 0});');
                widget.onScrollToTop?.call();
              },
            ),
            const SizedBox(width: 8),
            _buildActionButton(
              context,
              icon: Icons.copy,
              tooltip: 'Copy to clipboard',
              onPressed: widget.onCopy,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoItem(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 14,
          color: context.onSurface.addOpacity(0.5),
        ),
        const SizedBox(width: 6),
        Text(
          '$label: ',
          style: context.labelSmall?.copyWith(
            color: context.onSurface.addOpacity(0.5),
          ),
        ),
        Text(
          value,
          style: context.labelSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: context.onSurface.addOpacity(0.8),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String tooltip,
    VoidCallback? onPressed,
  }) {
    return IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: 18,
      tooltip: tooltip,
      style: IconButton.styleFrom(
        backgroundColor: context.primary.addOpacity(0.1),
        foregroundColor: context.primary,
        padding: const EdgeInsetsDirectional.all(6),
        minimumSize: const Size(32, 32),
      ),
    );
  }

  String _formatNumber(int number) {
    if (number < 1000) return number.toString();
    if (number < 1000000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    }
    return '${(number / 1000000).toStringAsFixed(1)}M';
  }
}
```

### widgets/resizable_splitter.dart
- Language: dart
```dart
import 'dart:developer';

import 'package:context_collector/extensions/theme_extensions.dart';
import 'package:flutter/material.dart';

/// A widget that allows resizing two panels with a draggable divider
class ResizableSplitter extends StatefulWidget {
  const ResizableSplitter({
    super.key,
    required this.startPanel,
    required this.endPanel,
    this.initialRatio = 0.4,
    this.minRatio = 0.2,
    this.maxRatio = 0.8,
    this.dividerThickness = 8,
    this.onRatioChanged,
  });

  final Widget startPanel;
  final Widget endPanel;
  final double initialRatio;
  final double minRatio;
  final double maxRatio;
  final double dividerThickness;
  final ValueChanged<double>? onRatioChanged;

  @override
  State<ResizableSplitter> createState() => _ResizableSplitterState();
}

class _ResizableSplitterState extends State<ResizableSplitter> {
  late double _ratio;
  bool _isDragging = false;

  @override
  void initState() {
    super.initState();
    _ratio = widget.initialRatio;
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    RenderBox? box;
    try {
      box = context.findRenderObject() as RenderBox?;
    } catch (e, s) {
      log('Error finding render object: $e', error: e, stackTrace: s);
    }

    final width = box?.size.width ?? 0;

    setState(() {
      _ratio += details.delta.dx / width;
      _ratio = _ratio.clamp(widget.minRatio, widget.maxRatio);
    });

    widget.onRatioChanged?.call(_ratio);
  }

  void _handleDragStart(DragStartDetails details) {
    setState(() {
      _isDragging = true;
    });
  }

  void _handleDragEnd(DragEndDetails details) {
    setState(() {
      _isDragging = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final startWidth =
            constraints.maxWidth * _ratio - widget.dividerThickness / 2;
        final endWidth =
            constraints.maxWidth * (1 - _ratio) - widget.dividerThickness / 2;

        return Row(
          children: [
            // Start panel
            SizedBox(
              width: startWidth,
              child: widget.startPanel,
            ),

            // Draggable divider
            MouseRegion(
              cursor: SystemMouseCursors.resizeColumn,
              child: GestureDetector(
                onHorizontalDragStart: _handleDragStart,
                onHorizontalDragUpdate: _handleDragUpdate,
                onHorizontalDragEnd: _handleDragEnd,
                child: Container(
                  width: widget.dividerThickness,
                  color: Colors.transparent,
                  child: Center(
                    child: Container(
                      width: _isDragging ? 3 : 1,
                      decoration: BoxDecoration(
                        color: _isDragging
                            ? context.primary
                            : context.onSurface.addOpacity(0.2),
                        borderRadius: BorderRadius.circular(2),
                      ),
                    ),
                  ),
                ),
              ),
            ),

            // End panel
            SizedBox(
              width: endWidth,
              child: widget.endPanel,
            ),
          ],
        );
      },
    );
  }
}
```
Below is a practical roadmap you can follow over a weekend refactor sprint.  The goal is to keep every visible feature working exactly as it does today, while making the internals easier to grow and reason about six-months from now.

---

## 1. Quick health-check

| What already feels solid                                                                                         | Where you’ll feel pain later                                                                                                                                            |
| ---------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Clean provider wiring.**  `HomeScreen` injects `SettingsProvider` into `FileCollectorProvider` only once—good. | **Feature code scattered.**  UI widgets, state classes, “services” and helpers are spread across top-level folders, so it’s hard to see *what belongs to what feature*. |
| **Thoughtful UX.**  Drag-and-drop, animated loading, and Monaco settings show nice polish.                       | **Providers mix concerns.**  `FileCollectorProvider` does UI selection state *and* disk IO *and* string assembly.                                                       |
| **Extension types are enumerated in one place.**  `FileExtensionConfig` is a tidy lookup.                        | **‘lib/’ is already crowded.**  In six months you’ll add more panels or an export format and the root will explode.                                                     |
| **Custom theming helpers reduce boilerplate.**                                                                   | **Controller vs Provider blur.**  `MonacoController` is UI-only; `FileCollectorProvider` is half-controller half-domain.  Naming doesn’t make that obvious.             |

---

## 2. Rename for intent

| Current                   | Rename                                        | Rationale                                                                                                                                       |
| ------------------------- | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `FileCollectorProvider`   | **`SelectionCubit`** (or `SelectedFilesBloc`) | Holds *UI* state about which files the user picked; does not need to know about disk IO.                                                        |
| `settings_provider.dart`  | **`PreferencesCubit`**                        | Exposes user-preferences as reactive state; “provider” is a generic Flutter word, but “Cubit” or “Notifier” tells future you *how* it notifies. |
| `MonacoController`        | **`MonacoBridge`**                            | Purely a bridge between Flutter and the WebView.  “Controller” clashes with Flutter’s own `TextEditingController`.                              |
| `extension_settings.dart` | **`ExtensionPrefs`**                          | A value object of preference data.                                                                                                              |
| `file_item.dart`          | **`ScannedFile`**                             | Makes it clear that this is a DTO representing something scanned from disk, not from the network.                                               |

---

## 3. Restructure folders by feature, then by layer

```
lib/
└── src/
    ├── bootstrap/          // main.dart, window setup
    ├── features/
    │   ├── scan/
    │   │   ├── data/       // disk scanning + content reading
    │   │   ├── domain/     // ScannedFile, extension logic
    │   │   └── presentation/
    │   │       ├── state/  // SelectionCubit
    │   │       └── ui/     // FileListWidget, DropZoneWidget
    │   ├── editor/
    │   │   ├── bridge/     // MonacoBridge
    │   │   ├── domain/     // EditorSettings
    │   │   └── presentation/
    │   │       ├── ui/     // CombinedContentWidget, InfoBar
    │   │       └── state/  // nothing yet – editor is self-contained
    │   └── settings/
    │       ├── domain/     // ExtensionPrefs
    │       ├── presentation/
    │       │   ├── state/  // PreferencesCubit
    │       │   └── ui/     // SettingsScreen, dialogs
    └── shared/
        ├── theme/
        ├── utils/
        └── widgets/        // small reusable pieces (ResizableSplitter, etc.)
```

*Why not “core/data/ui” at the root?*  Because you read features first (“scan”, “editor”), then drill down.  It scales better when you add an *export* or *cloud-sync* feature—you drop a new folder under `features/`.

---

## 4. Slice big classes

### 4.1 Disk work vs UI work

Create a small service called `ContentAssembler` inside **scan/data**:

```dart
/// Turns a list of ScannedFile into the giant markdown string.
class ContentAssembler {
  Future<String> buildMerged(List<ScannedFile> files) async { … }
}
```

`SelectionCubit` would emit a `List<ScannedFile>` and call the service in a background isolate (easy with `compute`).  The cubit then exposes `mergedContent` as state for the editor UI.
Result: UI never blocks while you read a 200 MB log file.

### 4.2 Error handling

Wrap all disk IO in a tiny `Either<Failure,T>` type or use `dartz`.  The cubit can then map failures to error snackbars in one place.

---

## 5. API surface clean-up

1. **Replace `isTextFileWithSettings`** with a top-level function:

   ```dart
   bool supportsText(String ext, ExtensionPrefs prefs) { … }
   ```

   That keeps `ScannedFile` immutable and dumb.

2. `FileExtensionConfig` can be promoted to `/shared/constants/extension_catalog.dart` – it’s “read-only knowledge,” not config.

3. Give every cubit a tiny event log (`debugPrint`) in `onChange` so you can replay a bug later.

---

## 6. Migration plan

| Day             | Task                                                                                                                                            |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| **Morning 1**   | Create new folder structure, move *one* feature (settings) into it, keep import prefixes the same using `export` shims so the app still builds. |
| **Afternoon 1** | Rename providers and classes (IDE rename) – run tests / hot-reload often.                                                                       |
| **Morning 2**   | Extract `ContentAssembler`, shift heavy work off `SelectionCubit`.  Verify large directory still loads.                                         |
| **Afternoon 2** | Delete temporary shims, run `dart fix`, bump version, push tag.                                                                                 |

---

## 7. What *not* to change (for now)

* **State-management library.**  Stick with `provider`/`ChangeNotifier` until the dust settles; migrating to Riverpod later is trivial once layers are clean.
* **Monaco embedding.**  Your bridge works; don’t chase extra performance unless you hit jank.
* **Theme constants.**  They live fine in one file; no need for separation.

---

### TL;DR

Group by **feature first**, slice disk logic away from UI state, and rename classes so the next developer guesses their job without reading the code.  Two focused days should get you there without breaking a single pixel of the current UX.

Happy refactoring!
